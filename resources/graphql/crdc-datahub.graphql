scalar Date

type Application {
    # backend managed fields
    _id: ID!
    status: String # [New, In Progress, Submitted, In Review, Approved, Rejected]
    createdAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
    updatedAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
    submittedDate: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
    history: [Event] # An Event will be appended to the list whenever Application's status changes
    applicant: Applicant # auto populated by BE
    organization: Organization
    # sort fields
    programName: String
    studyAbbreviation: String
    # questionnaire data as JSON string
    questionnaireData: String
}

type Event {
    status: String # valid values are the same as it's parent
    reviewComment: String # if applicable
    dateTime: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
    userID: ID!
}

input AppInput {
    _id: ID
    programName: String
    studyAbbreviation: String
    questionnaireData: String
}

type Applicant {
    applicantID: ID # auto populated by BE
    applicantName: String # auto populated by BE
    applicantEmail: String # auto populated by BE
}

type Organization {
    _id: ID
    name: String
}

type ListApplications {
    total: Int
    applications: [Application]
}

type ListSubmissions {
    total: Int
    submissions: [Submission]
}

type Submission {
    _id: ID # aka. submissionID
    name: String
    submitterID: ID
    submitterName: String # <first name> <last name>
    organization: Organization
    dataCommons: String
    modelVersion: String # for future use
    studyAbbreviation: String
    dbGaPID: String # aka. phs number
    bucketName: String # populated from organization
    rootPath: String # append "/<submission ID>" to organization's rootPath
    status: String # [New, In Progress, Submitted, Released, Canceled, Transferred, Completed, Archived]
    metadataValidationStatus: String # [New, Validating, Passed, Error, Warning], new successfully uploaded batch will set it to "New"
    fileValidationStatus: String # [New, Validating, Passed, Error, Warning], new successfully uploaded batch will set it to "New"
    fileErrors: [ErrorMessage] # holds submission level file errors, e.g., extra files in S3 folder
    fileWarnings: [ErrorMessage] # holds submission level file warnings
    history: [Event]
    conciergeName: String # Concierge name
    conciergeEmail: String # Concierge email
    errors: [ErrorMessage] # store validation errors
    createdAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
    updatedAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
    
}

type Batch {
    _id: ID
    submissionID: ID # parent
    type: String # [metadata, file]
    metadataIntention: String # [New, Update, Delete], Update is meant for "Update or insert", metadata only! file batches are always treated as Update
    fileCount: Int # calculated by BE
    files: [FileInfo]
    status: String # [Uploading, Uploaded, Upload Failed, Loaded, Rejected] Loaded and Rejected are for metadata batch only
    errors: [String]
    displayID: Int
    createdAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
    updatedAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
}

type ListBatches {
    total: Int
    batches: [Batch]
}

type FileInfo {
    filePrefix: String # prefix/path within S3 bucket
    fileName: String
    size: Int
    status: String # [New, Uploaded, Failed]
    errors: [String]
    createdAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
    updatedAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
}

type NewBatch {
    _id: ID
    submissionID: ID
    bucketName: String # S3 bucket of the submission, for file batch / CLI use
    filePrefix: String # prefix/path within S3 bucket, for file batch / CLI use
    type: String # [metadata, file]
    metadataIntention: String # [New, Update, Delete], Update is meant for "Update or insert", metadata only! file batches are always treated as Update
    fileCount: Int
    files: [FileURL] # only available for metadata batch
    status: String # [Uploading, Uploaded, Upload Failed, Loaded, Rejected]
    createdAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
    updatedAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
}

type FileURL {
    fileName: String
    signedURL: String
}

input FileInput {
    fileName: String
    size: Int
}

input UploadResult {
    fileName: String
    succeeded: Boolean
    errors: [String]
}

type TempCredentials {
    accessKeyId: String
    secretAccessKey: String
    sessionToken: String
}

type ApprovedStudy {
    _id: ID
    originalOrg: String # organization at the time of approval, can be absent if a submission request doesn't have an organization associated
    studyName: String
    studyAbbreviation: String # must be unique
    dbGaPID: String # aka. phs number
}

type ListLogFiles {
    logFiles: [LogFile]
}
type LogFile {
    fileName: String
    uploadType: String # [metadata, file]
    downloadUrl: String #s3 presigned download url of the file
    fileSize: Int #size in byte
}

type User {
  _id: ID # MongoDB native ID or UUID
  firstName: String
  lastName: String
  userStatus: String # [Active, Inactive]
  role: String # [User, Submitter, Organization Owner, Federal Lead, Data Curator, Data Commons POC, Admin]
  IDP: String # [NIH, Login.gov]
  email: String
  organization: OrgInfo # Organization
  dataCommons: [String] # Applies to Data Commons POC role only. Empty for other roles.
  tokens: [String]
  createdAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
  updateAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
}

type UserInfo {
  userID: ID # MongoDB native ID or UUID
  firstName: String
  lastName: String
#  orgRole: String # [Owner, Submitter, Concierge], Concierge can only be assign to a Curator
#  orgStatus: String # [Active, Inactive, Disabled]
  createdAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
  updateAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
}

type OrgInfo {
  orgID: ID # MongoDB native ID or UUID
  orgName: String
#  orgRole: String # [Owner, Submitter, Concierge], Concierge can only be assign to a Curator
#  orgStatus: String # [Active, Inactive, Disabled]
  createdAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
  updateAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
}

type UserOrganization {
  _id: ID # MongoDB native ID or UUID
  name: String
  status: String # [Active, Inactive], default to Active
  conciergeID: ID # The user's IDs are stored for the organization curators, aka. primary contact
  conciergeName: String # The user's name (first + last) is stored for the organization curators, aka. primary contact
  conciergeEmail: String
  studies: [ApprovedStudy] # Study names and abbreviations
  bucketName: String # Set by BE at creation time
  rootPath: String # Set by BE at creation time, in the form of “/<organization ID>”
  createdAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
  updateAt: Date # ISO 8601 date time format with UTC or offset e.g., 2023-05-01T09:23:30Z
}

type Tokens {
  tokens: [String]
  message: String
}

input UpdateUserInput {
    firstName: String!
    lastName: String!
}

input ApprovedStudyInput {
  studyName: String!
  studyAbbreviation: String!
}

type SubmissionStats {
    submissionID: ID
    stats: [Stats]
}

type Stats {
    nodeName: String
    total: Int
    new: Int
    passed: Int
    warning: Int
    error: Int
}

type QCResults {
    total: Int
    results: [QCResult]
}

type QCResult{
    submissionID: ID
    nodeType: String
    batchID: String
    displayID: Int
    nodeID: String
    CRDC_ID: String
    severity: String # [Error, Warning]
    uploadedDate: Date # batch.updatedAt
    description: [ErrorMessage]
}

type ErrorMessage {
    title: String
    description: String
}

type DataRecord {
    _id: ID
    submissionID: ID
    batchIDs: [ID] # all batch IDs, each time this record is reloaded in a new batch, append batchID here
    status: String # [New, Passed, Error, Warning], New is the initial state each time it's loaded
    errors: [ErrorMessage]
    warnings: [ErrorMessage]
    createdAt: Date
    updatedAt: Date
    orginalFileName: String # holds original file name the data is read from
    lineNumber: Int # line number in the original file
    nodeType: String # type of the node, in "type" column of the file
    nodeID: String # ID of the node, for example: "cds-case-99907"
#    props: Properties # properties of the node
    parents: [ParentNode]
#    relationshipProps: [RelationshipProperty] # for future use
#    rawData: RawData
    s3FileInfo: S3FileInfo # only for "file" types, should be null for other nodes
    CRDC_ID: String
}

type S3FileInfo {
    fileName: String
    size: Int
    md5: String
    status: String # [New, Passed, Error, Warning]
    errors: [ErrorMessage]
    warnings: [ErrorMessage]
    createdAt: Date
    updatedAt: Date
}

type DataValidation {
    success: Boolean
    message: String
}

# this type holds all the node properties in raw data (doesn't contain parent pointers and relationship properties)
#type Properties {
#    propertyName1: String # e.g, "gender": "Male"
#    propertyName2: Int # e.g, "age": 78
    # ...
#}

type ParentNode {
    parentType: String # node type of the parent node, e.g. "study"
    parentIDPropName: String # ID property name can be used to identify parent node, e.g., "study_id"
    parentIDValue: String # Value for above ID property, e.g. "CDS-study-007"
}

# for future use
#type RelationshipProperty {
#    relationshipName: String # name of the relationship
#    relationshipPropName: String # property name of the relationship
#    value: String # or other types
#}

# this type holds all data as is in a row in the file, including properties of the node,
# parent pointers and relationship properties if any
#type RawData {
#    type: String # node type is required
#    # "study.study_id": "CDS-study-007"
#    # "case_id": "cds-case-99907"
#    # "gender": "Male"
#    # "age": 78
#    # ...
#}

type AsyncProcessResult {
    success: Boolean
    message: String
}

type Query {
    "User or Fed lead initiated operations"
    getApplication (_id: ID!): Application
    getMyLastApplication: Application

    "Result depends on user's permission"
    listApplications(first: Int = 10, offset: Int = 0, orderBy: String = "Submitted Date", sortDirection: String = "DESC"): ListApplications
    # when first parameter is set to -1, we should return all applications (no pagination)
    # sortDirection in ["ASC", "DESC"]
    # orderBy in ["Submitter Name", "Organization", "Study", "Program", "Status", "Submitted Date"]

    # return approved studied for a user's organization
    listApprovedStudiesOfMyOrganization: [ApprovedStudy]

    # Admin only
    listApprovedStudies: [ApprovedStudy]

    "Result depends on user's permission"
    listSubmissions(
        organization: String,
        status: String,
        first: Int = 10,
        offset: Int = 0,
        # ["updatedAt", "createdAt", "name", "dataCommons", "organization", "studyAbbreviation",
        #              "dbGapID", "status", "concierge"]
        orderBy: String = "updatedAt",
        sortDirection: String = "DESC"): ListSubmissions
    getSubmission(_id: ID!): Submission
    submissionStats(_id: ID!): SubmissionStats
    submissionQCResults(
        _id: ID!,
        first: Int = 10,
        offset: Int = 0
        # [ "uploadedDate", "nodeType", "batchID", "nodeID", "CRDC_ID", "severity"]
        orderBy: String = "uploadedDate",
        sortDirection: String = "DESC"
    ): QCResults

    listBatches(submissionID: ID!,
        first: Int = 10,
        offset: Int = 0,
        # in ["updatedAt", "createdAt", "fileCount", "status", "errors"]
        orderBy: String = "updatedAt",
        sortDirection: String = "DESC" # ["DESC", "ASC"]
    ): ListBatches

    getBatch(batchID: ID!): Batch

    #upload log queries
    listLogs (submissionID: ID!) : ListLogFiles

    version: String

    "Limit to current user only"
    getMyUser : User

    "Admin and Org Owner only operations, Org Owner only see users within same organization"
    listUsers: [User]
    listActiveCurators: [UserInfo]
    getUser(userID: ID!): User

    "Admin only operations"
    listOrganizations: [UserOrganization]
    getOrganization(orgID: ID!): UserOrganization
}

type Mutation {
    "User initiated operations"
    saveApplication(application: AppInput!): Application
    submitApplication(_id: ID!): Application
    reopenApplication(_id: ID!): Application

    "Fed lead initiated operations"
    reviewApplication (_id: ID!): Application # same as getApplication but will set Application to "In Review" state
    approveApplication (_id: ID!, wholeProgram: Boolean, comment: String): Application
    rejectApplication (_id: ID!, comment: String!): Application
    inquireApplication (_id: ID!, comment: String!): Application

    "Admin only operations"
    deleteApplication (_id: ID!): Application

    "Submitter or Org Owner"
    createSubmission (studyAbbreviation: String!, dbGaPID: String, dataCommons: String!, name: String!): Submission
    submissionAction (
        submissionID: ID!,
        # in [Submit, Release, Withdraw, Reject, Complete, Cancel, Archive]
        action: String!
    ): Submission
    createBatch (submissionID: ID!, type: String, metadataIntention: String, files: [FileInput]): NewBatch
    updateBatch (batchID: ID!, files: [UploadResult]): Batch
    createTempCredentials (submissionID: ID!): TempCredentials
    validateSubmission(
        _id: ID!,
        types: [String] # [file, metadata]
        scope: String # [New, All] case-insensitive
    ): DataValidation
    exportSubmission(
        _id: ID!
    ): AsyncProcessResult

    "User initiated operations"
    updateMyUser (userInfo: UpdateUserInput!): User
    grantToken: Tokens

    "Admin only operations"
    invalidateToken(uuids: [String] = []): Tokens
    createOrganization(
        name: String!, # BE needs to check uniqueness of the new name
        conciergeID: String, # BE needs to save ID, email and name (first + last) of the concierge
        studies: [ApprovedStudyInput], # Will replace the list in the DB
    ) : UserOrganization
    editOrganization(
        orgID: ID!,
        name: String, # BE needs to check uniqueness of the new name
        conciergeID: String, # BE needs to save ID, email and name (first + last) of the concierge
        studies: [ApprovedStudyInput], # Will replace the list in the DB
        status: String # in [Active, Inactive]
    ): UserOrganization
    editUser(
      userID: ID!,
      organization: String, # Organization ID
      status: String, # in [Active, Inactive]
      role: String,
      dataCommons: [String], # Applies to Data Commons POC role only. Empty for other roles.
    ): User
}
