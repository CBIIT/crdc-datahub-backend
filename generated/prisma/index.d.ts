
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model OrgInfo
 * 
 */
export type OrgInfo = $Result.DefaultSelection<Prisma.$OrgInfoPayload>
/**
 * Model Applicant
 * 
 */
export type Applicant = $Result.DefaultSelection<Prisma.$ApplicantPayload>
/**
 * Model BatchFiles
 * 
 */
export type BatchFiles = $Result.DefaultSelection<Prisma.$BatchFilesPayload>
/**
 * Model PBACDefaults
 * 
 */
export type PBACDefaults = $Result.DefaultSelection<Prisma.$PBACDefaultsPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model ConfigurationTag
 * 
 */
export type ConfigurationTag = $Result.DefaultSelection<Prisma.$ConfigurationTagPayload>
/**
 * Model AdditionalError
 * 
 */
export type AdditionalError = $Result.DefaultSelection<Prisma.$AdditionalErrorPayload>
/**
 * Model S3FileInfo
 * 
 */
export type S3FileInfo = $Result.DefaultSelection<Prisma.$S3FileInfoPayload>
/**
 * Model LogsEventDetail
 * 
 */
export type LogsEventDetail = $Result.DefaultSelection<Prisma.$LogsEventDetailPayload>
/**
 * Model Institution
 * 
 */
export type Institution = $Result.DefaultSelection<Prisma.$InstitutionPayload>
/**
 * Model Collaborator
 * 
 */
export type Collaborator = $Result.DefaultSelection<Prisma.$CollaboratorPayload>
/**
 * Model DataFileSize
 * 
 */
export type DataFileSize = $Result.DefaultSelection<Prisma.$DataFileSizePayload>
/**
 * Model StudyByID
 * 
 */
export type StudyByID = $Result.DefaultSelection<Prisma.$StudyByIDPayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model History
 * 
 */
export type History = $Result.DefaultSelection<Prisma.$HistoryPayload>
/**
 * Model Error
 * 
 */
export type Error = $Result.DefaultSelection<Prisma.$ErrorPayload>
/**
 * Model CDE
 * 
 */
export type CDE = $Result.DefaultSelection<Prisma.$CDEPayload>
/**
 * Model applications
 * 
 */
export type applications = $Result.DefaultSelection<Prisma.$applicationsPayload>
/**
 * Model approvedStudies
 * 
 */
export type approvedStudies = $Result.DefaultSelection<Prisma.$approvedStudiesPayload>
/**
 * Model batch
 * 
 */
export type batch = $Result.DefaultSelection<Prisma.$batchPayload>
/**
 * Model configuration
 * 
 */
export type configuration = $Result.DefaultSelection<Prisma.$configurationPayload>
/**
 * Model dataRecords
 * 
 */
export type dataRecords = $Result.DefaultSelection<Prisma.$dataRecordsPayload>
/**
 * Model dataRecordsArchived
 * 
 */
export type dataRecordsArchived = $Result.DefaultSelection<Prisma.$dataRecordsArchivedPayload>
/**
 * Model fileMD5
 * 
 */
export type fileMD5 = $Result.DefaultSelection<Prisma.$fileMD5Payload>
/**
 * Model institutions
 * 
 */
export type institutions = $Result.DefaultSelection<Prisma.$institutionsPayload>
/**
 * Model logs
 * 
 */
export type logs = $Result.DefaultSelection<Prisma.$logsPayload>
/**
 * Model organization
 * 
 */
export type organization = $Result.DefaultSelection<Prisma.$organizationPayload>
/**
 * Model qcResults
 * 
 */
export type qcResults = $Result.DefaultSelection<Prisma.$qcResultsPayload>
/**
 * Model release
 * 
 */
export type release = $Result.DefaultSelection<Prisma.$releasePayload>
/**
 * Model sessions
 * 
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model submissions
 * 
 */
export type submissions = $Result.DefaultSelection<Prisma.$submissionsPayload>
/**
 * Model synonyms
 * 
 */
export type synonyms = $Result.DefaultSelection<Prisma.$synonymsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model validation
 * 
 */
export type validation = $Result.DefaultSelection<Prisma.$validationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CDES
 * const cDES = await prisma.cDE.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CDES
   * const cDES = await prisma.cDE.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.cDE`: Exposes CRUD operations for the **CDE** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CDES
    * const cDES = await prisma.cDE.findMany()
    * ```
    */
  get cDE(): Prisma.CDEDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applications`: Exposes CRUD operations for the **applications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.applications.findMany()
    * ```
    */
  get applications(): Prisma.applicationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.approvedStudies`: Exposes CRUD operations for the **approvedStudies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovedStudies
    * const approvedStudies = await prisma.approvedStudies.findMany()
    * ```
    */
  get approvedStudies(): Prisma.approvedStudiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batch`: Exposes CRUD operations for the **batch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batches
    * const batches = await prisma.batch.findMany()
    * ```
    */
  get batch(): Prisma.batchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configuration`: Exposes CRUD operations for the **configuration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configurations
    * const configurations = await prisma.configuration.findMany()
    * ```
    */
  get configuration(): Prisma.configurationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataRecords`: Exposes CRUD operations for the **dataRecords** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataRecords
    * const dataRecords = await prisma.dataRecords.findMany()
    * ```
    */
  get dataRecords(): Prisma.dataRecordsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataRecordsArchived`: Exposes CRUD operations for the **dataRecordsArchived** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataRecordsArchiveds
    * const dataRecordsArchiveds = await prisma.dataRecordsArchived.findMany()
    * ```
    */
  get dataRecordsArchived(): Prisma.dataRecordsArchivedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileMD5`: Exposes CRUD operations for the **fileMD5** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileMD5s
    * const fileMD5s = await prisma.fileMD5.findMany()
    * ```
    */
  get fileMD5(): Prisma.fileMD5Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institutions`: Exposes CRUD operations for the **institutions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutions
    * const institutions = await prisma.institutions.findMany()
    * ```
    */
  get institutions(): Prisma.institutionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.logs`: Exposes CRUD operations for the **logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.logs.findMany()
    * ```
    */
  get logs(): Prisma.logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.organizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qcResults`: Exposes CRUD operations for the **qcResults** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QcResults
    * const qcResults = await prisma.qcResults.findMany()
    * ```
    */
  get qcResults(): Prisma.qcResultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.release`: Exposes CRUD operations for the **release** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Releases
    * const releases = await prisma.release.findMany()
    * ```
    */
  get release(): Prisma.releaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.submissions`: Exposes CRUD operations for the **submissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Submissions
    * const submissions = await prisma.submissions.findMany()
    * ```
    */
  get submissions(): Prisma.submissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.synonyms`: Exposes CRUD operations for the **synonyms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Synonyms
    * const synonyms = await prisma.synonyms.findMany()
    * ```
    */
  get synonyms(): Prisma.synonymsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.validation`: Exposes CRUD operations for the **validation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Validations
    * const validations = await prisma.validation.findMany()
    * ```
    */
  get validation(): Prisma.validationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CDE: 'CDE',
    applications: 'applications',
    approvedStudies: 'approvedStudies',
    batch: 'batch',
    configuration: 'configuration',
    dataRecords: 'dataRecords',
    dataRecordsArchived: 'dataRecordsArchived',
    fileMD5: 'fileMD5',
    institutions: 'institutions',
    logs: 'logs',
    organization: 'organization',
    qcResults: 'qcResults',
    release: 'release',
    sessions: 'sessions',
    submissions: 'submissions',
    synonyms: 'synonyms',
    users: 'users',
    validation: 'validation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "cDE" | "applications" | "approvedStudies" | "batch" | "configuration" | "dataRecords" | "dataRecordsArchived" | "fileMD5" | "institutions" | "logs" | "organization" | "qcResults" | "release" | "sessions" | "submissions" | "synonyms" | "users" | "validation"
      txIsolationLevel: never
    }
    model: {
      CDE: {
        payload: Prisma.$CDEPayload<ExtArgs>
        fields: Prisma.CDEFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CDEFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CDEFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          findFirst: {
            args: Prisma.CDEFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CDEFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          findMany: {
            args: Prisma.CDEFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>[]
          }
          create: {
            args: Prisma.CDECreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          createMany: {
            args: Prisma.CDECreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CDEDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          update: {
            args: Prisma.CDEUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          deleteMany: {
            args: Prisma.CDEDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CDEUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CDEUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          aggregate: {
            args: Prisma.CDEAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCDE>
          }
          groupBy: {
            args: Prisma.CDEGroupByArgs<ExtArgs>
            result: $Utils.Optional<CDEGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CDEFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CDEAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CDECountArgs<ExtArgs>
            result: $Utils.Optional<CDECountAggregateOutputType> | number
          }
        }
      }
      applications: {
        payload: Prisma.$applicationsPayload<ExtArgs>
        fields: Prisma.applicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.applicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.applicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          findFirst: {
            args: Prisma.applicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.applicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          findMany: {
            args: Prisma.applicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>[]
          }
          create: {
            args: Prisma.applicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          createMany: {
            args: Prisma.applicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.applicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          update: {
            args: Prisma.applicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          deleteMany: {
            args: Prisma.applicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.applicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.applicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationsPayload>
          }
          aggregate: {
            args: Prisma.ApplicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplications>
          }
          groupBy: {
            args: Prisma.applicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.applicationsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.applicationsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.applicationsCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationsCountAggregateOutputType> | number
          }
        }
      }
      approvedStudies: {
        payload: Prisma.$approvedStudiesPayload<ExtArgs>
        fields: Prisma.approvedStudiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.approvedStudiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$approvedStudiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.approvedStudiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$approvedStudiesPayload>
          }
          findFirst: {
            args: Prisma.approvedStudiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$approvedStudiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.approvedStudiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$approvedStudiesPayload>
          }
          findMany: {
            args: Prisma.approvedStudiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$approvedStudiesPayload>[]
          }
          create: {
            args: Prisma.approvedStudiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$approvedStudiesPayload>
          }
          createMany: {
            args: Prisma.approvedStudiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.approvedStudiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$approvedStudiesPayload>
          }
          update: {
            args: Prisma.approvedStudiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$approvedStudiesPayload>
          }
          deleteMany: {
            args: Prisma.approvedStudiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.approvedStudiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.approvedStudiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$approvedStudiesPayload>
          }
          aggregate: {
            args: Prisma.ApprovedStudiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovedStudies>
          }
          groupBy: {
            args: Prisma.approvedStudiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovedStudiesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.approvedStudiesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.approvedStudiesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.approvedStudiesCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovedStudiesCountAggregateOutputType> | number
          }
        }
      }
      batch: {
        payload: Prisma.$batchPayload<ExtArgs>
        fields: Prisma.batchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.batchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.batchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchPayload>
          }
          findFirst: {
            args: Prisma.batchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.batchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchPayload>
          }
          findMany: {
            args: Prisma.batchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchPayload>[]
          }
          create: {
            args: Prisma.batchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchPayload>
          }
          createMany: {
            args: Prisma.batchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.batchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchPayload>
          }
          update: {
            args: Prisma.batchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchPayload>
          }
          deleteMany: {
            args: Prisma.batchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.batchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.batchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchPayload>
          }
          aggregate: {
            args: Prisma.BatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatch>
          }
          groupBy: {
            args: Prisma.batchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.batchFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.batchAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.batchCountArgs<ExtArgs>
            result: $Utils.Optional<BatchCountAggregateOutputType> | number
          }
        }
      }
      configuration: {
        payload: Prisma.$configurationPayload<ExtArgs>
        fields: Prisma.configurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          findFirst: {
            args: Prisma.configurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          findMany: {
            args: Prisma.configurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>[]
          }
          create: {
            args: Prisma.configurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          createMany: {
            args: Prisma.configurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.configurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          update: {
            args: Prisma.configurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          deleteMany: {
            args: Prisma.configurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.configurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.configurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configurationPayload>
          }
          aggregate: {
            args: Prisma.ConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguration>
          }
          groupBy: {
            args: Prisma.configurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.configurationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.configurationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.configurationCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationCountAggregateOutputType> | number
          }
        }
      }
      dataRecords: {
        payload: Prisma.$dataRecordsPayload<ExtArgs>
        fields: Prisma.dataRecordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dataRecordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dataRecordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsPayload>
          }
          findFirst: {
            args: Prisma.dataRecordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dataRecordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsPayload>
          }
          findMany: {
            args: Prisma.dataRecordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsPayload>[]
          }
          create: {
            args: Prisma.dataRecordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsPayload>
          }
          createMany: {
            args: Prisma.dataRecordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.dataRecordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsPayload>
          }
          update: {
            args: Prisma.dataRecordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsPayload>
          }
          deleteMany: {
            args: Prisma.dataRecordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dataRecordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dataRecordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsPayload>
          }
          aggregate: {
            args: Prisma.DataRecordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataRecords>
          }
          groupBy: {
            args: Prisma.dataRecordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataRecordsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.dataRecordsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.dataRecordsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.dataRecordsCountArgs<ExtArgs>
            result: $Utils.Optional<DataRecordsCountAggregateOutputType> | number
          }
        }
      }
      dataRecordsArchived: {
        payload: Prisma.$dataRecordsArchivedPayload<ExtArgs>
        fields: Prisma.dataRecordsArchivedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dataRecordsArchivedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsArchivedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dataRecordsArchivedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsArchivedPayload>
          }
          findFirst: {
            args: Prisma.dataRecordsArchivedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsArchivedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dataRecordsArchivedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsArchivedPayload>
          }
          findMany: {
            args: Prisma.dataRecordsArchivedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsArchivedPayload>[]
          }
          create: {
            args: Prisma.dataRecordsArchivedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsArchivedPayload>
          }
          createMany: {
            args: Prisma.dataRecordsArchivedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.dataRecordsArchivedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsArchivedPayload>
          }
          update: {
            args: Prisma.dataRecordsArchivedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsArchivedPayload>
          }
          deleteMany: {
            args: Prisma.dataRecordsArchivedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dataRecordsArchivedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dataRecordsArchivedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dataRecordsArchivedPayload>
          }
          aggregate: {
            args: Prisma.DataRecordsArchivedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataRecordsArchived>
          }
          groupBy: {
            args: Prisma.dataRecordsArchivedGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataRecordsArchivedGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.dataRecordsArchivedFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.dataRecordsArchivedAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.dataRecordsArchivedCountArgs<ExtArgs>
            result: $Utils.Optional<DataRecordsArchivedCountAggregateOutputType> | number
          }
        }
      }
      fileMD5: {
        payload: Prisma.$fileMD5Payload<ExtArgs>
        fields: Prisma.fileMD5FieldRefs
        operations: {
          findUnique: {
            args: Prisma.fileMD5FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fileMD5Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fileMD5FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fileMD5Payload>
          }
          findFirst: {
            args: Prisma.fileMD5FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fileMD5Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fileMD5FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fileMD5Payload>
          }
          findMany: {
            args: Prisma.fileMD5FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fileMD5Payload>[]
          }
          create: {
            args: Prisma.fileMD5CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fileMD5Payload>
          }
          createMany: {
            args: Prisma.fileMD5CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.fileMD5DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fileMD5Payload>
          }
          update: {
            args: Prisma.fileMD5UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fileMD5Payload>
          }
          deleteMany: {
            args: Prisma.fileMD5DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fileMD5UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.fileMD5UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fileMD5Payload>
          }
          aggregate: {
            args: Prisma.FileMD5AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileMD5>
          }
          groupBy: {
            args: Prisma.fileMD5GroupByArgs<ExtArgs>
            result: $Utils.Optional<FileMD5GroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.fileMD5FindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.fileMD5AggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.fileMD5CountArgs<ExtArgs>
            result: $Utils.Optional<FileMD5CountAggregateOutputType> | number
          }
        }
      }
      institutions: {
        payload: Prisma.$institutionsPayload<ExtArgs>
        fields: Prisma.institutionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.institutionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.institutionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          findFirst: {
            args: Prisma.institutionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.institutionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          findMany: {
            args: Prisma.institutionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>[]
          }
          create: {
            args: Prisma.institutionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          createMany: {
            args: Prisma.institutionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.institutionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          update: {
            args: Prisma.institutionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          deleteMany: {
            args: Prisma.institutionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.institutionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.institutionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          aggregate: {
            args: Prisma.InstitutionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitutions>
          }
          groupBy: {
            args: Prisma.institutionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.institutionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.institutionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.institutionsCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionsCountAggregateOutputType> | number
          }
        }
      }
      logs: {
        payload: Prisma.$logsPayload<ExtArgs>
        fields: Prisma.logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          findFirst: {
            args: Prisma.logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          findMany: {
            args: Prisma.logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>[]
          }
          create: {
            args: Prisma.logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          createMany: {
            args: Prisma.logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          update: {
            args: Prisma.logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          deleteMany: {
            args: Prisma.logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logsPayload>
          }
          aggregate: {
            args: Prisma.LogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogs>
          }
          groupBy: {
            args: Prisma.logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.logsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.logsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.logsCountArgs<ExtArgs>
            result: $Utils.Optional<LogsCountAggregateOutputType> | number
          }
        }
      }
      organization: {
        payload: Prisma.$organizationPayload<ExtArgs>
        fields: Prisma.organizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.organizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.organizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          findFirst: {
            args: Prisma.organizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.organizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          findMany: {
            args: Prisma.organizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>[]
          }
          create: {
            args: Prisma.organizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          createMany: {
            args: Prisma.organizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.organizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          update: {
            args: Prisma.organizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          deleteMany: {
            args: Prisma.organizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.organizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.organizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.organizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.organizationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.organizationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.organizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      qcResults: {
        payload: Prisma.$qcResultsPayload<ExtArgs>
        fields: Prisma.qcResultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qcResultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qcResultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qcResultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qcResultsPayload>
          }
          findFirst: {
            args: Prisma.qcResultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qcResultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qcResultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qcResultsPayload>
          }
          findMany: {
            args: Prisma.qcResultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qcResultsPayload>[]
          }
          create: {
            args: Prisma.qcResultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qcResultsPayload>
          }
          createMany: {
            args: Prisma.qcResultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.qcResultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qcResultsPayload>
          }
          update: {
            args: Prisma.qcResultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qcResultsPayload>
          }
          deleteMany: {
            args: Prisma.qcResultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qcResultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.qcResultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qcResultsPayload>
          }
          aggregate: {
            args: Prisma.QcResultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQcResults>
          }
          groupBy: {
            args: Prisma.qcResultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QcResultsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.qcResultsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.qcResultsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.qcResultsCountArgs<ExtArgs>
            result: $Utils.Optional<QcResultsCountAggregateOutputType> | number
          }
        }
      }
      release: {
        payload: Prisma.$releasePayload<ExtArgs>
        fields: Prisma.releaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.releaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$releasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.releaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$releasePayload>
          }
          findFirst: {
            args: Prisma.releaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$releasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.releaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$releasePayload>
          }
          findMany: {
            args: Prisma.releaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$releasePayload>[]
          }
          create: {
            args: Prisma.releaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$releasePayload>
          }
          createMany: {
            args: Prisma.releaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.releaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$releasePayload>
          }
          update: {
            args: Prisma.releaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$releasePayload>
          }
          deleteMany: {
            args: Prisma.releaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.releaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.releaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$releasePayload>
          }
          aggregate: {
            args: Prisma.ReleaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelease>
          }
          groupBy: {
            args: Prisma.releaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReleaseGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.releaseFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.releaseAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.releaseCountArgs<ExtArgs>
            result: $Utils.Optional<ReleaseCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.sessionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.sessionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      submissions: {
        payload: Prisma.$submissionsPayload<ExtArgs>
        fields: Prisma.submissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.submissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$submissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.submissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$submissionsPayload>
          }
          findFirst: {
            args: Prisma.submissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$submissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.submissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$submissionsPayload>
          }
          findMany: {
            args: Prisma.submissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$submissionsPayload>[]
          }
          create: {
            args: Prisma.submissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$submissionsPayload>
          }
          createMany: {
            args: Prisma.submissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.submissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$submissionsPayload>
          }
          update: {
            args: Prisma.submissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$submissionsPayload>
          }
          deleteMany: {
            args: Prisma.submissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.submissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.submissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$submissionsPayload>
          }
          aggregate: {
            args: Prisma.SubmissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubmissions>
          }
          groupBy: {
            args: Prisma.submissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubmissionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.submissionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.submissionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.submissionsCountArgs<ExtArgs>
            result: $Utils.Optional<SubmissionsCountAggregateOutputType> | number
          }
        }
      }
      synonyms: {
        payload: Prisma.$synonymsPayload<ExtArgs>
        fields: Prisma.synonymsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.synonymsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$synonymsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.synonymsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$synonymsPayload>
          }
          findFirst: {
            args: Prisma.synonymsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$synonymsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.synonymsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$synonymsPayload>
          }
          findMany: {
            args: Prisma.synonymsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$synonymsPayload>[]
          }
          create: {
            args: Prisma.synonymsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$synonymsPayload>
          }
          createMany: {
            args: Prisma.synonymsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.synonymsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$synonymsPayload>
          }
          update: {
            args: Prisma.synonymsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$synonymsPayload>
          }
          deleteMany: {
            args: Prisma.synonymsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.synonymsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.synonymsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$synonymsPayload>
          }
          aggregate: {
            args: Prisma.SynonymsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSynonyms>
          }
          groupBy: {
            args: Prisma.synonymsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SynonymsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.synonymsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.synonymsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.synonymsCountArgs<ExtArgs>
            result: $Utils.Optional<SynonymsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.usersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.usersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      validation: {
        payload: Prisma.$validationPayload<ExtArgs>
        fields: Prisma.validationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.validationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.validationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validationPayload>
          }
          findFirst: {
            args: Prisma.validationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.validationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validationPayload>
          }
          findMany: {
            args: Prisma.validationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validationPayload>[]
          }
          create: {
            args: Prisma.validationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validationPayload>
          }
          createMany: {
            args: Prisma.validationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.validationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validationPayload>
          }
          update: {
            args: Prisma.validationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validationPayload>
          }
          deleteMany: {
            args: Prisma.validationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.validationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.validationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$validationPayload>
          }
          aggregate: {
            args: Prisma.ValidationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateValidation>
          }
          groupBy: {
            args: Prisma.validationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ValidationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.validationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.validationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.validationCountArgs<ExtArgs>
            result: $Utils.Optional<ValidationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    cDE?: CDEOmit
    applications?: applicationsOmit
    approvedStudies?: approvedStudiesOmit
    batch?: batchOmit
    configuration?: configurationOmit
    dataRecords?: dataRecordsOmit
    dataRecordsArchived?: dataRecordsArchivedOmit
    fileMD5?: fileMD5Omit
    institutions?: institutionsOmit
    logs?: logsOmit
    organization?: organizationOmit
    qcResults?: qcResultsOmit
    release?: releaseOmit
    sessions?: sessionsOmit
    submissions?: submissionsOmit
    synonyms?: synonymsOmit
    users?: usersOmit
    validation?: validationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model OrgInfo
   */





  export type OrgInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updateAt?: boolean
    orgID?: boolean
    orgName?: boolean
  }, ExtArgs["result"]["orgInfo"]>



  export type OrgInfoSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updateAt?: boolean
    orgID?: boolean
    orgName?: boolean
  }

  export type OrgInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "createdAt" | "updateAt" | "orgID" | "orgName", ExtArgs["result"]["orgInfo"]>

  export type $OrgInfoPayload = {
    name: "OrgInfo"
    objects: {}
    scalars: {
      id: string
      name: string
      status: string | null
      createdAt: Date | null
      updateAt: Date | null
      orgID: string | null
      orgName: string | null
    }
    composites: {}
  }

  type OrgInfoGetPayload<S extends boolean | null | undefined | OrgInfoDefaultArgs> = $Result.GetResult<Prisma.$OrgInfoPayload, S>





  /**
   * Fields of the OrgInfo model
   */
  interface OrgInfoFieldRefs {
    readonly id: FieldRef<"OrgInfo", 'String'>
    readonly name: FieldRef<"OrgInfo", 'String'>
    readonly status: FieldRef<"OrgInfo", 'String'>
    readonly createdAt: FieldRef<"OrgInfo", 'DateTime'>
    readonly updateAt: FieldRef<"OrgInfo", 'DateTime'>
    readonly orgID: FieldRef<"OrgInfo", 'String'>
    readonly orgName: FieldRef<"OrgInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrgInfo without action
   */
  export type OrgInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgInfo
     */
    select?: OrgInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgInfo
     */
    omit?: OrgInfoOmit<ExtArgs> | null
  }


  /**
   * Model Applicant
   */





  export type ApplicantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    applicantEmail?: boolean
    applicantID?: boolean
    applicantName?: boolean
  }, ExtArgs["result"]["applicant"]>



  export type ApplicantSelectScalar = {
    applicantEmail?: boolean
    applicantID?: boolean
    applicantName?: boolean
  }

  export type ApplicantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"applicantEmail" | "applicantID" | "applicantName", ExtArgs["result"]["applicant"]>

  export type $ApplicantPayload = {
    name: "Applicant"
    objects: {}
    scalars: {
      applicantEmail: string
      applicantID: string
      applicantName: string
    }
    composites: {}
  }

  type ApplicantGetPayload<S extends boolean | null | undefined | ApplicantDefaultArgs> = $Result.GetResult<Prisma.$ApplicantPayload, S>





  /**
   * Fields of the Applicant model
   */
  interface ApplicantFieldRefs {
    readonly applicantEmail: FieldRef<"Applicant", 'String'>
    readonly applicantID: FieldRef<"Applicant", 'String'>
    readonly applicantName: FieldRef<"Applicant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Applicant without action
   */
  export type ApplicantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
  }


  /**
   * Model BatchFiles
   */





  export type BatchFilesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    errors?: boolean
    fileID?: boolean
    fileName?: boolean
    filePrefix?: boolean
    nodeType?: boolean
    signedURL?: boolean
    size?: boolean
    status?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchFiles"]>



  export type BatchFilesSelectScalar = {
    createdAt?: boolean
    errors?: boolean
    fileID?: boolean
    fileName?: boolean
    filePrefix?: boolean
    nodeType?: boolean
    signedURL?: boolean
    size?: boolean
    status?: boolean
    updatedAt?: boolean
  }

  export type BatchFilesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "errors" | "fileID" | "fileName" | "filePrefix" | "nodeType" | "signedURL" | "size" | "status" | "updatedAt", ExtArgs["result"]["batchFiles"]>

  export type $BatchFilesPayload = {
    name: "BatchFiles"
    objects: {}
    scalars: {
      createdAt: Date
      errors: string[]
      fileID: string | null
      fileName: string
      filePrefix: string
      nodeType: string | null
      signedURL: string | null
      size: number | null
      status: string
      updatedAt: Date
    }
    composites: {}
  }

  type BatchFilesGetPayload<S extends boolean | null | undefined | BatchFilesDefaultArgs> = $Result.GetResult<Prisma.$BatchFilesPayload, S>





  /**
   * Fields of the BatchFiles model
   */
  interface BatchFilesFieldRefs {
    readonly createdAt: FieldRef<"BatchFiles", 'DateTime'>
    readonly errors: FieldRef<"BatchFiles", 'String[]'>
    readonly fileID: FieldRef<"BatchFiles", 'String'>
    readonly fileName: FieldRef<"BatchFiles", 'String'>
    readonly filePrefix: FieldRef<"BatchFiles", 'String'>
    readonly nodeType: FieldRef<"BatchFiles", 'String'>
    readonly signedURL: FieldRef<"BatchFiles", 'String'>
    readonly size: FieldRef<"BatchFiles", 'Int'>
    readonly status: FieldRef<"BatchFiles", 'String'>
    readonly updatedAt: FieldRef<"BatchFiles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BatchFiles without action
   */
  export type BatchFilesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchFiles
     */
    select?: BatchFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchFiles
     */
    omit?: BatchFilesOmit<ExtArgs> | null
  }


  /**
   * Model PBACDefaults
   */





  export type PBACDefaultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    notifications?: boolean | NotificationDefaultArgs<ExtArgs>
    permissions?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean
  }, ExtArgs["result"]["pBACDefaults"]>



  export type PBACDefaultsSelectScalar = {
    role?: boolean
  }

  export type PBACDefaultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"notifications" | "permissions" | "role", ExtArgs["result"]["pBACDefaults"]>
  export type PBACDefaultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PBACDefaultsPayload = {
    name: "PBACDefaults"
    objects: {}
    scalars: {
      role: string
    }
    composites: {
      notifications: Prisma.$NotificationPayload[]
      permissions: Prisma.$PermissionPayload[]
    }
  }

  type PBACDefaultsGetPayload<S extends boolean | null | undefined | PBACDefaultsDefaultArgs> = $Result.GetResult<Prisma.$PBACDefaultsPayload, S>





  /**
   * Fields of the PBACDefaults model
   */
  interface PBACDefaultsFieldRefs {
    readonly role: FieldRef<"PBACDefaults", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PBACDefaults without action
   */
  export type PBACDefaultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PBACDefaults
     */
    select?: PBACDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PBACDefaults
     */
    omit?: PBACDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PBACDefaultsInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */





  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checked?: boolean
    disabled?: boolean
    group?: boolean
    name?: boolean
    order?: boolean
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    checked?: boolean
    disabled?: boolean
    group?: boolean
    name?: boolean
    order?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "checked" | "disabled" | "group" | "name" | "order", ExtArgs["result"]["notification"]>

  export type $NotificationPayload = {
    name: "Notification"
    objects: {}
    scalars: {
      id: string
      checked: boolean
      disabled: boolean
      group: string
      name: string
      order: number
    }
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>





  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly checked: FieldRef<"Notification", 'Boolean'>
    readonly disabled: FieldRef<"Notification", 'Boolean'>
    readonly group: FieldRef<"Notification", 'String'>
    readonly name: FieldRef<"Notification", 'String'>
    readonly order: FieldRef<"Notification", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Model Permission
   */





  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checked?: boolean
    disabled?: boolean
    group?: boolean
    inherited?: boolean
    name?: boolean
    order?: boolean
  }, ExtArgs["result"]["permission"]>



  export type PermissionSelectScalar = {
    id?: boolean
    checked?: boolean
    disabled?: boolean
    group?: boolean
    inherited?: boolean
    name?: boolean
    order?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "checked" | "disabled" | "group" | "inherited" | "name" | "order", ExtArgs["result"]["permission"]>

  export type $PermissionPayload = {
    name: "Permission"
    objects: {}
    scalars: {
      id: string
      checked: boolean
      disabled: boolean
      group: string
      inherited: string[]
      name: string
      order: number
    }
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>





  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly checked: FieldRef<"Permission", 'Boolean'>
    readonly disabled: FieldRef<"Permission", 'Boolean'>
    readonly group: FieldRef<"Permission", 'String'>
    readonly inherited: FieldRef<"Permission", 'String[]'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly order: FieldRef<"Permission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
  }


  /**
   * Model ConfigurationTag
   */





  export type ConfigurationTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Key?: boolean
    Value?: boolean
  }, ExtArgs["result"]["configurationTag"]>



  export type ConfigurationTagSelectScalar = {
    Key?: boolean
    Value?: boolean
  }

  export type ConfigurationTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Key" | "Value", ExtArgs["result"]["configurationTag"]>

  export type $ConfigurationTagPayload = {
    name: "ConfigurationTag"
    objects: {}
    scalars: {
      Key: string
      Value: string
    }
    composites: {}
  }

  type ConfigurationTagGetPayload<S extends boolean | null | undefined | ConfigurationTagDefaultArgs> = $Result.GetResult<Prisma.$ConfigurationTagPayload, S>





  /**
   * Fields of the ConfigurationTag model
   */
  interface ConfigurationTagFieldRefs {
    readonly Key: FieldRef<"ConfigurationTag", 'String'>
    readonly Value: FieldRef<"ConfigurationTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConfigurationTag without action
   */
  export type ConfigurationTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigurationTag
     */
    select?: ConfigurationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigurationTag
     */
    omit?: ConfigurationTagOmit<ExtArgs> | null
  }


  /**
   * Model AdditionalError
   */





  export type AdditionalErrorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conflictingSubmissions?: boolean
    description?: boolean
    title?: boolean
  }, ExtArgs["result"]["additionalError"]>



  export type AdditionalErrorSelectScalar = {
    conflictingSubmissions?: boolean
    description?: boolean
    title?: boolean
  }

  export type AdditionalErrorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"conflictingSubmissions" | "description" | "title", ExtArgs["result"]["additionalError"]>

  export type $AdditionalErrorPayload = {
    name: "AdditionalError"
    objects: {}
    scalars: {
      conflictingSubmissions: string[]
      description: string
      title: string
    }
    composites: {}
  }

  type AdditionalErrorGetPayload<S extends boolean | null | undefined | AdditionalErrorDefaultArgs> = $Result.GetResult<Prisma.$AdditionalErrorPayload, S>





  /**
   * Fields of the AdditionalError model
   */
  interface AdditionalErrorFieldRefs {
    readonly conflictingSubmissions: FieldRef<"AdditionalError", 'String[]'>
    readonly description: FieldRef<"AdditionalError", 'String'>
    readonly title: FieldRef<"AdditionalError", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdditionalError without action
   */
  export type AdditionalErrorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalError
     */
    select?: AdditionalErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalError
     */
    omit?: AdditionalErrorOmit<ExtArgs> | null
  }


  /**
   * Model S3FileInfo
   */





  export type S3FileInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    errors?: boolean | ErrorDefaultArgs<ExtArgs>
    fileName?: boolean
    md5?: boolean
    size?: boolean
    status?: boolean
    updatedAt?: boolean
    warnings?: boolean | ErrorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["s3FileInfo"]>



  export type S3FileInfoSelectScalar = {
    createdAt?: boolean
    fileName?: boolean
    md5?: boolean
    size?: boolean
    status?: boolean
    updatedAt?: boolean
  }

  export type S3FileInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "errors" | "fileName" | "md5" | "size" | "status" | "updatedAt" | "warnings", ExtArgs["result"]["s3FileInfo"]>
  export type S3FileInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $S3FileInfoPayload = {
    name: "S3FileInfo"
    objects: {}
    scalars: {
      createdAt: Date | null
      fileName: string
      md5: string | null
      size: string | null
      status: string
      updatedAt: Date | null
    }
    composites: {
      errors: Prisma.$ErrorPayload[]
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      warnings: Prisma.$ErrorPayload[]
    }
  }

  type S3FileInfoGetPayload<S extends boolean | null | undefined | S3FileInfoDefaultArgs> = $Result.GetResult<Prisma.$S3FileInfoPayload, S>





  /**
   * Fields of the S3FileInfo model
   */
  interface S3FileInfoFieldRefs {
    readonly createdAt: FieldRef<"S3FileInfo", 'DateTime'>
    readonly fileName: FieldRef<"S3FileInfo", 'String'>
    readonly md5: FieldRef<"S3FileInfo", 'String'>
    readonly size: FieldRef<"S3FileInfo", 'String'>
    readonly status: FieldRef<"S3FileInfo", 'String'>
    readonly updatedAt: FieldRef<"S3FileInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * S3FileInfo without action
   */
  export type S3FileInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3FileInfo
     */
    select?: S3FileInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3FileInfo
     */
    omit?: S3FileInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInfoInclude<ExtArgs> | null
  }


  /**
   * Model LogsEventDetail
   */





  export type LogsEventDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nodeIDs?: boolean
    nodeType?: boolean
    submissionID?: boolean
  }, ExtArgs["result"]["logsEventDetail"]>



  export type LogsEventDetailSelectScalar = {
    nodeIDs?: boolean
    nodeType?: boolean
    submissionID?: boolean
  }

  export type LogsEventDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"nodeIDs" | "nodeType" | "submissionID", ExtArgs["result"]["logsEventDetail"]>

  export type $LogsEventDetailPayload = {
    name: "LogsEventDetail"
    objects: {}
    scalars: {
      nodeIDs: string[]
      nodeType: string
      submissionID: string
    }
    composites: {}
  }

  type LogsEventDetailGetPayload<S extends boolean | null | undefined | LogsEventDetailDefaultArgs> = $Result.GetResult<Prisma.$LogsEventDetailPayload, S>





  /**
   * Fields of the LogsEventDetail model
   */
  interface LogsEventDetailFieldRefs {
    readonly nodeIDs: FieldRef<"LogsEventDetail", 'String[]'>
    readonly nodeType: FieldRef<"LogsEventDetail", 'String'>
    readonly submissionID: FieldRef<"LogsEventDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LogsEventDetail without action
   */
  export type LogsEventDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogsEventDetail
     */
    select?: LogsEventDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogsEventDetail
     */
    omit?: LogsEventDetailOmit<ExtArgs> | null
  }


  /**
   * Model Institution
   */





  export type InstitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
  }, ExtArgs["result"]["institution"]>



  export type InstitutionSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
  }

  export type InstitutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status", ExtArgs["result"]["institution"]>

  export type $InstitutionPayload = {
    name: "Institution"
    objects: {}
    scalars: {
      id: string
      name: string
      status: string
    }
    composites: {}
  }

  type InstitutionGetPayload<S extends boolean | null | undefined | InstitutionDefaultArgs> = $Result.GetResult<Prisma.$InstitutionPayload, S>





  /**
   * Fields of the Institution model
   */
  interface InstitutionFieldRefs {
    readonly id: FieldRef<"Institution", 'String'>
    readonly name: FieldRef<"Institution", 'String'>
    readonly status: FieldRef<"Institution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Institution without action
   */
  export type InstitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
  }


  /**
   * Model Collaborator
   */





  export type CollaboratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Organization?: boolean | OrgInfoDefaultArgs<ExtArgs>
    collaboratorID?: boolean
    collaboratorName?: boolean
    permission?: boolean
  }, ExtArgs["result"]["collaborator"]>



  export type CollaboratorSelectScalar = {
    collaboratorID?: boolean
    collaboratorName?: boolean
    permission?: boolean
  }

  export type CollaboratorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Organization" | "collaboratorID" | "collaboratorName" | "permission", ExtArgs["result"]["collaborator"]>
  export type CollaboratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CollaboratorPayload = {
    name: "Collaborator"
    objects: {}
    scalars: {
      collaboratorID: string
      collaboratorName: string | null
      /**
       * Multiple data types found: String: 97.4%, Array(String): 2.6% out of 38 sampled entries
       */
      permission: Prisma.JsonValue
    }
    composites: {
      Organization: Prisma.$OrgInfoPayload | null
    }
  }

  type CollaboratorGetPayload<S extends boolean | null | undefined | CollaboratorDefaultArgs> = $Result.GetResult<Prisma.$CollaboratorPayload, S>





  /**
   * Fields of the Collaborator model
   */
  interface CollaboratorFieldRefs {
    readonly collaboratorID: FieldRef<"Collaborator", 'String'>
    readonly collaboratorName: FieldRef<"Collaborator", 'String'>
    readonly permission: FieldRef<"Collaborator", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Collaborator without action
   */
  export type CollaboratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborator
     */
    omit?: CollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorInclude<ExtArgs> | null
  }


  /**
   * Model DataFileSize
   */





  export type DataFileSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    formatted?: boolean
    size?: boolean
  }, ExtArgs["result"]["dataFileSize"]>



  export type DataFileSizeSelectScalar = {
    formatted?: boolean
    size?: boolean
  }

  export type DataFileSizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"formatted" | "size", ExtArgs["result"]["dataFileSize"]>

  export type $DataFileSizePayload = {
    name: "DataFileSize"
    objects: {}
    scalars: {
      formatted: string
      size: number
    }
    composites: {}
  }

  type DataFileSizeGetPayload<S extends boolean | null | undefined | DataFileSizeDefaultArgs> = $Result.GetResult<Prisma.$DataFileSizePayload, S>





  /**
   * Fields of the DataFileSize model
   */
  interface DataFileSizeFieldRefs {
    readonly formatted: FieldRef<"DataFileSize", 'String'>
    readonly size: FieldRef<"DataFileSize", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DataFileSize without action
   */
  export type DataFileSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataFileSize
     */
    select?: DataFileSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataFileSize
     */
    omit?: DataFileSizeOmit<ExtArgs> | null
  }


  /**
   * Model StudyByID
   */





  export type StudyByIDSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["studyByID"]>



  export type StudyByIDSelectScalar = {
    id?: boolean
  }

  export type StudyByIDOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["studyByID"]>

  export type $StudyByIDPayload = {
    name: "StudyByID"
    objects: {}
    scalars: {
      id: string
    }
    composites: {}
  }

  type StudyByIDGetPayload<S extends boolean | null | undefined | StudyByIDDefaultArgs> = $Result.GetResult<Prisma.$StudyByIDPayload, S>





  /**
   * Fields of the StudyByID model
   */
  interface StudyByIDFieldRefs {
    readonly id: FieldRef<"StudyByID", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudyByID without action
   */
  export type StudyByIDDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyByID
     */
    select?: StudyByIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyByID
     */
    omit?: StudyByIDOmit<ExtArgs> | null
  }


  /**
   * Model Parent
   */





  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parentIDPropName?: boolean
    parentIDValue?: boolean
    parentType?: boolean
  }, ExtArgs["result"]["parent"]>



  export type ParentSelectScalar = {
    parentIDPropName?: boolean
    parentIDValue?: boolean
    parentType?: boolean
  }

  export type ParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"parentIDPropName" | "parentIDValue" | "parentType", ExtArgs["result"]["parent"]>

  export type $ParentPayload = {
    name: "Parent"
    objects: {}
    scalars: {
      parentIDPropName: string
      parentIDValue: string
      parentType: string
    }
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>





  /**
   * Fields of the Parent model
   */
  interface ParentFieldRefs {
    readonly parentIDPropName: FieldRef<"Parent", 'String'>
    readonly parentIDValue: FieldRef<"Parent", 'String'>
    readonly parentType: FieldRef<"Parent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
  }


  /**
   * Model History
   */





  export type HistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dateTime?: boolean
    reviewComment?: boolean
    status?: boolean
    userID?: boolean
    userName?: boolean
  }, ExtArgs["result"]["history"]>



  export type HistorySelectScalar = {
    dateTime?: boolean
    reviewComment?: boolean
    status?: boolean
    userID?: boolean
    userName?: boolean
  }

  export type HistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"dateTime" | "reviewComment" | "status" | "userID" | "userName", ExtArgs["result"]["history"]>

  export type $HistoryPayload = {
    name: "History"
    objects: {}
    scalars: {
      dateTime: Date
      reviewComment: string | null
      status: string
      userID: string
      userName: string | null
    }
    composites: {}
  }

  type HistoryGetPayload<S extends boolean | null | undefined | HistoryDefaultArgs> = $Result.GetResult<Prisma.$HistoryPayload, S>





  /**
   * Fields of the History model
   */
  interface HistoryFieldRefs {
    readonly dateTime: FieldRef<"History", 'DateTime'>
    readonly reviewComment: FieldRef<"History", 'String'>
    readonly status: FieldRef<"History", 'String'>
    readonly userID: FieldRef<"History", 'String'>
    readonly userName: FieldRef<"History", 'String'>
  }
    

  // Custom InputTypes
  /**
   * History without action
   */
  export type HistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
  }


  /**
   * Model Error
   */





  export type ErrorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    description?: boolean
    code?: boolean
    offendingProperty?: boolean
    offendingValue?: boolean
    severity?: boolean
  }, ExtArgs["result"]["error"]>



  export type ErrorSelectScalar = {
    title?: boolean
    description?: boolean
    code?: boolean
    offendingProperty?: boolean
    offendingValue?: boolean
    severity?: boolean
  }

  export type ErrorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"title" | "description" | "code" | "offendingProperty" | "offendingValue" | "severity", ExtArgs["result"]["error"]>

  export type $ErrorPayload = {
    name: "Error"
    objects: {}
    scalars: {
      title: string
      description: string
      code: string | null
      offendingProperty: string | null
      offendingValue: string | null
      severity: string | null
    }
    composites: {}
  }

  type ErrorGetPayload<S extends boolean | null | undefined | ErrorDefaultArgs> = $Result.GetResult<Prisma.$ErrorPayload, S>





  /**
   * Fields of the Error model
   */
  interface ErrorFieldRefs {
    readonly title: FieldRef<"Error", 'String'>
    readonly description: FieldRef<"Error", 'String'>
    readonly code: FieldRef<"Error", 'String'>
    readonly offendingProperty: FieldRef<"Error", 'String'>
    readonly offendingValue: FieldRef<"Error", 'String'>
    readonly severity: FieldRef<"Error", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Error without action
   */
  export type ErrorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
  }


  /**
   * Model CDE
   */

  export type AggregateCDE = {
    _count: CDECountAggregateOutputType | null
    _min: CDEMinAggregateOutputType | null
    _max: CDEMaxAggregateOutputType | null
  }

  export type CDEMinAggregateOutputType = {
    id: string | null
    CDECode: string | null
    CDEFullName: string | null
    CDEVersion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CDEMaxAggregateOutputType = {
    id: string | null
    CDECode: string | null
    CDEFullName: string | null
    CDEVersion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CDECountAggregateOutputType = {
    id: number
    CDECode: number
    CDEFullName: number
    CDEVersion: number
    PermissibleValues: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CDEMinAggregateInputType = {
    id?: true
    CDECode?: true
    CDEFullName?: true
    CDEVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CDEMaxAggregateInputType = {
    id?: true
    CDECode?: true
    CDEFullName?: true
    CDEVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CDECountAggregateInputType = {
    id?: true
    CDECode?: true
    CDEFullName?: true
    CDEVersion?: true
    PermissibleValues?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CDEAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CDE to aggregate.
     */
    where?: CDEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CDES to fetch.
     */
    orderBy?: CDEOrderByWithRelationInput | CDEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CDEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CDES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CDES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CDES
    **/
    _count?: true | CDECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CDEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CDEMaxAggregateInputType
  }

  export type GetCDEAggregateType<T extends CDEAggregateArgs> = {
        [P in keyof T & keyof AggregateCDE]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCDE[P]>
      : GetScalarType<T[P], AggregateCDE[P]>
  }




  export type CDEGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CDEWhereInput
    orderBy?: CDEOrderByWithAggregationInput | CDEOrderByWithAggregationInput[]
    by: CDEScalarFieldEnum[] | CDEScalarFieldEnum
    having?: CDEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CDECountAggregateInputType | true
    _min?: CDEMinAggregateInputType
    _max?: CDEMaxAggregateInputType
  }

  export type CDEGroupByOutputType = {
    id: string
    CDECode: string
    CDEFullName: string
    CDEVersion: string | null
    PermissibleValues: string[]
    createdAt: Date
    updatedAt: Date
    _count: CDECountAggregateOutputType | null
    _min: CDEMinAggregateOutputType | null
    _max: CDEMaxAggregateOutputType | null
  }

  type GetCDEGroupByPayload<T extends CDEGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CDEGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CDEGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CDEGroupByOutputType[P]>
            : GetScalarType<T[P], CDEGroupByOutputType[P]>
        }
      >
    >


  export type CDESelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CDECode?: boolean
    CDEFullName?: boolean
    CDEVersion?: boolean
    PermissibleValues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cDE"]>



  export type CDESelectScalar = {
    id?: boolean
    CDECode?: boolean
    CDEFullName?: boolean
    CDEVersion?: boolean
    PermissibleValues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CDEOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "CDECode" | "CDEFullName" | "CDEVersion" | "PermissibleValues" | "createdAt" | "updatedAt", ExtArgs["result"]["cDE"]>

  export type $CDEPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CDE"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      CDECode: string
      CDEFullName: string
      CDEVersion: string | null
      PermissibleValues: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cDE"]>
    composites: {}
  }

  type CDEGetPayload<S extends boolean | null | undefined | CDEDefaultArgs> = $Result.GetResult<Prisma.$CDEPayload, S>

  type CDECountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CDEFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CDECountAggregateInputType | true
    }

  export interface CDEDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CDE'], meta: { name: 'CDE' } }
    /**
     * Find zero or one CDE that matches the filter.
     * @param {CDEFindUniqueArgs} args - Arguments to find a CDE
     * @example
     * // Get one CDE
     * const cDE = await prisma.cDE.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CDEFindUniqueArgs>(args: SelectSubset<T, CDEFindUniqueArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CDE that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CDEFindUniqueOrThrowArgs} args - Arguments to find a CDE
     * @example
     * // Get one CDE
     * const cDE = await prisma.cDE.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CDEFindUniqueOrThrowArgs>(args: SelectSubset<T, CDEFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CDE that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEFindFirstArgs} args - Arguments to find a CDE
     * @example
     * // Get one CDE
     * const cDE = await prisma.cDE.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CDEFindFirstArgs>(args?: SelectSubset<T, CDEFindFirstArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CDE that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEFindFirstOrThrowArgs} args - Arguments to find a CDE
     * @example
     * // Get one CDE
     * const cDE = await prisma.cDE.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CDEFindFirstOrThrowArgs>(args?: SelectSubset<T, CDEFindFirstOrThrowArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CDES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CDES
     * const cDES = await prisma.cDE.findMany()
     * 
     * // Get first 10 CDES
     * const cDES = await prisma.cDE.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cDEWithIdOnly = await prisma.cDE.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CDEFindManyArgs>(args?: SelectSubset<T, CDEFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CDE.
     * @param {CDECreateArgs} args - Arguments to create a CDE.
     * @example
     * // Create one CDE
     * const CDE = await prisma.cDE.create({
     *   data: {
     *     // ... data to create a CDE
     *   }
     * })
     * 
     */
    create<T extends CDECreateArgs>(args: SelectSubset<T, CDECreateArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CDES.
     * @param {CDECreateManyArgs} args - Arguments to create many CDES.
     * @example
     * // Create many CDES
     * const cDE = await prisma.cDE.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CDECreateManyArgs>(args?: SelectSubset<T, CDECreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CDE.
     * @param {CDEDeleteArgs} args - Arguments to delete one CDE.
     * @example
     * // Delete one CDE
     * const CDE = await prisma.cDE.delete({
     *   where: {
     *     // ... filter to delete one CDE
     *   }
     * })
     * 
     */
    delete<T extends CDEDeleteArgs>(args: SelectSubset<T, CDEDeleteArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CDE.
     * @param {CDEUpdateArgs} args - Arguments to update one CDE.
     * @example
     * // Update one CDE
     * const cDE = await prisma.cDE.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CDEUpdateArgs>(args: SelectSubset<T, CDEUpdateArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CDES.
     * @param {CDEDeleteManyArgs} args - Arguments to filter CDES to delete.
     * @example
     * // Delete a few CDES
     * const { count } = await prisma.cDE.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CDEDeleteManyArgs>(args?: SelectSubset<T, CDEDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CDES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CDES
     * const cDE = await prisma.cDE.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CDEUpdateManyArgs>(args: SelectSubset<T, CDEUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CDE.
     * @param {CDEUpsertArgs} args - Arguments to update or create a CDE.
     * @example
     * // Update or create a CDE
     * const cDE = await prisma.cDE.upsert({
     *   create: {
     *     // ... data to create a CDE
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CDE we want to update
     *   }
     * })
     */
    upsert<T extends CDEUpsertArgs>(args: SelectSubset<T, CDEUpsertArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CDES that matches the filter.
     * @param {CDEFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const cDE = await prisma.cDE.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CDEFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CDE.
     * @param {CDEAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const cDE = await prisma.cDE.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CDEAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CDES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDECountArgs} args - Arguments to filter CDES to count.
     * @example
     * // Count the number of CDES
     * const count = await prisma.cDE.count({
     *   where: {
     *     // ... the filter for the CDES we want to count
     *   }
     * })
    **/
    count<T extends CDECountArgs>(
      args?: Subset<T, CDECountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CDECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CDE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CDEAggregateArgs>(args: Subset<T, CDEAggregateArgs>): Prisma.PrismaPromise<GetCDEAggregateType<T>>

    /**
     * Group by CDE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CDEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CDEGroupByArgs['orderBy'] }
        : { orderBy?: CDEGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CDEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCDEGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CDE model
   */
  readonly fields: CDEFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CDE.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CDEClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CDE model
   */
  interface CDEFieldRefs {
    readonly id: FieldRef<"CDE", 'String'>
    readonly CDECode: FieldRef<"CDE", 'String'>
    readonly CDEFullName: FieldRef<"CDE", 'String'>
    readonly CDEVersion: FieldRef<"CDE", 'String'>
    readonly PermissibleValues: FieldRef<"CDE", 'String[]'>
    readonly createdAt: FieldRef<"CDE", 'DateTime'>
    readonly updatedAt: FieldRef<"CDE", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CDE findUnique
   */
  export type CDEFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter, which CDE to fetch.
     */
    where: CDEWhereUniqueInput
  }

  /**
   * CDE findUniqueOrThrow
   */
  export type CDEFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter, which CDE to fetch.
     */
    where: CDEWhereUniqueInput
  }

  /**
   * CDE findFirst
   */
  export type CDEFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter, which CDE to fetch.
     */
    where?: CDEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CDES to fetch.
     */
    orderBy?: CDEOrderByWithRelationInput | CDEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CDES.
     */
    cursor?: CDEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CDES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CDES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CDES.
     */
    distinct?: CDEScalarFieldEnum | CDEScalarFieldEnum[]
  }

  /**
   * CDE findFirstOrThrow
   */
  export type CDEFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter, which CDE to fetch.
     */
    where?: CDEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CDES to fetch.
     */
    orderBy?: CDEOrderByWithRelationInput | CDEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CDES.
     */
    cursor?: CDEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CDES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CDES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CDES.
     */
    distinct?: CDEScalarFieldEnum | CDEScalarFieldEnum[]
  }

  /**
   * CDE findMany
   */
  export type CDEFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter, which CDES to fetch.
     */
    where?: CDEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CDES to fetch.
     */
    orderBy?: CDEOrderByWithRelationInput | CDEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CDES.
     */
    cursor?: CDEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CDES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CDES.
     */
    skip?: number
    distinct?: CDEScalarFieldEnum | CDEScalarFieldEnum[]
  }

  /**
   * CDE create
   */
  export type CDECreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * The data needed to create a CDE.
     */
    data: XOR<CDECreateInput, CDEUncheckedCreateInput>
  }

  /**
   * CDE createMany
   */
  export type CDECreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CDES.
     */
    data: CDECreateManyInput | CDECreateManyInput[]
  }

  /**
   * CDE update
   */
  export type CDEUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * The data needed to update a CDE.
     */
    data: XOR<CDEUpdateInput, CDEUncheckedUpdateInput>
    /**
     * Choose, which CDE to update.
     */
    where: CDEWhereUniqueInput
  }

  /**
   * CDE updateMany
   */
  export type CDEUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CDES.
     */
    data: XOR<CDEUpdateManyMutationInput, CDEUncheckedUpdateManyInput>
    /**
     * Filter which CDES to update
     */
    where?: CDEWhereInput
    /**
     * Limit how many CDES to update.
     */
    limit?: number
  }

  /**
   * CDE upsert
   */
  export type CDEUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * The filter to search for the CDE to update in case it exists.
     */
    where: CDEWhereUniqueInput
    /**
     * In case the CDE found by the `where` argument doesn't exist, create a new CDE with this data.
     */
    create: XOR<CDECreateInput, CDEUncheckedCreateInput>
    /**
     * In case the CDE was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CDEUpdateInput, CDEUncheckedUpdateInput>
  }

  /**
   * CDE delete
   */
  export type CDEDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter which CDE to delete.
     */
    where: CDEWhereUniqueInput
  }

  /**
   * CDE deleteMany
   */
  export type CDEDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CDES to delete
     */
    where?: CDEWhereInput
    /**
     * Limit how many CDES to delete.
     */
    limit?: number
  }

  /**
   * CDE findRaw
   */
  export type CDEFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CDE aggregateRaw
   */
  export type CDEAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CDE without action
   */
  export type CDEDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
  }


  /**
   * Model applications
   */

  export type AggregateApplications = {
    _count: ApplicationsCountAggregateOutputType | null
    _min: ApplicationsMinAggregateOutputType | null
    _max: ApplicationsMaxAggregateOutputType | null
  }

  export type ApplicationsMinAggregateOutputType = {
    id: string | null
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean | null
    createdAt: Date | null
    inactiveReminder: boolean | null
    openAccess: boolean | null
    programAbbreviation: string | null
    programDescription: string | null
    programName: string | null
    questionnaireData: string | null
    reviewComment: string | null
    status: string | null
    studyAbbreviation: string | null
    studyName: string | null
    submittedDate: Date | null
    updatedAt: Date | null
    version: string | null
    wholeProgram: boolean | null
  }

  export type ApplicationsMaxAggregateOutputType = {
    id: string | null
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean | null
    createdAt: Date | null
    inactiveReminder: boolean | null
    openAccess: boolean | null
    programAbbreviation: string | null
    programDescription: string | null
    programName: string | null
    questionnaireData: string | null
    reviewComment: string | null
    status: string | null
    studyAbbreviation: string | null
    studyName: string | null
    submittedDate: Date | null
    updatedAt: Date | null
    version: string | null
    wholeProgram: boolean | null
  }

  export type ApplicationsCountAggregateOutputType = {
    id: number
    ORCID: number
    PI: number
    controlledAccess: number
    createdAt: number
    inactiveReminder: number
    openAccess: number
    programAbbreviation: number
    programDescription: number
    programName: number
    questionnaireData: number
    reviewComment: number
    status: number
    studyAbbreviation: number
    studyName: number
    submittedDate: number
    updatedAt: number
    version: number
    wholeProgram: number
    _all: number
  }


  export type ApplicationsMinAggregateInputType = {
    id?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    createdAt?: true
    inactiveReminder?: true
    openAccess?: true
    programAbbreviation?: true
    programDescription?: true
    programName?: true
    questionnaireData?: true
    reviewComment?: true
    status?: true
    studyAbbreviation?: true
    studyName?: true
    submittedDate?: true
    updatedAt?: true
    version?: true
    wholeProgram?: true
  }

  export type ApplicationsMaxAggregateInputType = {
    id?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    createdAt?: true
    inactiveReminder?: true
    openAccess?: true
    programAbbreviation?: true
    programDescription?: true
    programName?: true
    questionnaireData?: true
    reviewComment?: true
    status?: true
    studyAbbreviation?: true
    studyName?: true
    submittedDate?: true
    updatedAt?: true
    version?: true
    wholeProgram?: true
  }

  export type ApplicationsCountAggregateInputType = {
    id?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    createdAt?: true
    inactiveReminder?: true
    openAccess?: true
    programAbbreviation?: true
    programDescription?: true
    programName?: true
    questionnaireData?: true
    reviewComment?: true
    status?: true
    studyAbbreviation?: true
    studyName?: true
    submittedDate?: true
    updatedAt?: true
    version?: true
    wholeProgram?: true
    _all?: true
  }

  export type ApplicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applications to aggregate.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applications
    **/
    _count?: true | ApplicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationsMaxAggregateInputType
  }

  export type GetApplicationsAggregateType<T extends ApplicationsAggregateArgs> = {
        [P in keyof T & keyof AggregateApplications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplications[P]>
      : GetScalarType<T[P], AggregateApplications[P]>
  }




  export type applicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationsWhereInput
    orderBy?: applicationsOrderByWithAggregationInput | applicationsOrderByWithAggregationInput[]
    by: ApplicationsScalarFieldEnum[] | ApplicationsScalarFieldEnum
    having?: applicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationsCountAggregateInputType | true
    _min?: ApplicationsMinAggregateInputType
    _max?: ApplicationsMaxAggregateInputType
  }

  export type ApplicationsGroupByOutputType = {
    id: string
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean | null
    createdAt: Date
    inactiveReminder: boolean | null
    openAccess: boolean | null
    programAbbreviation: string | null
    programDescription: string | null
    programName: string
    questionnaireData: string
    reviewComment: string | null
    status: string
    studyAbbreviation: string
    studyName: string
    submittedDate: Date | null
    updatedAt: Date
    version: string
    wholeProgram: boolean | null
    _count: ApplicationsCountAggregateOutputType | null
    _min: ApplicationsMinAggregateOutputType | null
    _max: ApplicationsMaxAggregateOutputType | null
  }

  type GetApplicationsGroupByPayload<T extends applicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationsGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationsGroupByOutputType[P]>
        }
      >
    >


  export type applicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ORCID?: boolean
    PI?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    controlledAccess?: boolean
    createdAt?: boolean
    history?: boolean | HistoryDefaultArgs<ExtArgs>
    inactiveReminder?: boolean
    openAccess?: boolean
    organization?: boolean | OrgInfoDefaultArgs<ExtArgs>
    programAbbreviation?: boolean
    programDescription?: boolean
    programName?: boolean
    questionnaireData?: boolean
    reviewComment?: boolean
    status?: boolean
    studyAbbreviation?: boolean
    studyName?: boolean
    submittedDate?: boolean
    updatedAt?: boolean
    version?: boolean
    wholeProgram?: boolean
  }, ExtArgs["result"]["applications"]>



  export type applicationsSelectScalar = {
    id?: boolean
    ORCID?: boolean
    PI?: boolean
    controlledAccess?: boolean
    createdAt?: boolean
    inactiveReminder?: boolean
    openAccess?: boolean
    programAbbreviation?: boolean
    programDescription?: boolean
    programName?: boolean
    questionnaireData?: boolean
    reviewComment?: boolean
    status?: boolean
    studyAbbreviation?: boolean
    studyName?: boolean
    submittedDate?: boolean
    updatedAt?: boolean
    version?: boolean
    wholeProgram?: boolean
  }

  export type applicationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ORCID" | "PI" | "applicant" | "controlledAccess" | "createdAt" | "history" | "inactiveReminder" | "openAccess" | "organization" | "programAbbreviation" | "programDescription" | "programName" | "questionnaireData" | "reviewComment" | "status" | "studyAbbreviation" | "studyName" | "submittedDate" | "updatedAt" | "version" | "wholeProgram", ExtArgs["result"]["applications"]>
  export type applicationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $applicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "applications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ORCID: string | null
      PI: string | null
      controlledAccess: boolean | null
      createdAt: Date
      inactiveReminder: boolean | null
      openAccess: boolean | null
      programAbbreviation: string | null
      programDescription: string | null
      programName: string
      questionnaireData: string
      reviewComment: string | null
      status: string
      studyAbbreviation: string
      studyName: string
      /**
       * Multiple data types found: String: 4.8%, DateTime (Date): 95.2% out of 21 sampled entries
       */
      submittedDate: Date | null
      updatedAt: Date
      version: string
      wholeProgram: boolean | null
    }, ExtArgs["result"]["applications"]>
    composites: {
      applicant: Prisma.$ApplicantPayload
      history: Prisma.$HistoryPayload[]
      organization: Prisma.$OrgInfoPayload
    }
  }

  type applicationsGetPayload<S extends boolean | null | undefined | applicationsDefaultArgs> = $Result.GetResult<Prisma.$applicationsPayload, S>

  type applicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<applicationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationsCountAggregateInputType | true
    }

  export interface applicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['applications'], meta: { name: 'applications' } }
    /**
     * Find zero or one Applications that matches the filter.
     * @param {applicationsFindUniqueArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends applicationsFindUniqueArgs>(args: SelectSubset<T, applicationsFindUniqueArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Applications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {applicationsFindUniqueOrThrowArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends applicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, applicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsFindFirstArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends applicationsFindFirstArgs>(args?: SelectSubset<T, applicationsFindFirstArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsFindFirstOrThrowArgs} args - Arguments to find a Applications
     * @example
     * // Get one Applications
     * const applications = await prisma.applications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends applicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, applicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.applications.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.applications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationsWithIdOnly = await prisma.applications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends applicationsFindManyArgs>(args?: SelectSubset<T, applicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Applications.
     * @param {applicationsCreateArgs} args - Arguments to create a Applications.
     * @example
     * // Create one Applications
     * const Applications = await prisma.applications.create({
     *   data: {
     *     // ... data to create a Applications
     *   }
     * })
     * 
     */
    create<T extends applicationsCreateArgs>(args: SelectSubset<T, applicationsCreateArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applications.
     * @param {applicationsCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const applications = await prisma.applications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends applicationsCreateManyArgs>(args?: SelectSubset<T, applicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Applications.
     * @param {applicationsDeleteArgs} args - Arguments to delete one Applications.
     * @example
     * // Delete one Applications
     * const Applications = await prisma.applications.delete({
     *   where: {
     *     // ... filter to delete one Applications
     *   }
     * })
     * 
     */
    delete<T extends applicationsDeleteArgs>(args: SelectSubset<T, applicationsDeleteArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Applications.
     * @param {applicationsUpdateArgs} args - Arguments to update one Applications.
     * @example
     * // Update one Applications
     * const applications = await prisma.applications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends applicationsUpdateArgs>(args: SelectSubset<T, applicationsUpdateArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applications.
     * @param {applicationsDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.applications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends applicationsDeleteManyArgs>(args?: SelectSubset<T, applicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const applications = await prisma.applications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends applicationsUpdateManyArgs>(args: SelectSubset<T, applicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Applications.
     * @param {applicationsUpsertArgs} args - Arguments to update or create a Applications.
     * @example
     * // Update or create a Applications
     * const applications = await prisma.applications.upsert({
     *   create: {
     *     // ... data to create a Applications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applications we want to update
     *   }
     * })
     */
    upsert<T extends applicationsUpsertArgs>(args: SelectSubset<T, applicationsUpsertArgs<ExtArgs>>): Prisma__applicationsClient<$Result.GetResult<Prisma.$applicationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applications that matches the filter.
     * @param {applicationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const applications = await prisma.applications.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: applicationsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Applications.
     * @param {applicationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const applications = await prisma.applications.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: applicationsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.applications.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends applicationsCountArgs>(
      args?: Subset<T, applicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationsAggregateArgs>(args: Subset<T, ApplicationsAggregateArgs>): Prisma.PrismaPromise<GetApplicationsAggregateType<T>>

    /**
     * Group by Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends applicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: applicationsGroupByArgs['orderBy'] }
        : { orderBy?: applicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, applicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the applications model
   */
  readonly fields: applicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for applications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__applicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the applications model
   */
  interface applicationsFieldRefs {
    readonly id: FieldRef<"applications", 'String'>
    readonly ORCID: FieldRef<"applications", 'String'>
    readonly PI: FieldRef<"applications", 'String'>
    readonly controlledAccess: FieldRef<"applications", 'Boolean'>
    readonly createdAt: FieldRef<"applications", 'DateTime'>
    readonly inactiveReminder: FieldRef<"applications", 'Boolean'>
    readonly openAccess: FieldRef<"applications", 'Boolean'>
    readonly programAbbreviation: FieldRef<"applications", 'String'>
    readonly programDescription: FieldRef<"applications", 'String'>
    readonly programName: FieldRef<"applications", 'String'>
    readonly questionnaireData: FieldRef<"applications", 'String'>
    readonly reviewComment: FieldRef<"applications", 'String'>
    readonly status: FieldRef<"applications", 'String'>
    readonly studyAbbreviation: FieldRef<"applications", 'String'>
    readonly studyName: FieldRef<"applications", 'String'>
    readonly submittedDate: FieldRef<"applications", 'DateTime'>
    readonly updatedAt: FieldRef<"applications", 'DateTime'>
    readonly version: FieldRef<"applications", 'String'>
    readonly wholeProgram: FieldRef<"applications", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * applications findUnique
   */
  export type applicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications findUniqueOrThrow
   */
  export type applicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications findFirst
   */
  export type applicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applications.
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applications.
     */
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * applications findFirstOrThrow
   */
  export type applicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applications.
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applications.
     */
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * applications findMany
   */
  export type applicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter, which applications to fetch.
     */
    where?: applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applications to fetch.
     */
    orderBy?: applicationsOrderByWithRelationInput | applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applications.
     */
    cursor?: applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applications.
     */
    skip?: number
    distinct?: ApplicationsScalarFieldEnum | ApplicationsScalarFieldEnum[]
  }

  /**
   * applications create
   */
  export type applicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * The data needed to create a applications.
     */
    data: XOR<applicationsCreateInput, applicationsUncheckedCreateInput>
  }

  /**
   * applications createMany
   */
  export type applicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many applications.
     */
    data: applicationsCreateManyInput | applicationsCreateManyInput[]
  }

  /**
   * applications update
   */
  export type applicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * The data needed to update a applications.
     */
    data: XOR<applicationsUpdateInput, applicationsUncheckedUpdateInput>
    /**
     * Choose, which applications to update.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications updateMany
   */
  export type applicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update applications.
     */
    data: XOR<applicationsUpdateManyMutationInput, applicationsUncheckedUpdateManyInput>
    /**
     * Filter which applications to update
     */
    where?: applicationsWhereInput
    /**
     * Limit how many applications to update.
     */
    limit?: number
  }

  /**
   * applications upsert
   */
  export type applicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * The filter to search for the applications to update in case it exists.
     */
    where: applicationsWhereUniqueInput
    /**
     * In case the applications found by the `where` argument doesn't exist, create a new applications with this data.
     */
    create: XOR<applicationsCreateInput, applicationsUncheckedCreateInput>
    /**
     * In case the applications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<applicationsUpdateInput, applicationsUncheckedUpdateInput>
  }

  /**
   * applications delete
   */
  export type applicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
    /**
     * Filter which applications to delete.
     */
    where: applicationsWhereUniqueInput
  }

  /**
   * applications deleteMany
   */
  export type applicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applications to delete
     */
    where?: applicationsWhereInput
    /**
     * Limit how many applications to delete.
     */
    limit?: number
  }

  /**
   * applications findRaw
   */
  export type applicationsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * applications aggregateRaw
   */
  export type applicationsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * applications without action
   */
  export type applicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applications
     */
    select?: applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applications
     */
    omit?: applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicationsInclude<ExtArgs> | null
  }


  /**
   * Model approvedStudies
   */

  export type AggregateApprovedStudies = {
    _count: ApprovedStudiesCountAggregateOutputType | null
    _min: ApprovedStudiesMinAggregateOutputType | null
    _max: ApprovedStudiesMaxAggregateOutputType | null
  }

  export type ApprovedStudiesMinAggregateOutputType = {
    id: string | null
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean | null
    createdAt: Date | null
    dbGaPID: string | null
    openAccess: boolean | null
    originalOrg: string | null
    primaryContactID: string | null
    programName: string | null
    studyAbbreviation: string | null
    studyName: string | null
    updatedAt: Date | null
    useProgramPC: boolean | null
  }

  export type ApprovedStudiesMaxAggregateOutputType = {
    id: string | null
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean | null
    createdAt: Date | null
    dbGaPID: string | null
    openAccess: boolean | null
    originalOrg: string | null
    primaryContactID: string | null
    programName: string | null
    studyAbbreviation: string | null
    studyName: string | null
    updatedAt: Date | null
    useProgramPC: boolean | null
  }

  export type ApprovedStudiesCountAggregateOutputType = {
    id: number
    ORCID: number
    PI: number
    controlledAccess: number
    createdAt: number
    dbGaPID: number
    openAccess: number
    originalOrg: number
    primaryContactID: number
    programName: number
    studyAbbreviation: number
    studyName: number
    updatedAt: number
    useProgramPC: number
    _all: number
  }


  export type ApprovedStudiesMinAggregateInputType = {
    id?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    createdAt?: true
    dbGaPID?: true
    openAccess?: true
    originalOrg?: true
    primaryContactID?: true
    programName?: true
    studyAbbreviation?: true
    studyName?: true
    updatedAt?: true
    useProgramPC?: true
  }

  export type ApprovedStudiesMaxAggregateInputType = {
    id?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    createdAt?: true
    dbGaPID?: true
    openAccess?: true
    originalOrg?: true
    primaryContactID?: true
    programName?: true
    studyAbbreviation?: true
    studyName?: true
    updatedAt?: true
    useProgramPC?: true
  }

  export type ApprovedStudiesCountAggregateInputType = {
    id?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    createdAt?: true
    dbGaPID?: true
    openAccess?: true
    originalOrg?: true
    primaryContactID?: true
    programName?: true
    studyAbbreviation?: true
    studyName?: true
    updatedAt?: true
    useProgramPC?: true
    _all?: true
  }

  export type ApprovedStudiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which approvedStudies to aggregate.
     */
    where?: approvedStudiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of approvedStudies to fetch.
     */
    orderBy?: approvedStudiesOrderByWithRelationInput | approvedStudiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: approvedStudiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` approvedStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` approvedStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned approvedStudies
    **/
    _count?: true | ApprovedStudiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovedStudiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovedStudiesMaxAggregateInputType
  }

  export type GetApprovedStudiesAggregateType<T extends ApprovedStudiesAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovedStudies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovedStudies[P]>
      : GetScalarType<T[P], AggregateApprovedStudies[P]>
  }




  export type approvedStudiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: approvedStudiesWhereInput
    orderBy?: approvedStudiesOrderByWithAggregationInput | approvedStudiesOrderByWithAggregationInput[]
    by: ApprovedStudiesScalarFieldEnum[] | ApprovedStudiesScalarFieldEnum
    having?: approvedStudiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovedStudiesCountAggregateInputType | true
    _min?: ApprovedStudiesMinAggregateInputType
    _max?: ApprovedStudiesMaxAggregateInputType
  }

  export type ApprovedStudiesGroupByOutputType = {
    id: string
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean
    createdAt: Date
    dbGaPID: string | null
    openAccess: boolean | null
    originalOrg: string | null
    primaryContactID: string | null
    programName: string | null
    studyAbbreviation: string
    studyName: string
    updatedAt: Date
    useProgramPC: boolean | null
    _count: ApprovedStudiesCountAggregateOutputType | null
    _min: ApprovedStudiesMinAggregateOutputType | null
    _max: ApprovedStudiesMaxAggregateOutputType | null
  }

  type GetApprovedStudiesGroupByPayload<T extends approvedStudiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovedStudiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovedStudiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovedStudiesGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovedStudiesGroupByOutputType[P]>
        }
      >
    >


  export type approvedStudiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ORCID?: boolean
    PI?: boolean
    controlledAccess?: boolean
    createdAt?: boolean
    dbGaPID?: boolean
    openAccess?: boolean
    originalOrg?: boolean
    primaryContactID?: boolean
    programName?: boolean
    studyAbbreviation?: boolean
    studyName?: boolean
    updatedAt?: boolean
    useProgramPC?: boolean
  }, ExtArgs["result"]["approvedStudies"]>



  export type approvedStudiesSelectScalar = {
    id?: boolean
    ORCID?: boolean
    PI?: boolean
    controlledAccess?: boolean
    createdAt?: boolean
    dbGaPID?: boolean
    openAccess?: boolean
    originalOrg?: boolean
    primaryContactID?: boolean
    programName?: boolean
    studyAbbreviation?: boolean
    studyName?: boolean
    updatedAt?: boolean
    useProgramPC?: boolean
  }

  export type approvedStudiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ORCID" | "PI" | "controlledAccess" | "createdAt" | "dbGaPID" | "openAccess" | "originalOrg" | "primaryContactID" | "programName" | "studyAbbreviation" | "studyName" | "updatedAt" | "useProgramPC", ExtArgs["result"]["approvedStudies"]>

  export type $approvedStudiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "approvedStudies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ORCID: string | null
      PI: string | null
      controlledAccess: boolean
      createdAt: Date
      dbGaPID: string | null
      openAccess: boolean | null
      originalOrg: string | null
      primaryContactID: string | null
      programName: string | null
      studyAbbreviation: string
      studyName: string
      updatedAt: Date
      useProgramPC: boolean | null
    }, ExtArgs["result"]["approvedStudies"]>
    composites: {}
  }

  type approvedStudiesGetPayload<S extends boolean | null | undefined | approvedStudiesDefaultArgs> = $Result.GetResult<Prisma.$approvedStudiesPayload, S>

  type approvedStudiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<approvedStudiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApprovedStudiesCountAggregateInputType | true
    }

  export interface approvedStudiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['approvedStudies'], meta: { name: 'approvedStudies' } }
    /**
     * Find zero or one ApprovedStudies that matches the filter.
     * @param {approvedStudiesFindUniqueArgs} args - Arguments to find a ApprovedStudies
     * @example
     * // Get one ApprovedStudies
     * const approvedStudies = await prisma.approvedStudies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends approvedStudiesFindUniqueArgs>(args: SelectSubset<T, approvedStudiesFindUniqueArgs<ExtArgs>>): Prisma__approvedStudiesClient<$Result.GetResult<Prisma.$approvedStudiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApprovedStudies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {approvedStudiesFindUniqueOrThrowArgs} args - Arguments to find a ApprovedStudies
     * @example
     * // Get one ApprovedStudies
     * const approvedStudies = await prisma.approvedStudies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends approvedStudiesFindUniqueOrThrowArgs>(args: SelectSubset<T, approvedStudiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__approvedStudiesClient<$Result.GetResult<Prisma.$approvedStudiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovedStudies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {approvedStudiesFindFirstArgs} args - Arguments to find a ApprovedStudies
     * @example
     * // Get one ApprovedStudies
     * const approvedStudies = await prisma.approvedStudies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends approvedStudiesFindFirstArgs>(args?: SelectSubset<T, approvedStudiesFindFirstArgs<ExtArgs>>): Prisma__approvedStudiesClient<$Result.GetResult<Prisma.$approvedStudiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovedStudies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {approvedStudiesFindFirstOrThrowArgs} args - Arguments to find a ApprovedStudies
     * @example
     * // Get one ApprovedStudies
     * const approvedStudies = await prisma.approvedStudies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends approvedStudiesFindFirstOrThrowArgs>(args?: SelectSubset<T, approvedStudiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__approvedStudiesClient<$Result.GetResult<Prisma.$approvedStudiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApprovedStudies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {approvedStudiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovedStudies
     * const approvedStudies = await prisma.approvedStudies.findMany()
     * 
     * // Get first 10 ApprovedStudies
     * const approvedStudies = await prisma.approvedStudies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvedStudiesWithIdOnly = await prisma.approvedStudies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends approvedStudiesFindManyArgs>(args?: SelectSubset<T, approvedStudiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$approvedStudiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApprovedStudies.
     * @param {approvedStudiesCreateArgs} args - Arguments to create a ApprovedStudies.
     * @example
     * // Create one ApprovedStudies
     * const ApprovedStudies = await prisma.approvedStudies.create({
     *   data: {
     *     // ... data to create a ApprovedStudies
     *   }
     * })
     * 
     */
    create<T extends approvedStudiesCreateArgs>(args: SelectSubset<T, approvedStudiesCreateArgs<ExtArgs>>): Prisma__approvedStudiesClient<$Result.GetResult<Prisma.$approvedStudiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApprovedStudies.
     * @param {approvedStudiesCreateManyArgs} args - Arguments to create many ApprovedStudies.
     * @example
     * // Create many ApprovedStudies
     * const approvedStudies = await prisma.approvedStudies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends approvedStudiesCreateManyArgs>(args?: SelectSubset<T, approvedStudiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ApprovedStudies.
     * @param {approvedStudiesDeleteArgs} args - Arguments to delete one ApprovedStudies.
     * @example
     * // Delete one ApprovedStudies
     * const ApprovedStudies = await prisma.approvedStudies.delete({
     *   where: {
     *     // ... filter to delete one ApprovedStudies
     *   }
     * })
     * 
     */
    delete<T extends approvedStudiesDeleteArgs>(args: SelectSubset<T, approvedStudiesDeleteArgs<ExtArgs>>): Prisma__approvedStudiesClient<$Result.GetResult<Prisma.$approvedStudiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApprovedStudies.
     * @param {approvedStudiesUpdateArgs} args - Arguments to update one ApprovedStudies.
     * @example
     * // Update one ApprovedStudies
     * const approvedStudies = await prisma.approvedStudies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends approvedStudiesUpdateArgs>(args: SelectSubset<T, approvedStudiesUpdateArgs<ExtArgs>>): Prisma__approvedStudiesClient<$Result.GetResult<Prisma.$approvedStudiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApprovedStudies.
     * @param {approvedStudiesDeleteManyArgs} args - Arguments to filter ApprovedStudies to delete.
     * @example
     * // Delete a few ApprovedStudies
     * const { count } = await prisma.approvedStudies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends approvedStudiesDeleteManyArgs>(args?: SelectSubset<T, approvedStudiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovedStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {approvedStudiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovedStudies
     * const approvedStudies = await prisma.approvedStudies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends approvedStudiesUpdateManyArgs>(args: SelectSubset<T, approvedStudiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApprovedStudies.
     * @param {approvedStudiesUpsertArgs} args - Arguments to update or create a ApprovedStudies.
     * @example
     * // Update or create a ApprovedStudies
     * const approvedStudies = await prisma.approvedStudies.upsert({
     *   create: {
     *     // ... data to create a ApprovedStudies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovedStudies we want to update
     *   }
     * })
     */
    upsert<T extends approvedStudiesUpsertArgs>(args: SelectSubset<T, approvedStudiesUpsertArgs<ExtArgs>>): Prisma__approvedStudiesClient<$Result.GetResult<Prisma.$approvedStudiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApprovedStudies that matches the filter.
     * @param {approvedStudiesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const approvedStudies = await prisma.approvedStudies.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: approvedStudiesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ApprovedStudies.
     * @param {approvedStudiesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const approvedStudies = await prisma.approvedStudies.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: approvedStudiesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ApprovedStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {approvedStudiesCountArgs} args - Arguments to filter ApprovedStudies to count.
     * @example
     * // Count the number of ApprovedStudies
     * const count = await prisma.approvedStudies.count({
     *   where: {
     *     // ... the filter for the ApprovedStudies we want to count
     *   }
     * })
    **/
    count<T extends approvedStudiesCountArgs>(
      args?: Subset<T, approvedStudiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovedStudiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovedStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovedStudiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovedStudiesAggregateArgs>(args: Subset<T, ApprovedStudiesAggregateArgs>): Prisma.PrismaPromise<GetApprovedStudiesAggregateType<T>>

    /**
     * Group by ApprovedStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {approvedStudiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends approvedStudiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: approvedStudiesGroupByArgs['orderBy'] }
        : { orderBy?: approvedStudiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, approvedStudiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovedStudiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the approvedStudies model
   */
  readonly fields: approvedStudiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for approvedStudies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__approvedStudiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the approvedStudies model
   */
  interface approvedStudiesFieldRefs {
    readonly id: FieldRef<"approvedStudies", 'String'>
    readonly ORCID: FieldRef<"approvedStudies", 'String'>
    readonly PI: FieldRef<"approvedStudies", 'String'>
    readonly controlledAccess: FieldRef<"approvedStudies", 'Boolean'>
    readonly createdAt: FieldRef<"approvedStudies", 'DateTime'>
    readonly dbGaPID: FieldRef<"approvedStudies", 'String'>
    readonly openAccess: FieldRef<"approvedStudies", 'Boolean'>
    readonly originalOrg: FieldRef<"approvedStudies", 'String'>
    readonly primaryContactID: FieldRef<"approvedStudies", 'String'>
    readonly programName: FieldRef<"approvedStudies", 'String'>
    readonly studyAbbreviation: FieldRef<"approvedStudies", 'String'>
    readonly studyName: FieldRef<"approvedStudies", 'String'>
    readonly updatedAt: FieldRef<"approvedStudies", 'DateTime'>
    readonly useProgramPC: FieldRef<"approvedStudies", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * approvedStudies findUnique
   */
  export type approvedStudiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the approvedStudies
     */
    select?: approvedStudiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the approvedStudies
     */
    omit?: approvedStudiesOmit<ExtArgs> | null
    /**
     * Filter, which approvedStudies to fetch.
     */
    where: approvedStudiesWhereUniqueInput
  }

  /**
   * approvedStudies findUniqueOrThrow
   */
  export type approvedStudiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the approvedStudies
     */
    select?: approvedStudiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the approvedStudies
     */
    omit?: approvedStudiesOmit<ExtArgs> | null
    /**
     * Filter, which approvedStudies to fetch.
     */
    where: approvedStudiesWhereUniqueInput
  }

  /**
   * approvedStudies findFirst
   */
  export type approvedStudiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the approvedStudies
     */
    select?: approvedStudiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the approvedStudies
     */
    omit?: approvedStudiesOmit<ExtArgs> | null
    /**
     * Filter, which approvedStudies to fetch.
     */
    where?: approvedStudiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of approvedStudies to fetch.
     */
    orderBy?: approvedStudiesOrderByWithRelationInput | approvedStudiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for approvedStudies.
     */
    cursor?: approvedStudiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` approvedStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` approvedStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of approvedStudies.
     */
    distinct?: ApprovedStudiesScalarFieldEnum | ApprovedStudiesScalarFieldEnum[]
  }

  /**
   * approvedStudies findFirstOrThrow
   */
  export type approvedStudiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the approvedStudies
     */
    select?: approvedStudiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the approvedStudies
     */
    omit?: approvedStudiesOmit<ExtArgs> | null
    /**
     * Filter, which approvedStudies to fetch.
     */
    where?: approvedStudiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of approvedStudies to fetch.
     */
    orderBy?: approvedStudiesOrderByWithRelationInput | approvedStudiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for approvedStudies.
     */
    cursor?: approvedStudiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` approvedStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` approvedStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of approvedStudies.
     */
    distinct?: ApprovedStudiesScalarFieldEnum | ApprovedStudiesScalarFieldEnum[]
  }

  /**
   * approvedStudies findMany
   */
  export type approvedStudiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the approvedStudies
     */
    select?: approvedStudiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the approvedStudies
     */
    omit?: approvedStudiesOmit<ExtArgs> | null
    /**
     * Filter, which approvedStudies to fetch.
     */
    where?: approvedStudiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of approvedStudies to fetch.
     */
    orderBy?: approvedStudiesOrderByWithRelationInput | approvedStudiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing approvedStudies.
     */
    cursor?: approvedStudiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` approvedStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` approvedStudies.
     */
    skip?: number
    distinct?: ApprovedStudiesScalarFieldEnum | ApprovedStudiesScalarFieldEnum[]
  }

  /**
   * approvedStudies create
   */
  export type approvedStudiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the approvedStudies
     */
    select?: approvedStudiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the approvedStudies
     */
    omit?: approvedStudiesOmit<ExtArgs> | null
    /**
     * The data needed to create a approvedStudies.
     */
    data: XOR<approvedStudiesCreateInput, approvedStudiesUncheckedCreateInput>
  }

  /**
   * approvedStudies createMany
   */
  export type approvedStudiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many approvedStudies.
     */
    data: approvedStudiesCreateManyInput | approvedStudiesCreateManyInput[]
  }

  /**
   * approvedStudies update
   */
  export type approvedStudiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the approvedStudies
     */
    select?: approvedStudiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the approvedStudies
     */
    omit?: approvedStudiesOmit<ExtArgs> | null
    /**
     * The data needed to update a approvedStudies.
     */
    data: XOR<approvedStudiesUpdateInput, approvedStudiesUncheckedUpdateInput>
    /**
     * Choose, which approvedStudies to update.
     */
    where: approvedStudiesWhereUniqueInput
  }

  /**
   * approvedStudies updateMany
   */
  export type approvedStudiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update approvedStudies.
     */
    data: XOR<approvedStudiesUpdateManyMutationInput, approvedStudiesUncheckedUpdateManyInput>
    /**
     * Filter which approvedStudies to update
     */
    where?: approvedStudiesWhereInput
    /**
     * Limit how many approvedStudies to update.
     */
    limit?: number
  }

  /**
   * approvedStudies upsert
   */
  export type approvedStudiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the approvedStudies
     */
    select?: approvedStudiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the approvedStudies
     */
    omit?: approvedStudiesOmit<ExtArgs> | null
    /**
     * The filter to search for the approvedStudies to update in case it exists.
     */
    where: approvedStudiesWhereUniqueInput
    /**
     * In case the approvedStudies found by the `where` argument doesn't exist, create a new approvedStudies with this data.
     */
    create: XOR<approvedStudiesCreateInput, approvedStudiesUncheckedCreateInput>
    /**
     * In case the approvedStudies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<approvedStudiesUpdateInput, approvedStudiesUncheckedUpdateInput>
  }

  /**
   * approvedStudies delete
   */
  export type approvedStudiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the approvedStudies
     */
    select?: approvedStudiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the approvedStudies
     */
    omit?: approvedStudiesOmit<ExtArgs> | null
    /**
     * Filter which approvedStudies to delete.
     */
    where: approvedStudiesWhereUniqueInput
  }

  /**
   * approvedStudies deleteMany
   */
  export type approvedStudiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which approvedStudies to delete
     */
    where?: approvedStudiesWhereInput
    /**
     * Limit how many approvedStudies to delete.
     */
    limit?: number
  }

  /**
   * approvedStudies findRaw
   */
  export type approvedStudiesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * approvedStudies aggregateRaw
   */
  export type approvedStudiesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * approvedStudies without action
   */
  export type approvedStudiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the approvedStudies
     */
    select?: approvedStudiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the approvedStudies
     */
    omit?: approvedStudiesOmit<ExtArgs> | null
  }


  /**
   * Model batch
   */

  export type AggregateBatch = {
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  export type BatchAvgAggregateOutputType = {
    displayID: number | null
    fileCount: number | null
  }

  export type BatchSumAggregateOutputType = {
    displayID: number | null
    fileCount: number | null
  }

  export type BatchMinAggregateOutputType = {
    id: string | null
    bucketName: string | null
    createdAt: Date | null
    displayID: number | null
    fileCount: number | null
    filePrefix: string | null
    status: string | null
    submissionID: string | null
    submitterID: string | null
    submitterName: string | null
    type: string | null
    updatedAt: Date | null
    zipFileName: string | null
  }

  export type BatchMaxAggregateOutputType = {
    id: string | null
    bucketName: string | null
    createdAt: Date | null
    displayID: number | null
    fileCount: number | null
    filePrefix: string | null
    status: string | null
    submissionID: string | null
    submitterID: string | null
    submitterName: string | null
    type: string | null
    updatedAt: Date | null
    zipFileName: string | null
  }

  export type BatchCountAggregateOutputType = {
    id: number
    bucketName: number
    createdAt: number
    displayID: number
    errors: number
    fileCount: number
    filePrefix: number
    status: number
    submissionID: number
    submitterID: number
    submitterName: number
    type: number
    updatedAt: number
    zipFileName: number
    _all: number
  }


  export type BatchAvgAggregateInputType = {
    displayID?: true
    fileCount?: true
  }

  export type BatchSumAggregateInputType = {
    displayID?: true
    fileCount?: true
  }

  export type BatchMinAggregateInputType = {
    id?: true
    bucketName?: true
    createdAt?: true
    displayID?: true
    fileCount?: true
    filePrefix?: true
    status?: true
    submissionID?: true
    submitterID?: true
    submitterName?: true
    type?: true
    updatedAt?: true
    zipFileName?: true
  }

  export type BatchMaxAggregateInputType = {
    id?: true
    bucketName?: true
    createdAt?: true
    displayID?: true
    fileCount?: true
    filePrefix?: true
    status?: true
    submissionID?: true
    submitterID?: true
    submitterName?: true
    type?: true
    updatedAt?: true
    zipFileName?: true
  }

  export type BatchCountAggregateInputType = {
    id?: true
    bucketName?: true
    createdAt?: true
    displayID?: true
    errors?: true
    fileCount?: true
    filePrefix?: true
    status?: true
    submissionID?: true
    submitterID?: true
    submitterName?: true
    type?: true
    updatedAt?: true
    zipFileName?: true
    _all?: true
  }

  export type BatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which batch to aggregate.
     */
    where?: batchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of batches to fetch.
     */
    orderBy?: batchOrderByWithRelationInput | batchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: batchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned batches
    **/
    _count?: true | BatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchMaxAggregateInputType
  }

  export type GetBatchAggregateType<T extends BatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatch[P]>
      : GetScalarType<T[P], AggregateBatch[P]>
  }




  export type batchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: batchWhereInput
    orderBy?: batchOrderByWithAggregationInput | batchOrderByWithAggregationInput[]
    by: BatchScalarFieldEnum[] | BatchScalarFieldEnum
    having?: batchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchCountAggregateInputType | true
    _avg?: BatchAvgAggregateInputType
    _sum?: BatchSumAggregateInputType
    _min?: BatchMinAggregateInputType
    _max?: BatchMaxAggregateInputType
  }

  export type BatchGroupByOutputType = {
    id: string
    bucketName: string
    createdAt: Date
    displayID: number
    errors: string[]
    fileCount: number
    filePrefix: string
    status: string
    submissionID: string
    submitterID: string | null
    submitterName: string | null
    type: string
    updatedAt: Date
    zipFileName: string | null
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  type GetBatchGroupByPayload<T extends batchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchGroupByOutputType[P]>
            : GetScalarType<T[P], BatchGroupByOutputType[P]>
        }
      >
    >


  export type batchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bucketName?: boolean
    createdAt?: boolean
    displayID?: boolean
    errors?: boolean
    fileCount?: boolean
    filePrefix?: boolean
    files?: boolean | BatchFilesDefaultArgs<ExtArgs>
    status?: boolean
    submissionID?: boolean
    submitterID?: boolean
    submitterName?: boolean
    type?: boolean
    updatedAt?: boolean
    zipFileName?: boolean
  }, ExtArgs["result"]["batch"]>



  export type batchSelectScalar = {
    id?: boolean
    bucketName?: boolean
    createdAt?: boolean
    displayID?: boolean
    errors?: boolean
    fileCount?: boolean
    filePrefix?: boolean
    status?: boolean
    submissionID?: boolean
    submitterID?: boolean
    submitterName?: boolean
    type?: boolean
    updatedAt?: boolean
    zipFileName?: boolean
  }

  export type batchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bucketName" | "createdAt" | "displayID" | "errors" | "fileCount" | "filePrefix" | "files" | "status" | "submissionID" | "submitterID" | "submitterName" | "type" | "updatedAt" | "zipFileName", ExtArgs["result"]["batch"]>
  export type batchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $batchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "batch"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bucketName: string
      createdAt: Date
      displayID: number
      errors: string[]
      fileCount: number
      filePrefix: string
      status: string
      submissionID: string
      submitterID: string | null
      submitterName: string | null
      type: string
      updatedAt: Date
      zipFileName: string | null
    }, ExtArgs["result"]["batch"]>
    composites: {
      files: Prisma.$BatchFilesPayload[]
    }
  }

  type batchGetPayload<S extends boolean | null | undefined | batchDefaultArgs> = $Result.GetResult<Prisma.$batchPayload, S>

  type batchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<batchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchCountAggregateInputType | true
    }

  export interface batchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['batch'], meta: { name: 'batch' } }
    /**
     * Find zero or one Batch that matches the filter.
     * @param {batchFindUniqueArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends batchFindUniqueArgs>(args: SelectSubset<T, batchFindUniqueArgs<ExtArgs>>): Prisma__batchClient<$Result.GetResult<Prisma.$batchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Batch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {batchFindUniqueOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends batchFindUniqueOrThrowArgs>(args: SelectSubset<T, batchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__batchClient<$Result.GetResult<Prisma.$batchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchFindFirstArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends batchFindFirstArgs>(args?: SelectSubset<T, batchFindFirstArgs<ExtArgs>>): Prisma__batchClient<$Result.GetResult<Prisma.$batchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchFindFirstOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends batchFindFirstOrThrowArgs>(args?: SelectSubset<T, batchFindFirstOrThrowArgs<ExtArgs>>): Prisma__batchClient<$Result.GetResult<Prisma.$batchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batches
     * const batches = await prisma.batch.findMany()
     * 
     * // Get first 10 Batches
     * const batches = await prisma.batch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchWithIdOnly = await prisma.batch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends batchFindManyArgs>(args?: SelectSubset<T, batchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$batchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Batch.
     * @param {batchCreateArgs} args - Arguments to create a Batch.
     * @example
     * // Create one Batch
     * const Batch = await prisma.batch.create({
     *   data: {
     *     // ... data to create a Batch
     *   }
     * })
     * 
     */
    create<T extends batchCreateArgs>(args: SelectSubset<T, batchCreateArgs<ExtArgs>>): Prisma__batchClient<$Result.GetResult<Prisma.$batchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Batches.
     * @param {batchCreateManyArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends batchCreateManyArgs>(args?: SelectSubset<T, batchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Batch.
     * @param {batchDeleteArgs} args - Arguments to delete one Batch.
     * @example
     * // Delete one Batch
     * const Batch = await prisma.batch.delete({
     *   where: {
     *     // ... filter to delete one Batch
     *   }
     * })
     * 
     */
    delete<T extends batchDeleteArgs>(args: SelectSubset<T, batchDeleteArgs<ExtArgs>>): Prisma__batchClient<$Result.GetResult<Prisma.$batchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Batch.
     * @param {batchUpdateArgs} args - Arguments to update one Batch.
     * @example
     * // Update one Batch
     * const batch = await prisma.batch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends batchUpdateArgs>(args: SelectSubset<T, batchUpdateArgs<ExtArgs>>): Prisma__batchClient<$Result.GetResult<Prisma.$batchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Batches.
     * @param {batchDeleteManyArgs} args - Arguments to filter Batches to delete.
     * @example
     * // Delete a few Batches
     * const { count } = await prisma.batch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends batchDeleteManyArgs>(args?: SelectSubset<T, batchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends batchUpdateManyArgs>(args: SelectSubset<T, batchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Batch.
     * @param {batchUpsertArgs} args - Arguments to update or create a Batch.
     * @example
     * // Update or create a Batch
     * const batch = await prisma.batch.upsert({
     *   create: {
     *     // ... data to create a Batch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batch we want to update
     *   }
     * })
     */
    upsert<T extends batchUpsertArgs>(args: SelectSubset<T, batchUpsertArgs<ExtArgs>>): Prisma__batchClient<$Result.GetResult<Prisma.$batchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batches that matches the filter.
     * @param {batchFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const batch = await prisma.batch.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: batchFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Batch.
     * @param {batchAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const batch = await prisma.batch.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: batchAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchCountArgs} args - Arguments to filter Batches to count.
     * @example
     * // Count the number of Batches
     * const count = await prisma.batch.count({
     *   where: {
     *     // ... the filter for the Batches we want to count
     *   }
     * })
    **/
    count<T extends batchCountArgs>(
      args?: Subset<T, batchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAggregateArgs>(args: Subset<T, BatchAggregateArgs>): Prisma.PrismaPromise<GetBatchAggregateType<T>>

    /**
     * Group by Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends batchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: batchGroupByArgs['orderBy'] }
        : { orderBy?: batchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, batchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the batch model
   */
  readonly fields: batchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for batch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__batchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the batch model
   */
  interface batchFieldRefs {
    readonly id: FieldRef<"batch", 'String'>
    readonly bucketName: FieldRef<"batch", 'String'>
    readonly createdAt: FieldRef<"batch", 'DateTime'>
    readonly displayID: FieldRef<"batch", 'Int'>
    readonly errors: FieldRef<"batch", 'String[]'>
    readonly fileCount: FieldRef<"batch", 'Int'>
    readonly filePrefix: FieldRef<"batch", 'String'>
    readonly status: FieldRef<"batch", 'String'>
    readonly submissionID: FieldRef<"batch", 'String'>
    readonly submitterID: FieldRef<"batch", 'String'>
    readonly submitterName: FieldRef<"batch", 'String'>
    readonly type: FieldRef<"batch", 'String'>
    readonly updatedAt: FieldRef<"batch", 'DateTime'>
    readonly zipFileName: FieldRef<"batch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * batch findUnique
   */
  export type batchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batch
     */
    select?: batchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batch
     */
    omit?: batchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: batchInclude<ExtArgs> | null
    /**
     * Filter, which batch to fetch.
     */
    where: batchWhereUniqueInput
  }

  /**
   * batch findUniqueOrThrow
   */
  export type batchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batch
     */
    select?: batchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batch
     */
    omit?: batchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: batchInclude<ExtArgs> | null
    /**
     * Filter, which batch to fetch.
     */
    where: batchWhereUniqueInput
  }

  /**
   * batch findFirst
   */
  export type batchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batch
     */
    select?: batchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batch
     */
    omit?: batchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: batchInclude<ExtArgs> | null
    /**
     * Filter, which batch to fetch.
     */
    where?: batchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of batches to fetch.
     */
    orderBy?: batchOrderByWithRelationInput | batchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for batches.
     */
    cursor?: batchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * batch findFirstOrThrow
   */
  export type batchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batch
     */
    select?: batchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batch
     */
    omit?: batchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: batchInclude<ExtArgs> | null
    /**
     * Filter, which batch to fetch.
     */
    where?: batchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of batches to fetch.
     */
    orderBy?: batchOrderByWithRelationInput | batchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for batches.
     */
    cursor?: batchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * batch findMany
   */
  export type batchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batch
     */
    select?: batchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batch
     */
    omit?: batchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: batchInclude<ExtArgs> | null
    /**
     * Filter, which batches to fetch.
     */
    where?: batchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of batches to fetch.
     */
    orderBy?: batchOrderByWithRelationInput | batchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing batches.
     */
    cursor?: batchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` batches.
     */
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * batch create
   */
  export type batchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batch
     */
    select?: batchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batch
     */
    omit?: batchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: batchInclude<ExtArgs> | null
    /**
     * The data needed to create a batch.
     */
    data: XOR<batchCreateInput, batchUncheckedCreateInput>
  }

  /**
   * batch createMany
   */
  export type batchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many batches.
     */
    data: batchCreateManyInput | batchCreateManyInput[]
  }

  /**
   * batch update
   */
  export type batchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batch
     */
    select?: batchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batch
     */
    omit?: batchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: batchInclude<ExtArgs> | null
    /**
     * The data needed to update a batch.
     */
    data: XOR<batchUpdateInput, batchUncheckedUpdateInput>
    /**
     * Choose, which batch to update.
     */
    where: batchWhereUniqueInput
  }

  /**
   * batch updateMany
   */
  export type batchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update batches.
     */
    data: XOR<batchUpdateManyMutationInput, batchUncheckedUpdateManyInput>
    /**
     * Filter which batches to update
     */
    where?: batchWhereInput
    /**
     * Limit how many batches to update.
     */
    limit?: number
  }

  /**
   * batch upsert
   */
  export type batchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batch
     */
    select?: batchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batch
     */
    omit?: batchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: batchInclude<ExtArgs> | null
    /**
     * The filter to search for the batch to update in case it exists.
     */
    where: batchWhereUniqueInput
    /**
     * In case the batch found by the `where` argument doesn't exist, create a new batch with this data.
     */
    create: XOR<batchCreateInput, batchUncheckedCreateInput>
    /**
     * In case the batch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<batchUpdateInput, batchUncheckedUpdateInput>
  }

  /**
   * batch delete
   */
  export type batchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batch
     */
    select?: batchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batch
     */
    omit?: batchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: batchInclude<ExtArgs> | null
    /**
     * Filter which batch to delete.
     */
    where: batchWhereUniqueInput
  }

  /**
   * batch deleteMany
   */
  export type batchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which batches to delete
     */
    where?: batchWhereInput
    /**
     * Limit how many batches to delete.
     */
    limit?: number
  }

  /**
   * batch findRaw
   */
  export type batchFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * batch aggregateRaw
   */
  export type batchAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * batch without action
   */
  export type batchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batch
     */
    select?: batchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batch
     */
    omit?: batchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: batchInclude<ExtArgs> | null
  }


  /**
   * Model configuration
   */

  export type AggregateConfiguration = {
    _count: ConfigurationCountAggregateOutputType | null
    _avg: ConfigurationAvgAggregateOutputType | null
    _sum: ConfigurationSumAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  export type ConfigurationAvgAggregateOutputType = {
    COMPLETED_RETENTION_DAYS: number | null
    DASHBOARD_SESSION_TIMEOUT: number | null
    INACTIVE_APPLICATION_DAYS: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE: number | null
    INACTIVE_USER_DAYS: number | null
    PRESIGN_EXPIRATION: number | null
    REMIND_APPLICATION_DAYS: number | null
    ROLE_TIMEOUT: number | null
    age: number | null
    days: number | null
    interval: number | null
    timeout: number | null
  }

  export type ConfigurationSumAggregateOutputType = {
    COMPLETED_RETENTION_DAYS: number | null
    DASHBOARD_SESSION_TIMEOUT: number | null
    INACTIVE_APPLICATION_DAYS: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE: number | null
    INACTIVE_USER_DAYS: number | null
    PRESIGN_EXPIRATION: number | null
    REMIND_APPLICATION_DAYS: number | null
    ROLE_TIMEOUT: number | null
    age: number | null
    days: number | null
    interval: number | null
    timeout: number | null
  }

  export type ConfigurationMinAggregateOutputType = {
    id: string | null
    COMPLETED_RETENTION_DAYS: number | null
    DASHBOARD_SESSION_TIMEOUT: number | null
    EMAIL_URL: string | null
    INACTIVE_APPLICATION_DAYS: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE: number | null
    INACTIVE_USER_DAYS: number | null
    OFFICIAL_EMAIL: string | null
    PRESIGN_EXPIRATION: number | null
    PROD_URL: string | null
    REMIND_APPLICATION_DAYS: number | null
    ROLE_TIMEOUT: number | null
    SCHEDULED_JOBS: string | null
    SUBMISSION_BUCKET: string | null
    SUBMISSION_HELPDESK: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL: string | null
    SUBMISSION_SYSTEM_PORTAL: string | null
    TECH_SUPPORT_EMAIL: string | null
    age: number | null
    bucketName: string | null
    current: string | null
    current_version: string | null
    dashboardID: string | null
    dataCommons: string | null
    days: number | null
    interval: number | null
    new: string | null
    prefix: string | null
    timeout: number | null
    type: string | null
    version: string | null
  }

  export type ConfigurationMaxAggregateOutputType = {
    id: string | null
    COMPLETED_RETENTION_DAYS: number | null
    DASHBOARD_SESSION_TIMEOUT: number | null
    EMAIL_URL: string | null
    INACTIVE_APPLICATION_DAYS: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE: number | null
    INACTIVE_USER_DAYS: number | null
    OFFICIAL_EMAIL: string | null
    PRESIGN_EXPIRATION: number | null
    PROD_URL: string | null
    REMIND_APPLICATION_DAYS: number | null
    ROLE_TIMEOUT: number | null
    SCHEDULED_JOBS: string | null
    SUBMISSION_BUCKET: string | null
    SUBMISSION_HELPDESK: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL: string | null
    SUBMISSION_SYSTEM_PORTAL: string | null
    TECH_SUPPORT_EMAIL: string | null
    age: number | null
    bucketName: string | null
    current: string | null
    current_version: string | null
    dashboardID: string | null
    dataCommons: string | null
    days: number | null
    interval: number | null
    new: string | null
    prefix: string | null
    timeout: number | null
    type: string | null
    version: string | null
  }

  export type ConfigurationCountAggregateOutputType = {
    id: number
    COMPLETED_RETENTION_DAYS: number
    DASHBOARD_SESSION_TIMEOUT: number
    EMAIL_URL: number
    INACTIVE_APPLICATION_DAYS: number
    INACTIVE_SUBMISSION_DAYS_DELETE: number
    INACTIVE_USER_DAYS: number
    OFFICIAL_EMAIL: number
    PRESIGN_EXPIRATION: number
    PROD_URL: number
    REMIND_APPLICATION_DAYS: number
    REVIEW_COMMITTEE_EMAIL: number
    ROLE_TIMEOUT: number
    SCHEDULED_JOBS: number
    SUBMISSION_BUCKET: number
    SUBMISSION_HELPDESK: number
    SUBMISSION_REQUEST_CONTACT_EMAIL: number
    SUBMISSION_SYSTEM_PORTAL: number
    TECH_SUPPORT_EMAIL: number
    age: number
    bucketName: number
    current: number
    current_version: number
    dashboardID: number
    dataCommons: number
    days: number
    interval: number
    key: number
    keys: number
    new: number
    prefix: number
    timeout: number
    type: number
    version: number
    _all: number
  }


  export type ConfigurationAvgAggregateInputType = {
    COMPLETED_RETENTION_DAYS?: true
    DASHBOARD_SESSION_TIMEOUT?: true
    INACTIVE_APPLICATION_DAYS?: true
    INACTIVE_SUBMISSION_DAYS_DELETE?: true
    INACTIVE_USER_DAYS?: true
    PRESIGN_EXPIRATION?: true
    REMIND_APPLICATION_DAYS?: true
    ROLE_TIMEOUT?: true
    age?: true
    days?: true
    interval?: true
    timeout?: true
  }

  export type ConfigurationSumAggregateInputType = {
    COMPLETED_RETENTION_DAYS?: true
    DASHBOARD_SESSION_TIMEOUT?: true
    INACTIVE_APPLICATION_DAYS?: true
    INACTIVE_SUBMISSION_DAYS_DELETE?: true
    INACTIVE_USER_DAYS?: true
    PRESIGN_EXPIRATION?: true
    REMIND_APPLICATION_DAYS?: true
    ROLE_TIMEOUT?: true
    age?: true
    days?: true
    interval?: true
    timeout?: true
  }

  export type ConfigurationMinAggregateInputType = {
    id?: true
    COMPLETED_RETENTION_DAYS?: true
    DASHBOARD_SESSION_TIMEOUT?: true
    EMAIL_URL?: true
    INACTIVE_APPLICATION_DAYS?: true
    INACTIVE_SUBMISSION_DAYS_DELETE?: true
    INACTIVE_USER_DAYS?: true
    OFFICIAL_EMAIL?: true
    PRESIGN_EXPIRATION?: true
    PROD_URL?: true
    REMIND_APPLICATION_DAYS?: true
    ROLE_TIMEOUT?: true
    SCHEDULED_JOBS?: true
    SUBMISSION_BUCKET?: true
    SUBMISSION_HELPDESK?: true
    SUBMISSION_REQUEST_CONTACT_EMAIL?: true
    SUBMISSION_SYSTEM_PORTAL?: true
    TECH_SUPPORT_EMAIL?: true
    age?: true
    bucketName?: true
    current?: true
    current_version?: true
    dashboardID?: true
    dataCommons?: true
    days?: true
    interval?: true
    new?: true
    prefix?: true
    timeout?: true
    type?: true
    version?: true
  }

  export type ConfigurationMaxAggregateInputType = {
    id?: true
    COMPLETED_RETENTION_DAYS?: true
    DASHBOARD_SESSION_TIMEOUT?: true
    EMAIL_URL?: true
    INACTIVE_APPLICATION_DAYS?: true
    INACTIVE_SUBMISSION_DAYS_DELETE?: true
    INACTIVE_USER_DAYS?: true
    OFFICIAL_EMAIL?: true
    PRESIGN_EXPIRATION?: true
    PROD_URL?: true
    REMIND_APPLICATION_DAYS?: true
    ROLE_TIMEOUT?: true
    SCHEDULED_JOBS?: true
    SUBMISSION_BUCKET?: true
    SUBMISSION_HELPDESK?: true
    SUBMISSION_REQUEST_CONTACT_EMAIL?: true
    SUBMISSION_SYSTEM_PORTAL?: true
    TECH_SUPPORT_EMAIL?: true
    age?: true
    bucketName?: true
    current?: true
    current_version?: true
    dashboardID?: true
    dataCommons?: true
    days?: true
    interval?: true
    new?: true
    prefix?: true
    timeout?: true
    type?: true
    version?: true
  }

  export type ConfigurationCountAggregateInputType = {
    id?: true
    COMPLETED_RETENTION_DAYS?: true
    DASHBOARD_SESSION_TIMEOUT?: true
    EMAIL_URL?: true
    INACTIVE_APPLICATION_DAYS?: true
    INACTIVE_SUBMISSION_DAYS_DELETE?: true
    INACTIVE_USER_DAYS?: true
    OFFICIAL_EMAIL?: true
    PRESIGN_EXPIRATION?: true
    PROD_URL?: true
    REMIND_APPLICATION_DAYS?: true
    REVIEW_COMMITTEE_EMAIL?: true
    ROLE_TIMEOUT?: true
    SCHEDULED_JOBS?: true
    SUBMISSION_BUCKET?: true
    SUBMISSION_HELPDESK?: true
    SUBMISSION_REQUEST_CONTACT_EMAIL?: true
    SUBMISSION_SYSTEM_PORTAL?: true
    TECH_SUPPORT_EMAIL?: true
    age?: true
    bucketName?: true
    current?: true
    current_version?: true
    dashboardID?: true
    dataCommons?: true
    days?: true
    interval?: true
    key?: true
    keys?: true
    new?: true
    prefix?: true
    timeout?: true
    type?: true
    version?: true
    _all?: true
  }

  export type ConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configuration to aggregate.
     */
    where?: configurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configurations to fetch.
     */
    orderBy?: configurationOrderByWithRelationInput | configurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configurations
    **/
    _count?: true | ConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigurationMaxAggregateInputType
  }

  export type GetConfigurationAggregateType<T extends ConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguration[P]>
      : GetScalarType<T[P], AggregateConfiguration[P]>
  }




  export type configurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configurationWhereInput
    orderBy?: configurationOrderByWithAggregationInput | configurationOrderByWithAggregationInput[]
    by: ConfigurationScalarFieldEnum[] | ConfigurationScalarFieldEnum
    having?: configurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigurationCountAggregateInputType | true
    _avg?: ConfigurationAvgAggregateInputType
    _sum?: ConfigurationSumAggregateInputType
    _min?: ConfigurationMinAggregateInputType
    _max?: ConfigurationMaxAggregateInputType
  }

  export type ConfigurationGroupByOutputType = {
    id: string
    COMPLETED_RETENTION_DAYS: number | null
    DASHBOARD_SESSION_TIMEOUT: number | null
    EMAIL_URL: string | null
    INACTIVE_APPLICATION_DAYS: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE: number | null
    INACTIVE_USER_DAYS: number | null
    OFFICIAL_EMAIL: string | null
    PRESIGN_EXPIRATION: number | null
    PROD_URL: string | null
    REMIND_APPLICATION_DAYS: number | null
    REVIEW_COMMITTEE_EMAIL: string[]
    ROLE_TIMEOUT: number | null
    SCHEDULED_JOBS: string | null
    SUBMISSION_BUCKET: string | null
    SUBMISSION_HELPDESK: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL: string | null
    SUBMISSION_SYSTEM_PORTAL: string | null
    TECH_SUPPORT_EMAIL: string | null
    age: number | null
    bucketName: string | null
    current: string | null
    current_version: string | null
    dashboardID: string | null
    dataCommons: string | null
    days: number | null
    interval: number | null
    key: string[]
    keys: JsonValue | null
    new: string | null
    prefix: string | null
    timeout: number | null
    type: string
    version: string | null
    _count: ConfigurationCountAggregateOutputType | null
    _avg: ConfigurationAvgAggregateOutputType | null
    _sum: ConfigurationSumAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  type GetConfigurationGroupByPayload<T extends configurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type configurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    COMPLETED_RETENTION_DAYS?: boolean
    DASHBOARD_SESSION_TIMEOUT?: boolean
    Defaults?: boolean | PBACDefaultsDefaultArgs<ExtArgs>
    EMAIL_URL?: boolean
    INACTIVE_APPLICATION_DAYS?: boolean
    INACTIVE_SUBMISSION_DAYS_DELETE?: boolean
    INACTIVE_USER_DAYS?: boolean
    OFFICIAL_EMAIL?: boolean
    PRESIGN_EXPIRATION?: boolean
    PROD_URL?: boolean
    REMIND_APPLICATION_DAYS?: boolean
    REVIEW_COMMITTEE_EMAIL?: boolean
    ROLE_TIMEOUT?: boolean
    SCHEDULED_JOBS?: boolean
    SUBMISSION_BUCKET?: boolean
    SUBMISSION_HELPDESK?: boolean
    SUBMISSION_REQUEST_CONTACT_EMAIL?: boolean
    SUBMISSION_SYSTEM_PORTAL?: boolean
    TECH_SUPPORT_EMAIL?: boolean
    age?: boolean
    bucketName?: boolean
    current?: boolean
    current_version?: boolean
    dashboardID?: boolean
    dataCommons?: boolean
    days?: boolean
    interval?: boolean
    key?: boolean
    keys?: boolean
    new?: boolean
    prefix?: boolean
    tag?: boolean | ConfigurationTagDefaultArgs<ExtArgs>
    timeout?: boolean
    type?: boolean
    version?: boolean
  }, ExtArgs["result"]["configuration"]>



  export type configurationSelectScalar = {
    id?: boolean
    COMPLETED_RETENTION_DAYS?: boolean
    DASHBOARD_SESSION_TIMEOUT?: boolean
    EMAIL_URL?: boolean
    INACTIVE_APPLICATION_DAYS?: boolean
    INACTIVE_SUBMISSION_DAYS_DELETE?: boolean
    INACTIVE_USER_DAYS?: boolean
    OFFICIAL_EMAIL?: boolean
    PRESIGN_EXPIRATION?: boolean
    PROD_URL?: boolean
    REMIND_APPLICATION_DAYS?: boolean
    REVIEW_COMMITTEE_EMAIL?: boolean
    ROLE_TIMEOUT?: boolean
    SCHEDULED_JOBS?: boolean
    SUBMISSION_BUCKET?: boolean
    SUBMISSION_HELPDESK?: boolean
    SUBMISSION_REQUEST_CONTACT_EMAIL?: boolean
    SUBMISSION_SYSTEM_PORTAL?: boolean
    TECH_SUPPORT_EMAIL?: boolean
    age?: boolean
    bucketName?: boolean
    current?: boolean
    current_version?: boolean
    dashboardID?: boolean
    dataCommons?: boolean
    days?: boolean
    interval?: boolean
    key?: boolean
    keys?: boolean
    new?: boolean
    prefix?: boolean
    timeout?: boolean
    type?: boolean
    version?: boolean
  }

  export type configurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "COMPLETED_RETENTION_DAYS" | "DASHBOARD_SESSION_TIMEOUT" | "Defaults" | "EMAIL_URL" | "INACTIVE_APPLICATION_DAYS" | "INACTIVE_SUBMISSION_DAYS_DELETE" | "INACTIVE_USER_DAYS" | "OFFICIAL_EMAIL" | "PRESIGN_EXPIRATION" | "PROD_URL" | "REMIND_APPLICATION_DAYS" | "REVIEW_COMMITTEE_EMAIL" | "ROLE_TIMEOUT" | "SCHEDULED_JOBS" | "SUBMISSION_BUCKET" | "SUBMISSION_HELPDESK" | "SUBMISSION_REQUEST_CONTACT_EMAIL" | "SUBMISSION_SYSTEM_PORTAL" | "TECH_SUPPORT_EMAIL" | "age" | "bucketName" | "current" | "current_version" | "dashboardID" | "dataCommons" | "days" | "interval" | "key" | "keys" | "new" | "prefix" | "tag" | "timeout" | "type" | "version", ExtArgs["result"]["configuration"]>
  export type configurationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $configurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "configuration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      COMPLETED_RETENTION_DAYS: number | null
      DASHBOARD_SESSION_TIMEOUT: number | null
      EMAIL_URL: string | null
      INACTIVE_APPLICATION_DAYS: number | null
      INACTIVE_SUBMISSION_DAYS_DELETE: number | null
      INACTIVE_USER_DAYS: number | null
      OFFICIAL_EMAIL: string | null
      PRESIGN_EXPIRATION: number | null
      PROD_URL: string | null
      REMIND_APPLICATION_DAYS: number | null
      REVIEW_COMMITTEE_EMAIL: string[]
      ROLE_TIMEOUT: number | null
      SCHEDULED_JOBS: string | null
      SUBMISSION_BUCKET: string | null
      SUBMISSION_HELPDESK: string | null
      SUBMISSION_REQUEST_CONTACT_EMAIL: string | null
      SUBMISSION_SYSTEM_PORTAL: string | null
      TECH_SUPPORT_EMAIL: string | null
      age: number | null
      bucketName: string | null
      current: string | null
      current_version: string | null
      dashboardID: string | null
      dataCommons: string | null
      days: number | null
      interval: number | null
      key: string[]
      keys: Prisma.JsonValue | null
      new: string | null
      prefix: string | null
      timeout: number | null
      type: string
      version: string | null
    }, ExtArgs["result"]["configuration"]>
    composites: {
      Defaults: Prisma.$PBACDefaultsPayload[]
      tag: Prisma.$ConfigurationTagPayload | null
    }
  }

  type configurationGetPayload<S extends boolean | null | undefined | configurationDefaultArgs> = $Result.GetResult<Prisma.$configurationPayload, S>

  type configurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<configurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigurationCountAggregateInputType | true
    }

  export interface configurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['configuration'], meta: { name: 'configuration' } }
    /**
     * Find zero or one Configuration that matches the filter.
     * @param {configurationFindUniqueArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends configurationFindUniqueArgs>(args: SelectSubset<T, configurationFindUniqueArgs<ExtArgs>>): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Configuration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {configurationFindUniqueOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends configurationFindUniqueOrThrowArgs>(args: SelectSubset<T, configurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configuration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationFindFirstArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends configurationFindFirstArgs>(args?: SelectSubset<T, configurationFindFirstArgs<ExtArgs>>): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configuration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationFindFirstOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends configurationFindFirstOrThrowArgs>(args?: SelectSubset<T, configurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configurations
     * const configurations = await prisma.configuration.findMany()
     * 
     * // Get first 10 Configurations
     * const configurations = await prisma.configuration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configurationWithIdOnly = await prisma.configuration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends configurationFindManyArgs>(args?: SelectSubset<T, configurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Configuration.
     * @param {configurationCreateArgs} args - Arguments to create a Configuration.
     * @example
     * // Create one Configuration
     * const Configuration = await prisma.configuration.create({
     *   data: {
     *     // ... data to create a Configuration
     *   }
     * })
     * 
     */
    create<T extends configurationCreateArgs>(args: SelectSubset<T, configurationCreateArgs<ExtArgs>>): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Configurations.
     * @param {configurationCreateManyArgs} args - Arguments to create many Configurations.
     * @example
     * // Create many Configurations
     * const configuration = await prisma.configuration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends configurationCreateManyArgs>(args?: SelectSubset<T, configurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Configuration.
     * @param {configurationDeleteArgs} args - Arguments to delete one Configuration.
     * @example
     * // Delete one Configuration
     * const Configuration = await prisma.configuration.delete({
     *   where: {
     *     // ... filter to delete one Configuration
     *   }
     * })
     * 
     */
    delete<T extends configurationDeleteArgs>(args: SelectSubset<T, configurationDeleteArgs<ExtArgs>>): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Configuration.
     * @param {configurationUpdateArgs} args - Arguments to update one Configuration.
     * @example
     * // Update one Configuration
     * const configuration = await prisma.configuration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends configurationUpdateArgs>(args: SelectSubset<T, configurationUpdateArgs<ExtArgs>>): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Configurations.
     * @param {configurationDeleteManyArgs} args - Arguments to filter Configurations to delete.
     * @example
     * // Delete a few Configurations
     * const { count } = await prisma.configuration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends configurationDeleteManyArgs>(args?: SelectSubset<T, configurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configurations
     * const configuration = await prisma.configuration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends configurationUpdateManyArgs>(args: SelectSubset<T, configurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configuration.
     * @param {configurationUpsertArgs} args - Arguments to update or create a Configuration.
     * @example
     * // Update or create a Configuration
     * const configuration = await prisma.configuration.upsert({
     *   create: {
     *     // ... data to create a Configuration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configuration we want to update
     *   }
     * })
     */
    upsert<T extends configurationUpsertArgs>(args: SelectSubset<T, configurationUpsertArgs<ExtArgs>>): Prisma__configurationClient<$Result.GetResult<Prisma.$configurationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configurations that matches the filter.
     * @param {configurationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const configuration = await prisma.configuration.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: configurationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Configuration.
     * @param {configurationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const configuration = await prisma.configuration.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: configurationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationCountArgs} args - Arguments to filter Configurations to count.
     * @example
     * // Count the number of Configurations
     * const count = await prisma.configuration.count({
     *   where: {
     *     // ... the filter for the Configurations we want to count
     *   }
     * })
    **/
    count<T extends configurationCountArgs>(
      args?: Subset<T, configurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigurationAggregateArgs>(args: Subset<T, ConfigurationAggregateArgs>): Prisma.PrismaPromise<GetConfigurationAggregateType<T>>

    /**
     * Group by Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configurationGroupByArgs['orderBy'] }
        : { orderBy?: configurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the configuration model
   */
  readonly fields: configurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for configuration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the configuration model
   */
  interface configurationFieldRefs {
    readonly id: FieldRef<"configuration", 'String'>
    readonly COMPLETED_RETENTION_DAYS: FieldRef<"configuration", 'Int'>
    readonly DASHBOARD_SESSION_TIMEOUT: FieldRef<"configuration", 'Int'>
    readonly EMAIL_URL: FieldRef<"configuration", 'String'>
    readonly INACTIVE_APPLICATION_DAYS: FieldRef<"configuration", 'Int'>
    readonly INACTIVE_SUBMISSION_DAYS_DELETE: FieldRef<"configuration", 'Int'>
    readonly INACTIVE_USER_DAYS: FieldRef<"configuration", 'Int'>
    readonly OFFICIAL_EMAIL: FieldRef<"configuration", 'String'>
    readonly PRESIGN_EXPIRATION: FieldRef<"configuration", 'Int'>
    readonly PROD_URL: FieldRef<"configuration", 'String'>
    readonly REMIND_APPLICATION_DAYS: FieldRef<"configuration", 'Int'>
    readonly REVIEW_COMMITTEE_EMAIL: FieldRef<"configuration", 'String[]'>
    readonly ROLE_TIMEOUT: FieldRef<"configuration", 'Int'>
    readonly SCHEDULED_JOBS: FieldRef<"configuration", 'String'>
    readonly SUBMISSION_BUCKET: FieldRef<"configuration", 'String'>
    readonly SUBMISSION_HELPDESK: FieldRef<"configuration", 'String'>
    readonly SUBMISSION_REQUEST_CONTACT_EMAIL: FieldRef<"configuration", 'String'>
    readonly SUBMISSION_SYSTEM_PORTAL: FieldRef<"configuration", 'String'>
    readonly TECH_SUPPORT_EMAIL: FieldRef<"configuration", 'String'>
    readonly age: FieldRef<"configuration", 'Int'>
    readonly bucketName: FieldRef<"configuration", 'String'>
    readonly current: FieldRef<"configuration", 'String'>
    readonly current_version: FieldRef<"configuration", 'String'>
    readonly dashboardID: FieldRef<"configuration", 'String'>
    readonly dataCommons: FieldRef<"configuration", 'String'>
    readonly days: FieldRef<"configuration", 'Int'>
    readonly interval: FieldRef<"configuration", 'Int'>
    readonly key: FieldRef<"configuration", 'String[]'>
    readonly keys: FieldRef<"configuration", 'Json'>
    readonly new: FieldRef<"configuration", 'String'>
    readonly prefix: FieldRef<"configuration", 'String'>
    readonly timeout: FieldRef<"configuration", 'Int'>
    readonly type: FieldRef<"configuration", 'String'>
    readonly version: FieldRef<"configuration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * configuration findUnique
   */
  export type configurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuration
     */
    omit?: configurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configurationInclude<ExtArgs> | null
    /**
     * Filter, which configuration to fetch.
     */
    where: configurationWhereUniqueInput
  }

  /**
   * configuration findUniqueOrThrow
   */
  export type configurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuration
     */
    omit?: configurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configurationInclude<ExtArgs> | null
    /**
     * Filter, which configuration to fetch.
     */
    where: configurationWhereUniqueInput
  }

  /**
   * configuration findFirst
   */
  export type configurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuration
     */
    omit?: configurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configurationInclude<ExtArgs> | null
    /**
     * Filter, which configuration to fetch.
     */
    where?: configurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configurations to fetch.
     */
    orderBy?: configurationOrderByWithRelationInput | configurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configurations.
     */
    cursor?: configurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * configuration findFirstOrThrow
   */
  export type configurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuration
     */
    omit?: configurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configurationInclude<ExtArgs> | null
    /**
     * Filter, which configuration to fetch.
     */
    where?: configurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configurations to fetch.
     */
    orderBy?: configurationOrderByWithRelationInput | configurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configurations.
     */
    cursor?: configurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * configuration findMany
   */
  export type configurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuration
     */
    omit?: configurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configurationInclude<ExtArgs> | null
    /**
     * Filter, which configurations to fetch.
     */
    where?: configurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configurations to fetch.
     */
    orderBy?: configurationOrderByWithRelationInput | configurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configurations.
     */
    cursor?: configurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configurations.
     */
    skip?: number
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * configuration create
   */
  export type configurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuration
     */
    omit?: configurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configurationInclude<ExtArgs> | null
    /**
     * The data needed to create a configuration.
     */
    data: XOR<configurationCreateInput, configurationUncheckedCreateInput>
  }

  /**
   * configuration createMany
   */
  export type configurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configurations.
     */
    data: configurationCreateManyInput | configurationCreateManyInput[]
  }

  /**
   * configuration update
   */
  export type configurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuration
     */
    omit?: configurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configurationInclude<ExtArgs> | null
    /**
     * The data needed to update a configuration.
     */
    data: XOR<configurationUpdateInput, configurationUncheckedUpdateInput>
    /**
     * Choose, which configuration to update.
     */
    where: configurationWhereUniqueInput
  }

  /**
   * configuration updateMany
   */
  export type configurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configurations.
     */
    data: XOR<configurationUpdateManyMutationInput, configurationUncheckedUpdateManyInput>
    /**
     * Filter which configurations to update
     */
    where?: configurationWhereInput
    /**
     * Limit how many configurations to update.
     */
    limit?: number
  }

  /**
   * configuration upsert
   */
  export type configurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuration
     */
    omit?: configurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configurationInclude<ExtArgs> | null
    /**
     * The filter to search for the configuration to update in case it exists.
     */
    where: configurationWhereUniqueInput
    /**
     * In case the configuration found by the `where` argument doesn't exist, create a new configuration with this data.
     */
    create: XOR<configurationCreateInput, configurationUncheckedCreateInput>
    /**
     * In case the configuration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configurationUpdateInput, configurationUncheckedUpdateInput>
  }

  /**
   * configuration delete
   */
  export type configurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuration
     */
    omit?: configurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configurationInclude<ExtArgs> | null
    /**
     * Filter which configuration to delete.
     */
    where: configurationWhereUniqueInput
  }

  /**
   * configuration deleteMany
   */
  export type configurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configurations to delete
     */
    where?: configurationWhereInput
    /**
     * Limit how many configurations to delete.
     */
    limit?: number
  }

  /**
   * configuration findRaw
   */
  export type configurationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * configuration aggregateRaw
   */
  export type configurationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * configuration without action
   */
  export type configurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuration
     */
    select?: configurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuration
     */
    omit?: configurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: configurationInclude<ExtArgs> | null
  }


  /**
   * Model dataRecords
   */

  export type AggregateDataRecords = {
    _count: DataRecordsCountAggregateOutputType | null
    _avg: DataRecordsAvgAggregateOutputType | null
    _sum: DataRecordsSumAggregateOutputType | null
    _min: DataRecordsMinAggregateOutputType | null
    _max: DataRecordsMaxAggregateOutputType | null
  }

  export type DataRecordsAvgAggregateOutputType = {
    latestBatchDisplayID: number | null
    lineNumber: number | null
  }

  export type DataRecordsSumAggregateOutputType = {
    latestBatchDisplayID: number | null
    lineNumber: number | null
  }

  export type DataRecordsMinAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    IDPropName: string | null
    createdAt: Date | null
    dataCommons: string | null
    entityType: string | null
    latestBatchDisplayID: number | null
    latestBatchID: string | null
    lineNumber: number | null
    nodeID: string | null
    nodeType: string | null
    orginalFileName: string | null
    qcResultID: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    updatedAt: Date | null
    uploadedDate: Date | null
    validatedAt: Date | null
  }

  export type DataRecordsMaxAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    IDPropName: string | null
    createdAt: Date | null
    dataCommons: string | null
    entityType: string | null
    latestBatchDisplayID: number | null
    latestBatchID: string | null
    lineNumber: number | null
    nodeID: string | null
    nodeType: string | null
    orginalFileName: string | null
    qcResultID: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    updatedAt: Date | null
    uploadedDate: Date | null
    validatedAt: Date | null
  }

  export type DataRecordsCountAggregateOutputType = {
    id: number
    CRDC_ID: number
    IDPropName: number
    batchIDs: number
    createdAt: number
    dataCommons: number
    entityType: number
    latestBatchDisplayID: number
    latestBatchID: number
    lineNumber: number
    nodeID: number
    nodeType: number
    orginalFileName: number
    props: number
    qcResultID: number
    rawData: number
    status: number
    studyID: number
    submissionID: number
    updatedAt: number
    uploadedDate: number
    validatedAt: number
    _all: number
  }


  export type DataRecordsAvgAggregateInputType = {
    latestBatchDisplayID?: true
    lineNumber?: true
  }

  export type DataRecordsSumAggregateInputType = {
    latestBatchDisplayID?: true
    lineNumber?: true
  }

  export type DataRecordsMinAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    createdAt?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    qcResultID?: true
    status?: true
    studyID?: true
    submissionID?: true
    updatedAt?: true
    uploadedDate?: true
    validatedAt?: true
  }

  export type DataRecordsMaxAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    createdAt?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    qcResultID?: true
    status?: true
    studyID?: true
    submissionID?: true
    updatedAt?: true
    uploadedDate?: true
    validatedAt?: true
  }

  export type DataRecordsCountAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    batchIDs?: true
    createdAt?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    props?: true
    qcResultID?: true
    rawData?: true
    status?: true
    studyID?: true
    submissionID?: true
    updatedAt?: true
    uploadedDate?: true
    validatedAt?: true
    _all?: true
  }

  export type DataRecordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dataRecords to aggregate.
     */
    where?: dataRecordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dataRecords to fetch.
     */
    orderBy?: dataRecordsOrderByWithRelationInput | dataRecordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dataRecordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dataRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dataRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dataRecords
    **/
    _count?: true | DataRecordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataRecordsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataRecordsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataRecordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataRecordsMaxAggregateInputType
  }

  export type GetDataRecordsAggregateType<T extends DataRecordsAggregateArgs> = {
        [P in keyof T & keyof AggregateDataRecords]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataRecords[P]>
      : GetScalarType<T[P], AggregateDataRecords[P]>
  }




  export type dataRecordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dataRecordsWhereInput
    orderBy?: dataRecordsOrderByWithAggregationInput | dataRecordsOrderByWithAggregationInput[]
    by: DataRecordsScalarFieldEnum[] | DataRecordsScalarFieldEnum
    having?: dataRecordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataRecordsCountAggregateInputType | true
    _avg?: DataRecordsAvgAggregateInputType
    _sum?: DataRecordsSumAggregateInputType
    _min?: DataRecordsMinAggregateInputType
    _max?: DataRecordsMaxAggregateInputType
  }

  export type DataRecordsGroupByOutputType = {
    id: string
    CRDC_ID: string | null
    IDPropName: string
    batchIDs: string[]
    createdAt: Date
    dataCommons: string
    entityType: string | null
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    props: JsonValue
    qcResultID: string | null
    rawData: JsonValue
    status: string
    studyID: string
    submissionID: string
    updatedAt: Date
    uploadedDate: Date
    validatedAt: Date | null
    _count: DataRecordsCountAggregateOutputType | null
    _avg: DataRecordsAvgAggregateOutputType | null
    _sum: DataRecordsSumAggregateOutputType | null
    _min: DataRecordsMinAggregateOutputType | null
    _max: DataRecordsMaxAggregateOutputType | null
  }

  type GetDataRecordsGroupByPayload<T extends dataRecordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataRecordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataRecordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataRecordsGroupByOutputType[P]>
            : GetScalarType<T[P], DataRecordsGroupByOutputType[P]>
        }
      >
    >


  export type dataRecordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CRDC_ID?: boolean
    IDPropName?: boolean
    additionalErrors?: boolean | AdditionalErrorDefaultArgs<ExtArgs>
    batchIDs?: boolean
    createdAt?: boolean
    dataCommons?: boolean
    entityType?: boolean
    errors?: boolean | ErrorDefaultArgs<ExtArgs>
    latestBatchDisplayID?: boolean
    latestBatchID?: boolean
    lineNumber?: boolean
    nodeID?: boolean
    nodeType?: boolean
    orginalFileName?: boolean
    parents?: boolean | ParentDefaultArgs<ExtArgs>
    props?: boolean
    qcResultID?: boolean
    rawData?: boolean
    s3FileInfo?: boolean | S3FileInfoDefaultArgs<ExtArgs>
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    updatedAt?: boolean
    uploadedDate?: boolean
    validatedAt?: boolean
    warnings?: boolean | ErrorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataRecords"]>



  export type dataRecordsSelectScalar = {
    id?: boolean
    CRDC_ID?: boolean
    IDPropName?: boolean
    batchIDs?: boolean
    createdAt?: boolean
    dataCommons?: boolean
    entityType?: boolean
    latestBatchDisplayID?: boolean
    latestBatchID?: boolean
    lineNumber?: boolean
    nodeID?: boolean
    nodeType?: boolean
    orginalFileName?: boolean
    props?: boolean
    qcResultID?: boolean
    rawData?: boolean
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    updatedAt?: boolean
    uploadedDate?: boolean
    validatedAt?: boolean
  }

  export type dataRecordsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "CRDC_ID" | "IDPropName" | "additionalErrors" | "batchIDs" | "createdAt" | "dataCommons" | "entityType" | "errors" | "latestBatchDisplayID" | "latestBatchID" | "lineNumber" | "nodeID" | "nodeType" | "orginalFileName" | "parents" | "props" | "qcResultID" | "rawData" | "s3FileInfo" | "status" | "studyID" | "submissionID" | "updatedAt" | "uploadedDate" | "validatedAt" | "warnings", ExtArgs["result"]["dataRecords"]>
  export type dataRecordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $dataRecordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dataRecords"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      CRDC_ID: string | null
      IDPropName: string
      batchIDs: string[]
      createdAt: Date
      dataCommons: string
      entityType: string | null
      latestBatchDisplayID: number
      latestBatchID: string
      lineNumber: number
      nodeID: string
      nodeType: string
      orginalFileName: string
      props: Prisma.JsonValue
      qcResultID: string | null
      rawData: Prisma.JsonValue
      status: string
      studyID: string
      submissionID: string
      updatedAt: Date
      uploadedDate: Date
      validatedAt: Date | null
    }, ExtArgs["result"]["dataRecords"]>
    composites: {
      additionalErrors: Prisma.$AdditionalErrorPayload[]
      errors: Prisma.$ErrorPayload[]
      parents: Prisma.$ParentPayload[]
      s3FileInfo: Prisma.$S3FileInfoPayload | null
      warnings: Prisma.$ErrorPayload[]
    }
  }

  type dataRecordsGetPayload<S extends boolean | null | undefined | dataRecordsDefaultArgs> = $Result.GetResult<Prisma.$dataRecordsPayload, S>

  type dataRecordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<dataRecordsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataRecordsCountAggregateInputType | true
    }

  export interface dataRecordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dataRecords'], meta: { name: 'dataRecords' } }
    /**
     * Find zero or one DataRecords that matches the filter.
     * @param {dataRecordsFindUniqueArgs} args - Arguments to find a DataRecords
     * @example
     * // Get one DataRecords
     * const dataRecords = await prisma.dataRecords.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dataRecordsFindUniqueArgs>(args: SelectSubset<T, dataRecordsFindUniqueArgs<ExtArgs>>): Prisma__dataRecordsClient<$Result.GetResult<Prisma.$dataRecordsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataRecords that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {dataRecordsFindUniqueOrThrowArgs} args - Arguments to find a DataRecords
     * @example
     * // Get one DataRecords
     * const dataRecords = await prisma.dataRecords.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dataRecordsFindUniqueOrThrowArgs>(args: SelectSubset<T, dataRecordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dataRecordsClient<$Result.GetResult<Prisma.$dataRecordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsFindFirstArgs} args - Arguments to find a DataRecords
     * @example
     * // Get one DataRecords
     * const dataRecords = await prisma.dataRecords.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dataRecordsFindFirstArgs>(args?: SelectSubset<T, dataRecordsFindFirstArgs<ExtArgs>>): Prisma__dataRecordsClient<$Result.GetResult<Prisma.$dataRecordsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRecords that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsFindFirstOrThrowArgs} args - Arguments to find a DataRecords
     * @example
     * // Get one DataRecords
     * const dataRecords = await prisma.dataRecords.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dataRecordsFindFirstOrThrowArgs>(args?: SelectSubset<T, dataRecordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__dataRecordsClient<$Result.GetResult<Prisma.$dataRecordsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataRecords
     * const dataRecords = await prisma.dataRecords.findMany()
     * 
     * // Get first 10 DataRecords
     * const dataRecords = await prisma.dataRecords.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataRecordsWithIdOnly = await prisma.dataRecords.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dataRecordsFindManyArgs>(args?: SelectSubset<T, dataRecordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dataRecordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataRecords.
     * @param {dataRecordsCreateArgs} args - Arguments to create a DataRecords.
     * @example
     * // Create one DataRecords
     * const DataRecords = await prisma.dataRecords.create({
     *   data: {
     *     // ... data to create a DataRecords
     *   }
     * })
     * 
     */
    create<T extends dataRecordsCreateArgs>(args: SelectSubset<T, dataRecordsCreateArgs<ExtArgs>>): Prisma__dataRecordsClient<$Result.GetResult<Prisma.$dataRecordsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataRecords.
     * @param {dataRecordsCreateManyArgs} args - Arguments to create many DataRecords.
     * @example
     * // Create many DataRecords
     * const dataRecords = await prisma.dataRecords.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dataRecordsCreateManyArgs>(args?: SelectSubset<T, dataRecordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataRecords.
     * @param {dataRecordsDeleteArgs} args - Arguments to delete one DataRecords.
     * @example
     * // Delete one DataRecords
     * const DataRecords = await prisma.dataRecords.delete({
     *   where: {
     *     // ... filter to delete one DataRecords
     *   }
     * })
     * 
     */
    delete<T extends dataRecordsDeleteArgs>(args: SelectSubset<T, dataRecordsDeleteArgs<ExtArgs>>): Prisma__dataRecordsClient<$Result.GetResult<Prisma.$dataRecordsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataRecords.
     * @param {dataRecordsUpdateArgs} args - Arguments to update one DataRecords.
     * @example
     * // Update one DataRecords
     * const dataRecords = await prisma.dataRecords.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dataRecordsUpdateArgs>(args: SelectSubset<T, dataRecordsUpdateArgs<ExtArgs>>): Prisma__dataRecordsClient<$Result.GetResult<Prisma.$dataRecordsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataRecords.
     * @param {dataRecordsDeleteManyArgs} args - Arguments to filter DataRecords to delete.
     * @example
     * // Delete a few DataRecords
     * const { count } = await prisma.dataRecords.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dataRecordsDeleteManyArgs>(args?: SelectSubset<T, dataRecordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataRecords
     * const dataRecords = await prisma.dataRecords.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dataRecordsUpdateManyArgs>(args: SelectSubset<T, dataRecordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataRecords.
     * @param {dataRecordsUpsertArgs} args - Arguments to update or create a DataRecords.
     * @example
     * // Update or create a DataRecords
     * const dataRecords = await prisma.dataRecords.upsert({
     *   create: {
     *     // ... data to create a DataRecords
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataRecords we want to update
     *   }
     * })
     */
    upsert<T extends dataRecordsUpsertArgs>(args: SelectSubset<T, dataRecordsUpsertArgs<ExtArgs>>): Prisma__dataRecordsClient<$Result.GetResult<Prisma.$dataRecordsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataRecords that matches the filter.
     * @param {dataRecordsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dataRecords = await prisma.dataRecords.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: dataRecordsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DataRecords.
     * @param {dataRecordsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dataRecords = await prisma.dataRecords.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: dataRecordsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DataRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsCountArgs} args - Arguments to filter DataRecords to count.
     * @example
     * // Count the number of DataRecords
     * const count = await prisma.dataRecords.count({
     *   where: {
     *     // ... the filter for the DataRecords we want to count
     *   }
     * })
    **/
    count<T extends dataRecordsCountArgs>(
      args?: Subset<T, dataRecordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataRecordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataRecordsAggregateArgs>(args: Subset<T, DataRecordsAggregateArgs>): Prisma.PrismaPromise<GetDataRecordsAggregateType<T>>

    /**
     * Group by DataRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dataRecordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dataRecordsGroupByArgs['orderBy'] }
        : { orderBy?: dataRecordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dataRecordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataRecordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dataRecords model
   */
  readonly fields: dataRecordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dataRecords.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dataRecordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dataRecords model
   */
  interface dataRecordsFieldRefs {
    readonly id: FieldRef<"dataRecords", 'String'>
    readonly CRDC_ID: FieldRef<"dataRecords", 'String'>
    readonly IDPropName: FieldRef<"dataRecords", 'String'>
    readonly batchIDs: FieldRef<"dataRecords", 'String[]'>
    readonly createdAt: FieldRef<"dataRecords", 'DateTime'>
    readonly dataCommons: FieldRef<"dataRecords", 'String'>
    readonly entityType: FieldRef<"dataRecords", 'String'>
    readonly latestBatchDisplayID: FieldRef<"dataRecords", 'Int'>
    readonly latestBatchID: FieldRef<"dataRecords", 'String'>
    readonly lineNumber: FieldRef<"dataRecords", 'Int'>
    readonly nodeID: FieldRef<"dataRecords", 'String'>
    readonly nodeType: FieldRef<"dataRecords", 'String'>
    readonly orginalFileName: FieldRef<"dataRecords", 'String'>
    readonly props: FieldRef<"dataRecords", 'Json'>
    readonly qcResultID: FieldRef<"dataRecords", 'String'>
    readonly rawData: FieldRef<"dataRecords", 'Json'>
    readonly status: FieldRef<"dataRecords", 'String'>
    readonly studyID: FieldRef<"dataRecords", 'String'>
    readonly submissionID: FieldRef<"dataRecords", 'String'>
    readonly updatedAt: FieldRef<"dataRecords", 'DateTime'>
    readonly uploadedDate: FieldRef<"dataRecords", 'DateTime'>
    readonly validatedAt: FieldRef<"dataRecords", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * dataRecords findUnique
   */
  export type dataRecordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecords
     */
    select?: dataRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecords
     */
    omit?: dataRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsInclude<ExtArgs> | null
    /**
     * Filter, which dataRecords to fetch.
     */
    where: dataRecordsWhereUniqueInput
  }

  /**
   * dataRecords findUniqueOrThrow
   */
  export type dataRecordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecords
     */
    select?: dataRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecords
     */
    omit?: dataRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsInclude<ExtArgs> | null
    /**
     * Filter, which dataRecords to fetch.
     */
    where: dataRecordsWhereUniqueInput
  }

  /**
   * dataRecords findFirst
   */
  export type dataRecordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecords
     */
    select?: dataRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecords
     */
    omit?: dataRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsInclude<ExtArgs> | null
    /**
     * Filter, which dataRecords to fetch.
     */
    where?: dataRecordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dataRecords to fetch.
     */
    orderBy?: dataRecordsOrderByWithRelationInput | dataRecordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dataRecords.
     */
    cursor?: dataRecordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dataRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dataRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dataRecords.
     */
    distinct?: DataRecordsScalarFieldEnum | DataRecordsScalarFieldEnum[]
  }

  /**
   * dataRecords findFirstOrThrow
   */
  export type dataRecordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecords
     */
    select?: dataRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecords
     */
    omit?: dataRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsInclude<ExtArgs> | null
    /**
     * Filter, which dataRecords to fetch.
     */
    where?: dataRecordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dataRecords to fetch.
     */
    orderBy?: dataRecordsOrderByWithRelationInput | dataRecordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dataRecords.
     */
    cursor?: dataRecordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dataRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dataRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dataRecords.
     */
    distinct?: DataRecordsScalarFieldEnum | DataRecordsScalarFieldEnum[]
  }

  /**
   * dataRecords findMany
   */
  export type dataRecordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecords
     */
    select?: dataRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecords
     */
    omit?: dataRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsInclude<ExtArgs> | null
    /**
     * Filter, which dataRecords to fetch.
     */
    where?: dataRecordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dataRecords to fetch.
     */
    orderBy?: dataRecordsOrderByWithRelationInput | dataRecordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dataRecords.
     */
    cursor?: dataRecordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dataRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dataRecords.
     */
    skip?: number
    distinct?: DataRecordsScalarFieldEnum | DataRecordsScalarFieldEnum[]
  }

  /**
   * dataRecords create
   */
  export type dataRecordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecords
     */
    select?: dataRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecords
     */
    omit?: dataRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsInclude<ExtArgs> | null
    /**
     * The data needed to create a dataRecords.
     */
    data: XOR<dataRecordsCreateInput, dataRecordsUncheckedCreateInput>
  }

  /**
   * dataRecords createMany
   */
  export type dataRecordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dataRecords.
     */
    data: dataRecordsCreateManyInput | dataRecordsCreateManyInput[]
  }

  /**
   * dataRecords update
   */
  export type dataRecordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecords
     */
    select?: dataRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecords
     */
    omit?: dataRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsInclude<ExtArgs> | null
    /**
     * The data needed to update a dataRecords.
     */
    data: XOR<dataRecordsUpdateInput, dataRecordsUncheckedUpdateInput>
    /**
     * Choose, which dataRecords to update.
     */
    where: dataRecordsWhereUniqueInput
  }

  /**
   * dataRecords updateMany
   */
  export type dataRecordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dataRecords.
     */
    data: XOR<dataRecordsUpdateManyMutationInput, dataRecordsUncheckedUpdateManyInput>
    /**
     * Filter which dataRecords to update
     */
    where?: dataRecordsWhereInput
    /**
     * Limit how many dataRecords to update.
     */
    limit?: number
  }

  /**
   * dataRecords upsert
   */
  export type dataRecordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecords
     */
    select?: dataRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecords
     */
    omit?: dataRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsInclude<ExtArgs> | null
    /**
     * The filter to search for the dataRecords to update in case it exists.
     */
    where: dataRecordsWhereUniqueInput
    /**
     * In case the dataRecords found by the `where` argument doesn't exist, create a new dataRecords with this data.
     */
    create: XOR<dataRecordsCreateInput, dataRecordsUncheckedCreateInput>
    /**
     * In case the dataRecords was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dataRecordsUpdateInput, dataRecordsUncheckedUpdateInput>
  }

  /**
   * dataRecords delete
   */
  export type dataRecordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecords
     */
    select?: dataRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecords
     */
    omit?: dataRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsInclude<ExtArgs> | null
    /**
     * Filter which dataRecords to delete.
     */
    where: dataRecordsWhereUniqueInput
  }

  /**
   * dataRecords deleteMany
   */
  export type dataRecordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dataRecords to delete
     */
    where?: dataRecordsWhereInput
    /**
     * Limit how many dataRecords to delete.
     */
    limit?: number
  }

  /**
   * dataRecords findRaw
   */
  export type dataRecordsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * dataRecords aggregateRaw
   */
  export type dataRecordsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * dataRecords without action
   */
  export type dataRecordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecords
     */
    select?: dataRecordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecords
     */
    omit?: dataRecordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsInclude<ExtArgs> | null
  }


  /**
   * Model dataRecordsArchived
   */

  export type AggregateDataRecordsArchived = {
    _count: DataRecordsArchivedCountAggregateOutputType | null
    _avg: DataRecordsArchivedAvgAggregateOutputType | null
    _sum: DataRecordsArchivedSumAggregateOutputType | null
    _min: DataRecordsArchivedMinAggregateOutputType | null
    _max: DataRecordsArchivedMaxAggregateOutputType | null
  }

  export type DataRecordsArchivedAvgAggregateOutputType = {
    latestBatchDisplayID: number | null
    lineNumber: number | null
  }

  export type DataRecordsArchivedSumAggregateOutputType = {
    latestBatchDisplayID: number | null
    lineNumber: number | null
  }

  export type DataRecordsArchivedMinAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    IDPropName: string | null
    createdAt: Date | null
    dataCommons: string | null
    entityType: string | null
    latestBatchDisplayID: number | null
    latestBatchID: string | null
    lineNumber: number | null
    nodeID: string | null
    nodeType: string | null
    orginalFileName: string | null
    qcResultID: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    updatedAt: Date | null
    uploadedDate: Date | null
    validatedAt: Date | null
  }

  export type DataRecordsArchivedMaxAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    IDPropName: string | null
    createdAt: Date | null
    dataCommons: string | null
    entityType: string | null
    latestBatchDisplayID: number | null
    latestBatchID: string | null
    lineNumber: number | null
    nodeID: string | null
    nodeType: string | null
    orginalFileName: string | null
    qcResultID: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    updatedAt: Date | null
    uploadedDate: Date | null
    validatedAt: Date | null
  }

  export type DataRecordsArchivedCountAggregateOutputType = {
    id: number
    CRDC_ID: number
    IDPropName: number
    batchIDs: number
    createdAt: number
    dataCommons: number
    entityType: number
    latestBatchDisplayID: number
    latestBatchID: number
    lineNumber: number
    nodeID: number
    nodeType: number
    orginalFileName: number
    props: number
    qcResultID: number
    rawData: number
    status: number
    studyID: number
    submissionID: number
    updatedAt: number
    uploadedDate: number
    validatedAt: number
    _all: number
  }


  export type DataRecordsArchivedAvgAggregateInputType = {
    latestBatchDisplayID?: true
    lineNumber?: true
  }

  export type DataRecordsArchivedSumAggregateInputType = {
    latestBatchDisplayID?: true
    lineNumber?: true
  }

  export type DataRecordsArchivedMinAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    createdAt?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    qcResultID?: true
    status?: true
    studyID?: true
    submissionID?: true
    updatedAt?: true
    uploadedDate?: true
    validatedAt?: true
  }

  export type DataRecordsArchivedMaxAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    createdAt?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    qcResultID?: true
    status?: true
    studyID?: true
    submissionID?: true
    updatedAt?: true
    uploadedDate?: true
    validatedAt?: true
  }

  export type DataRecordsArchivedCountAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    batchIDs?: true
    createdAt?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    props?: true
    qcResultID?: true
    rawData?: true
    status?: true
    studyID?: true
    submissionID?: true
    updatedAt?: true
    uploadedDate?: true
    validatedAt?: true
    _all?: true
  }

  export type DataRecordsArchivedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dataRecordsArchived to aggregate.
     */
    where?: dataRecordsArchivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dataRecordsArchiveds to fetch.
     */
    orderBy?: dataRecordsArchivedOrderByWithRelationInput | dataRecordsArchivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dataRecordsArchivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dataRecordsArchiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dataRecordsArchiveds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dataRecordsArchiveds
    **/
    _count?: true | DataRecordsArchivedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataRecordsArchivedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataRecordsArchivedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataRecordsArchivedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataRecordsArchivedMaxAggregateInputType
  }

  export type GetDataRecordsArchivedAggregateType<T extends DataRecordsArchivedAggregateArgs> = {
        [P in keyof T & keyof AggregateDataRecordsArchived]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataRecordsArchived[P]>
      : GetScalarType<T[P], AggregateDataRecordsArchived[P]>
  }




  export type dataRecordsArchivedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dataRecordsArchivedWhereInput
    orderBy?: dataRecordsArchivedOrderByWithAggregationInput | dataRecordsArchivedOrderByWithAggregationInput[]
    by: DataRecordsArchivedScalarFieldEnum[] | DataRecordsArchivedScalarFieldEnum
    having?: dataRecordsArchivedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataRecordsArchivedCountAggregateInputType | true
    _avg?: DataRecordsArchivedAvgAggregateInputType
    _sum?: DataRecordsArchivedSumAggregateInputType
    _min?: DataRecordsArchivedMinAggregateInputType
    _max?: DataRecordsArchivedMaxAggregateInputType
  }

  export type DataRecordsArchivedGroupByOutputType = {
    id: string
    CRDC_ID: string | null
    IDPropName: string
    batchIDs: string[]
    createdAt: Date
    dataCommons: string
    entityType: string | null
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    props: JsonValue
    qcResultID: string | null
    rawData: JsonValue
    status: string
    studyID: string | null
    submissionID: string
    updatedAt: Date
    uploadedDate: Date
    validatedAt: Date | null
    _count: DataRecordsArchivedCountAggregateOutputType | null
    _avg: DataRecordsArchivedAvgAggregateOutputType | null
    _sum: DataRecordsArchivedSumAggregateOutputType | null
    _min: DataRecordsArchivedMinAggregateOutputType | null
    _max: DataRecordsArchivedMaxAggregateOutputType | null
  }

  type GetDataRecordsArchivedGroupByPayload<T extends dataRecordsArchivedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataRecordsArchivedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataRecordsArchivedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataRecordsArchivedGroupByOutputType[P]>
            : GetScalarType<T[P], DataRecordsArchivedGroupByOutputType[P]>
        }
      >
    >


  export type dataRecordsArchivedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CRDC_ID?: boolean
    IDPropName?: boolean
    additionalErrors?: boolean | AdditionalErrorDefaultArgs<ExtArgs>
    batchIDs?: boolean
    createdAt?: boolean
    dataCommons?: boolean
    entityType?: boolean
    errors?: boolean | ErrorDefaultArgs<ExtArgs>
    latestBatchDisplayID?: boolean
    latestBatchID?: boolean
    lineNumber?: boolean
    nodeID?: boolean
    nodeType?: boolean
    orginalFileName?: boolean
    parents?: boolean | ParentDefaultArgs<ExtArgs>
    props?: boolean
    qcResultID?: boolean
    rawData?: boolean
    s3FileInfo?: boolean | S3FileInfoDefaultArgs<ExtArgs>
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    updatedAt?: boolean
    uploadedDate?: boolean
    validatedAt?: boolean
    warnings?: boolean | ErrorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataRecordsArchived"]>



  export type dataRecordsArchivedSelectScalar = {
    id?: boolean
    CRDC_ID?: boolean
    IDPropName?: boolean
    batchIDs?: boolean
    createdAt?: boolean
    dataCommons?: boolean
    entityType?: boolean
    latestBatchDisplayID?: boolean
    latestBatchID?: boolean
    lineNumber?: boolean
    nodeID?: boolean
    nodeType?: boolean
    orginalFileName?: boolean
    props?: boolean
    qcResultID?: boolean
    rawData?: boolean
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    updatedAt?: boolean
    uploadedDate?: boolean
    validatedAt?: boolean
  }

  export type dataRecordsArchivedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "CRDC_ID" | "IDPropName" | "additionalErrors" | "batchIDs" | "createdAt" | "dataCommons" | "entityType" | "errors" | "latestBatchDisplayID" | "latestBatchID" | "lineNumber" | "nodeID" | "nodeType" | "orginalFileName" | "parents" | "props" | "qcResultID" | "rawData" | "s3FileInfo" | "status" | "studyID" | "submissionID" | "updatedAt" | "uploadedDate" | "validatedAt" | "warnings", ExtArgs["result"]["dataRecordsArchived"]>
  export type dataRecordsArchivedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $dataRecordsArchivedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dataRecordsArchived"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      CRDC_ID: string | null
      IDPropName: string
      batchIDs: string[]
      createdAt: Date
      dataCommons: string
      entityType: string | null
      latestBatchDisplayID: number
      latestBatchID: string
      lineNumber: number
      nodeID: string
      nodeType: string
      orginalFileName: string
      props: Prisma.JsonValue
      qcResultID: string | null
      rawData: Prisma.JsonValue
      status: string
      studyID: string | null
      submissionID: string
      updatedAt: Date
      uploadedDate: Date
      validatedAt: Date | null
    }, ExtArgs["result"]["dataRecordsArchived"]>
    composites: {
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      additionalErrors: Prisma.$AdditionalErrorPayload[]
      errors: Prisma.$ErrorPayload[]
      parents: Prisma.$ParentPayload[]
      s3FileInfo: Prisma.$S3FileInfoPayload | null
      warnings: Prisma.$ErrorPayload[]
    }
  }

  type dataRecordsArchivedGetPayload<S extends boolean | null | undefined | dataRecordsArchivedDefaultArgs> = $Result.GetResult<Prisma.$dataRecordsArchivedPayload, S>

  type dataRecordsArchivedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<dataRecordsArchivedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataRecordsArchivedCountAggregateInputType | true
    }

  export interface dataRecordsArchivedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dataRecordsArchived'], meta: { name: 'dataRecordsArchived' } }
    /**
     * Find zero or one DataRecordsArchived that matches the filter.
     * @param {dataRecordsArchivedFindUniqueArgs} args - Arguments to find a DataRecordsArchived
     * @example
     * // Get one DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dataRecordsArchivedFindUniqueArgs>(args: SelectSubset<T, dataRecordsArchivedFindUniqueArgs<ExtArgs>>): Prisma__dataRecordsArchivedClient<$Result.GetResult<Prisma.$dataRecordsArchivedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataRecordsArchived that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {dataRecordsArchivedFindUniqueOrThrowArgs} args - Arguments to find a DataRecordsArchived
     * @example
     * // Get one DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dataRecordsArchivedFindUniqueOrThrowArgs>(args: SelectSubset<T, dataRecordsArchivedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dataRecordsArchivedClient<$Result.GetResult<Prisma.$dataRecordsArchivedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRecordsArchived that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsArchivedFindFirstArgs} args - Arguments to find a DataRecordsArchived
     * @example
     * // Get one DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dataRecordsArchivedFindFirstArgs>(args?: SelectSubset<T, dataRecordsArchivedFindFirstArgs<ExtArgs>>): Prisma__dataRecordsArchivedClient<$Result.GetResult<Prisma.$dataRecordsArchivedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRecordsArchived that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsArchivedFindFirstOrThrowArgs} args - Arguments to find a DataRecordsArchived
     * @example
     * // Get one DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dataRecordsArchivedFindFirstOrThrowArgs>(args?: SelectSubset<T, dataRecordsArchivedFindFirstOrThrowArgs<ExtArgs>>): Prisma__dataRecordsArchivedClient<$Result.GetResult<Prisma.$dataRecordsArchivedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataRecordsArchiveds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsArchivedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataRecordsArchiveds
     * const dataRecordsArchiveds = await prisma.dataRecordsArchived.findMany()
     * 
     * // Get first 10 DataRecordsArchiveds
     * const dataRecordsArchiveds = await prisma.dataRecordsArchived.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataRecordsArchivedWithIdOnly = await prisma.dataRecordsArchived.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dataRecordsArchivedFindManyArgs>(args?: SelectSubset<T, dataRecordsArchivedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dataRecordsArchivedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataRecordsArchived.
     * @param {dataRecordsArchivedCreateArgs} args - Arguments to create a DataRecordsArchived.
     * @example
     * // Create one DataRecordsArchived
     * const DataRecordsArchived = await prisma.dataRecordsArchived.create({
     *   data: {
     *     // ... data to create a DataRecordsArchived
     *   }
     * })
     * 
     */
    create<T extends dataRecordsArchivedCreateArgs>(args: SelectSubset<T, dataRecordsArchivedCreateArgs<ExtArgs>>): Prisma__dataRecordsArchivedClient<$Result.GetResult<Prisma.$dataRecordsArchivedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataRecordsArchiveds.
     * @param {dataRecordsArchivedCreateManyArgs} args - Arguments to create many DataRecordsArchiveds.
     * @example
     * // Create many DataRecordsArchiveds
     * const dataRecordsArchived = await prisma.dataRecordsArchived.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dataRecordsArchivedCreateManyArgs>(args?: SelectSubset<T, dataRecordsArchivedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataRecordsArchived.
     * @param {dataRecordsArchivedDeleteArgs} args - Arguments to delete one DataRecordsArchived.
     * @example
     * // Delete one DataRecordsArchived
     * const DataRecordsArchived = await prisma.dataRecordsArchived.delete({
     *   where: {
     *     // ... filter to delete one DataRecordsArchived
     *   }
     * })
     * 
     */
    delete<T extends dataRecordsArchivedDeleteArgs>(args: SelectSubset<T, dataRecordsArchivedDeleteArgs<ExtArgs>>): Prisma__dataRecordsArchivedClient<$Result.GetResult<Prisma.$dataRecordsArchivedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataRecordsArchived.
     * @param {dataRecordsArchivedUpdateArgs} args - Arguments to update one DataRecordsArchived.
     * @example
     * // Update one DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dataRecordsArchivedUpdateArgs>(args: SelectSubset<T, dataRecordsArchivedUpdateArgs<ExtArgs>>): Prisma__dataRecordsArchivedClient<$Result.GetResult<Prisma.$dataRecordsArchivedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataRecordsArchiveds.
     * @param {dataRecordsArchivedDeleteManyArgs} args - Arguments to filter DataRecordsArchiveds to delete.
     * @example
     * // Delete a few DataRecordsArchiveds
     * const { count } = await prisma.dataRecordsArchived.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dataRecordsArchivedDeleteManyArgs>(args?: SelectSubset<T, dataRecordsArchivedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRecordsArchiveds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsArchivedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataRecordsArchiveds
     * const dataRecordsArchived = await prisma.dataRecordsArchived.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dataRecordsArchivedUpdateManyArgs>(args: SelectSubset<T, dataRecordsArchivedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataRecordsArchived.
     * @param {dataRecordsArchivedUpsertArgs} args - Arguments to update or create a DataRecordsArchived.
     * @example
     * // Update or create a DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.upsert({
     *   create: {
     *     // ... data to create a DataRecordsArchived
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataRecordsArchived we want to update
     *   }
     * })
     */
    upsert<T extends dataRecordsArchivedUpsertArgs>(args: SelectSubset<T, dataRecordsArchivedUpsertArgs<ExtArgs>>): Prisma__dataRecordsArchivedClient<$Result.GetResult<Prisma.$dataRecordsArchivedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataRecordsArchiveds that matches the filter.
     * @param {dataRecordsArchivedFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dataRecordsArchived = await prisma.dataRecordsArchived.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: dataRecordsArchivedFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DataRecordsArchived.
     * @param {dataRecordsArchivedAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dataRecordsArchived = await prisma.dataRecordsArchived.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: dataRecordsArchivedAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DataRecordsArchiveds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsArchivedCountArgs} args - Arguments to filter DataRecordsArchiveds to count.
     * @example
     * // Count the number of DataRecordsArchiveds
     * const count = await prisma.dataRecordsArchived.count({
     *   where: {
     *     // ... the filter for the DataRecordsArchiveds we want to count
     *   }
     * })
    **/
    count<T extends dataRecordsArchivedCountArgs>(
      args?: Subset<T, dataRecordsArchivedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataRecordsArchivedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataRecordsArchived.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordsArchivedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataRecordsArchivedAggregateArgs>(args: Subset<T, DataRecordsArchivedAggregateArgs>): Prisma.PrismaPromise<GetDataRecordsArchivedAggregateType<T>>

    /**
     * Group by DataRecordsArchived.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dataRecordsArchivedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dataRecordsArchivedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dataRecordsArchivedGroupByArgs['orderBy'] }
        : { orderBy?: dataRecordsArchivedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dataRecordsArchivedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataRecordsArchivedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dataRecordsArchived model
   */
  readonly fields: dataRecordsArchivedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dataRecordsArchived.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dataRecordsArchivedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dataRecordsArchived model
   */
  interface dataRecordsArchivedFieldRefs {
    readonly id: FieldRef<"dataRecordsArchived", 'String'>
    readonly CRDC_ID: FieldRef<"dataRecordsArchived", 'String'>
    readonly IDPropName: FieldRef<"dataRecordsArchived", 'String'>
    readonly batchIDs: FieldRef<"dataRecordsArchived", 'String[]'>
    readonly createdAt: FieldRef<"dataRecordsArchived", 'DateTime'>
    readonly dataCommons: FieldRef<"dataRecordsArchived", 'String'>
    readonly entityType: FieldRef<"dataRecordsArchived", 'String'>
    readonly latestBatchDisplayID: FieldRef<"dataRecordsArchived", 'Int'>
    readonly latestBatchID: FieldRef<"dataRecordsArchived", 'String'>
    readonly lineNumber: FieldRef<"dataRecordsArchived", 'Int'>
    readonly nodeID: FieldRef<"dataRecordsArchived", 'String'>
    readonly nodeType: FieldRef<"dataRecordsArchived", 'String'>
    readonly orginalFileName: FieldRef<"dataRecordsArchived", 'String'>
    readonly props: FieldRef<"dataRecordsArchived", 'Json'>
    readonly qcResultID: FieldRef<"dataRecordsArchived", 'String'>
    readonly rawData: FieldRef<"dataRecordsArchived", 'Json'>
    readonly status: FieldRef<"dataRecordsArchived", 'String'>
    readonly studyID: FieldRef<"dataRecordsArchived", 'String'>
    readonly submissionID: FieldRef<"dataRecordsArchived", 'String'>
    readonly updatedAt: FieldRef<"dataRecordsArchived", 'DateTime'>
    readonly uploadedDate: FieldRef<"dataRecordsArchived", 'DateTime'>
    readonly validatedAt: FieldRef<"dataRecordsArchived", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * dataRecordsArchived findUnique
   */
  export type dataRecordsArchivedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecordsArchived
     */
    select?: dataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecordsArchived
     */
    omit?: dataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter, which dataRecordsArchived to fetch.
     */
    where: dataRecordsArchivedWhereUniqueInput
  }

  /**
   * dataRecordsArchived findUniqueOrThrow
   */
  export type dataRecordsArchivedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecordsArchived
     */
    select?: dataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecordsArchived
     */
    omit?: dataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter, which dataRecordsArchived to fetch.
     */
    where: dataRecordsArchivedWhereUniqueInput
  }

  /**
   * dataRecordsArchived findFirst
   */
  export type dataRecordsArchivedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecordsArchived
     */
    select?: dataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecordsArchived
     */
    omit?: dataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter, which dataRecordsArchived to fetch.
     */
    where?: dataRecordsArchivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dataRecordsArchiveds to fetch.
     */
    orderBy?: dataRecordsArchivedOrderByWithRelationInput | dataRecordsArchivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dataRecordsArchiveds.
     */
    cursor?: dataRecordsArchivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dataRecordsArchiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dataRecordsArchiveds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dataRecordsArchiveds.
     */
    distinct?: DataRecordsArchivedScalarFieldEnum | DataRecordsArchivedScalarFieldEnum[]
  }

  /**
   * dataRecordsArchived findFirstOrThrow
   */
  export type dataRecordsArchivedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecordsArchived
     */
    select?: dataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecordsArchived
     */
    omit?: dataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter, which dataRecordsArchived to fetch.
     */
    where?: dataRecordsArchivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dataRecordsArchiveds to fetch.
     */
    orderBy?: dataRecordsArchivedOrderByWithRelationInput | dataRecordsArchivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dataRecordsArchiveds.
     */
    cursor?: dataRecordsArchivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dataRecordsArchiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dataRecordsArchiveds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dataRecordsArchiveds.
     */
    distinct?: DataRecordsArchivedScalarFieldEnum | DataRecordsArchivedScalarFieldEnum[]
  }

  /**
   * dataRecordsArchived findMany
   */
  export type dataRecordsArchivedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecordsArchived
     */
    select?: dataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecordsArchived
     */
    omit?: dataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter, which dataRecordsArchiveds to fetch.
     */
    where?: dataRecordsArchivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dataRecordsArchiveds to fetch.
     */
    orderBy?: dataRecordsArchivedOrderByWithRelationInput | dataRecordsArchivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dataRecordsArchiveds.
     */
    cursor?: dataRecordsArchivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dataRecordsArchiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dataRecordsArchiveds.
     */
    skip?: number
    distinct?: DataRecordsArchivedScalarFieldEnum | DataRecordsArchivedScalarFieldEnum[]
  }

  /**
   * dataRecordsArchived create
   */
  export type dataRecordsArchivedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecordsArchived
     */
    select?: dataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecordsArchived
     */
    omit?: dataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsArchivedInclude<ExtArgs> | null
    /**
     * The data needed to create a dataRecordsArchived.
     */
    data: XOR<dataRecordsArchivedCreateInput, dataRecordsArchivedUncheckedCreateInput>
  }

  /**
   * dataRecordsArchived createMany
   */
  export type dataRecordsArchivedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dataRecordsArchiveds.
     */
    data: dataRecordsArchivedCreateManyInput | dataRecordsArchivedCreateManyInput[]
  }

  /**
   * dataRecordsArchived update
   */
  export type dataRecordsArchivedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecordsArchived
     */
    select?: dataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecordsArchived
     */
    omit?: dataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsArchivedInclude<ExtArgs> | null
    /**
     * The data needed to update a dataRecordsArchived.
     */
    data: XOR<dataRecordsArchivedUpdateInput, dataRecordsArchivedUncheckedUpdateInput>
    /**
     * Choose, which dataRecordsArchived to update.
     */
    where: dataRecordsArchivedWhereUniqueInput
  }

  /**
   * dataRecordsArchived updateMany
   */
  export type dataRecordsArchivedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dataRecordsArchiveds.
     */
    data: XOR<dataRecordsArchivedUpdateManyMutationInput, dataRecordsArchivedUncheckedUpdateManyInput>
    /**
     * Filter which dataRecordsArchiveds to update
     */
    where?: dataRecordsArchivedWhereInput
    /**
     * Limit how many dataRecordsArchiveds to update.
     */
    limit?: number
  }

  /**
   * dataRecordsArchived upsert
   */
  export type dataRecordsArchivedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecordsArchived
     */
    select?: dataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecordsArchived
     */
    omit?: dataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsArchivedInclude<ExtArgs> | null
    /**
     * The filter to search for the dataRecordsArchived to update in case it exists.
     */
    where: dataRecordsArchivedWhereUniqueInput
    /**
     * In case the dataRecordsArchived found by the `where` argument doesn't exist, create a new dataRecordsArchived with this data.
     */
    create: XOR<dataRecordsArchivedCreateInput, dataRecordsArchivedUncheckedCreateInput>
    /**
     * In case the dataRecordsArchived was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dataRecordsArchivedUpdateInput, dataRecordsArchivedUncheckedUpdateInput>
  }

  /**
   * dataRecordsArchived delete
   */
  export type dataRecordsArchivedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecordsArchived
     */
    select?: dataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecordsArchived
     */
    omit?: dataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter which dataRecordsArchived to delete.
     */
    where: dataRecordsArchivedWhereUniqueInput
  }

  /**
   * dataRecordsArchived deleteMany
   */
  export type dataRecordsArchivedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dataRecordsArchiveds to delete
     */
    where?: dataRecordsArchivedWhereInput
    /**
     * Limit how many dataRecordsArchiveds to delete.
     */
    limit?: number
  }

  /**
   * dataRecordsArchived findRaw
   */
  export type dataRecordsArchivedFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * dataRecordsArchived aggregateRaw
   */
  export type dataRecordsArchivedAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * dataRecordsArchived without action
   */
  export type dataRecordsArchivedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dataRecordsArchived
     */
    select?: dataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dataRecordsArchived
     */
    omit?: dataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dataRecordsArchivedInclude<ExtArgs> | null
  }


  /**
   * Model fileMD5
   */

  export type AggregateFileMD5 = {
    _count: FileMD5CountAggregateOutputType | null
    _min: FileMD5MinAggregateOutputType | null
    _max: FileMD5MaxAggregateOutputType | null
  }

  export type FileMD5MinAggregateOutputType = {
    id: string | null
    LastModified: Date | null
    createdAt: Date | null
    fileName: string | null
    md5: string | null
    submissionID: string | null
    updatedAt: Date | null
  }

  export type FileMD5MaxAggregateOutputType = {
    id: string | null
    LastModified: Date | null
    createdAt: Date | null
    fileName: string | null
    md5: string | null
    submissionID: string | null
    updatedAt: Date | null
  }

  export type FileMD5CountAggregateOutputType = {
    id: number
    LastModified: number
    createdAt: number
    fileName: number
    md5: number
    submissionID: number
    updatedAt: number
    _all: number
  }


  export type FileMD5MinAggregateInputType = {
    id?: true
    LastModified?: true
    createdAt?: true
    fileName?: true
    md5?: true
    submissionID?: true
    updatedAt?: true
  }

  export type FileMD5MaxAggregateInputType = {
    id?: true
    LastModified?: true
    createdAt?: true
    fileName?: true
    md5?: true
    submissionID?: true
    updatedAt?: true
  }

  export type FileMD5CountAggregateInputType = {
    id?: true
    LastModified?: true
    createdAt?: true
    fileName?: true
    md5?: true
    submissionID?: true
    updatedAt?: true
    _all?: true
  }

  export type FileMD5AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fileMD5 to aggregate.
     */
    where?: fileMD5WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fileMD5s to fetch.
     */
    orderBy?: fileMD5OrderByWithRelationInput | fileMD5OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fileMD5WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fileMD5s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fileMD5s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fileMD5s
    **/
    _count?: true | FileMD5CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMD5MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMD5MaxAggregateInputType
  }

  export type GetFileMD5AggregateType<T extends FileMD5AggregateArgs> = {
        [P in keyof T & keyof AggregateFileMD5]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileMD5[P]>
      : GetScalarType<T[P], AggregateFileMD5[P]>
  }




  export type fileMD5GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fileMD5WhereInput
    orderBy?: fileMD5OrderByWithAggregationInput | fileMD5OrderByWithAggregationInput[]
    by: FileMD5ScalarFieldEnum[] | FileMD5ScalarFieldEnum
    having?: fileMD5ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileMD5CountAggregateInputType | true
    _min?: FileMD5MinAggregateInputType
    _max?: FileMD5MaxAggregateInputType
  }

  export type FileMD5GroupByOutputType = {
    id: string
    LastModified: Date
    createdAt: Date
    fileName: string
    md5: string
    submissionID: string
    updatedAt: Date
    _count: FileMD5CountAggregateOutputType | null
    _min: FileMD5MinAggregateOutputType | null
    _max: FileMD5MaxAggregateOutputType | null
  }

  type GetFileMD5GroupByPayload<T extends fileMD5GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileMD5GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileMD5GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileMD5GroupByOutputType[P]>
            : GetScalarType<T[P], FileMD5GroupByOutputType[P]>
        }
      >
    >


  export type fileMD5Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    LastModified?: boolean
    createdAt?: boolean
    fileName?: boolean
    md5?: boolean
    submissionID?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fileMD5"]>



  export type fileMD5SelectScalar = {
    id?: boolean
    LastModified?: boolean
    createdAt?: boolean
    fileName?: boolean
    md5?: boolean
    submissionID?: boolean
    updatedAt?: boolean
  }

  export type fileMD5Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "LastModified" | "createdAt" | "fileName" | "md5" | "submissionID" | "updatedAt", ExtArgs["result"]["fileMD5"]>

  export type $fileMD5Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fileMD5"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      LastModified: Date
      createdAt: Date
      fileName: string
      md5: string
      submissionID: string
      updatedAt: Date
    }, ExtArgs["result"]["fileMD5"]>
    composites: {}
  }

  type fileMD5GetPayload<S extends boolean | null | undefined | fileMD5DefaultArgs> = $Result.GetResult<Prisma.$fileMD5Payload, S>

  type fileMD5CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<fileMD5FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileMD5CountAggregateInputType | true
    }

  export interface fileMD5Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fileMD5'], meta: { name: 'fileMD5' } }
    /**
     * Find zero or one FileMD5 that matches the filter.
     * @param {fileMD5FindUniqueArgs} args - Arguments to find a FileMD5
     * @example
     * // Get one FileMD5
     * const fileMD5 = await prisma.fileMD5.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fileMD5FindUniqueArgs>(args: SelectSubset<T, fileMD5FindUniqueArgs<ExtArgs>>): Prisma__fileMD5Client<$Result.GetResult<Prisma.$fileMD5Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileMD5 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fileMD5FindUniqueOrThrowArgs} args - Arguments to find a FileMD5
     * @example
     * // Get one FileMD5
     * const fileMD5 = await prisma.fileMD5.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fileMD5FindUniqueOrThrowArgs>(args: SelectSubset<T, fileMD5FindUniqueOrThrowArgs<ExtArgs>>): Prisma__fileMD5Client<$Result.GetResult<Prisma.$fileMD5Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileMD5 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileMD5FindFirstArgs} args - Arguments to find a FileMD5
     * @example
     * // Get one FileMD5
     * const fileMD5 = await prisma.fileMD5.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fileMD5FindFirstArgs>(args?: SelectSubset<T, fileMD5FindFirstArgs<ExtArgs>>): Prisma__fileMD5Client<$Result.GetResult<Prisma.$fileMD5Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileMD5 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileMD5FindFirstOrThrowArgs} args - Arguments to find a FileMD5
     * @example
     * // Get one FileMD5
     * const fileMD5 = await prisma.fileMD5.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fileMD5FindFirstOrThrowArgs>(args?: SelectSubset<T, fileMD5FindFirstOrThrowArgs<ExtArgs>>): Prisma__fileMD5Client<$Result.GetResult<Prisma.$fileMD5Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileMD5s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileMD5FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileMD5s
     * const fileMD5s = await prisma.fileMD5.findMany()
     * 
     * // Get first 10 FileMD5s
     * const fileMD5s = await prisma.fileMD5.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileMD5WithIdOnly = await prisma.fileMD5.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends fileMD5FindManyArgs>(args?: SelectSubset<T, fileMD5FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fileMD5Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileMD5.
     * @param {fileMD5CreateArgs} args - Arguments to create a FileMD5.
     * @example
     * // Create one FileMD5
     * const FileMD5 = await prisma.fileMD5.create({
     *   data: {
     *     // ... data to create a FileMD5
     *   }
     * })
     * 
     */
    create<T extends fileMD5CreateArgs>(args: SelectSubset<T, fileMD5CreateArgs<ExtArgs>>): Prisma__fileMD5Client<$Result.GetResult<Prisma.$fileMD5Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileMD5s.
     * @param {fileMD5CreateManyArgs} args - Arguments to create many FileMD5s.
     * @example
     * // Create many FileMD5s
     * const fileMD5 = await prisma.fileMD5.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fileMD5CreateManyArgs>(args?: SelectSubset<T, fileMD5CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FileMD5.
     * @param {fileMD5DeleteArgs} args - Arguments to delete one FileMD5.
     * @example
     * // Delete one FileMD5
     * const FileMD5 = await prisma.fileMD5.delete({
     *   where: {
     *     // ... filter to delete one FileMD5
     *   }
     * })
     * 
     */
    delete<T extends fileMD5DeleteArgs>(args: SelectSubset<T, fileMD5DeleteArgs<ExtArgs>>): Prisma__fileMD5Client<$Result.GetResult<Prisma.$fileMD5Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileMD5.
     * @param {fileMD5UpdateArgs} args - Arguments to update one FileMD5.
     * @example
     * // Update one FileMD5
     * const fileMD5 = await prisma.fileMD5.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fileMD5UpdateArgs>(args: SelectSubset<T, fileMD5UpdateArgs<ExtArgs>>): Prisma__fileMD5Client<$Result.GetResult<Prisma.$fileMD5Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileMD5s.
     * @param {fileMD5DeleteManyArgs} args - Arguments to filter FileMD5s to delete.
     * @example
     * // Delete a few FileMD5s
     * const { count } = await prisma.fileMD5.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fileMD5DeleteManyArgs>(args?: SelectSubset<T, fileMD5DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileMD5s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileMD5UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileMD5s
     * const fileMD5 = await prisma.fileMD5.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fileMD5UpdateManyArgs>(args: SelectSubset<T, fileMD5UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FileMD5.
     * @param {fileMD5UpsertArgs} args - Arguments to update or create a FileMD5.
     * @example
     * // Update or create a FileMD5
     * const fileMD5 = await prisma.fileMD5.upsert({
     *   create: {
     *     // ... data to create a FileMD5
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileMD5 we want to update
     *   }
     * })
     */
    upsert<T extends fileMD5UpsertArgs>(args: SelectSubset<T, fileMD5UpsertArgs<ExtArgs>>): Prisma__fileMD5Client<$Result.GetResult<Prisma.$fileMD5Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileMD5s that matches the filter.
     * @param {fileMD5FindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fileMD5 = await prisma.fileMD5.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: fileMD5FindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FileMD5.
     * @param {fileMD5AggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fileMD5 = await prisma.fileMD5.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: fileMD5AggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FileMD5s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileMD5CountArgs} args - Arguments to filter FileMD5s to count.
     * @example
     * // Count the number of FileMD5s
     * const count = await prisma.fileMD5.count({
     *   where: {
     *     // ... the filter for the FileMD5s we want to count
     *   }
     * })
    **/
    count<T extends fileMD5CountArgs>(
      args?: Subset<T, fileMD5CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileMD5CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileMD5.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMD5AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileMD5AggregateArgs>(args: Subset<T, FileMD5AggregateArgs>): Prisma.PrismaPromise<GetFileMD5AggregateType<T>>

    /**
     * Group by FileMD5.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileMD5GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fileMD5GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fileMD5GroupByArgs['orderBy'] }
        : { orderBy?: fileMD5GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fileMD5GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileMD5GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fileMD5 model
   */
  readonly fields: fileMD5FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fileMD5.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fileMD5Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fileMD5 model
   */
  interface fileMD5FieldRefs {
    readonly id: FieldRef<"fileMD5", 'String'>
    readonly LastModified: FieldRef<"fileMD5", 'DateTime'>
    readonly createdAt: FieldRef<"fileMD5", 'DateTime'>
    readonly fileName: FieldRef<"fileMD5", 'String'>
    readonly md5: FieldRef<"fileMD5", 'String'>
    readonly submissionID: FieldRef<"fileMD5", 'String'>
    readonly updatedAt: FieldRef<"fileMD5", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * fileMD5 findUnique
   */
  export type fileMD5FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fileMD5
     */
    select?: fileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the fileMD5
     */
    omit?: fileMD5Omit<ExtArgs> | null
    /**
     * Filter, which fileMD5 to fetch.
     */
    where: fileMD5WhereUniqueInput
  }

  /**
   * fileMD5 findUniqueOrThrow
   */
  export type fileMD5FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fileMD5
     */
    select?: fileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the fileMD5
     */
    omit?: fileMD5Omit<ExtArgs> | null
    /**
     * Filter, which fileMD5 to fetch.
     */
    where: fileMD5WhereUniqueInput
  }

  /**
   * fileMD5 findFirst
   */
  export type fileMD5FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fileMD5
     */
    select?: fileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the fileMD5
     */
    omit?: fileMD5Omit<ExtArgs> | null
    /**
     * Filter, which fileMD5 to fetch.
     */
    where?: fileMD5WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fileMD5s to fetch.
     */
    orderBy?: fileMD5OrderByWithRelationInput | fileMD5OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fileMD5s.
     */
    cursor?: fileMD5WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fileMD5s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fileMD5s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fileMD5s.
     */
    distinct?: FileMD5ScalarFieldEnum | FileMD5ScalarFieldEnum[]
  }

  /**
   * fileMD5 findFirstOrThrow
   */
  export type fileMD5FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fileMD5
     */
    select?: fileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the fileMD5
     */
    omit?: fileMD5Omit<ExtArgs> | null
    /**
     * Filter, which fileMD5 to fetch.
     */
    where?: fileMD5WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fileMD5s to fetch.
     */
    orderBy?: fileMD5OrderByWithRelationInput | fileMD5OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fileMD5s.
     */
    cursor?: fileMD5WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fileMD5s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fileMD5s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fileMD5s.
     */
    distinct?: FileMD5ScalarFieldEnum | FileMD5ScalarFieldEnum[]
  }

  /**
   * fileMD5 findMany
   */
  export type fileMD5FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fileMD5
     */
    select?: fileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the fileMD5
     */
    omit?: fileMD5Omit<ExtArgs> | null
    /**
     * Filter, which fileMD5s to fetch.
     */
    where?: fileMD5WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fileMD5s to fetch.
     */
    orderBy?: fileMD5OrderByWithRelationInput | fileMD5OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fileMD5s.
     */
    cursor?: fileMD5WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fileMD5s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fileMD5s.
     */
    skip?: number
    distinct?: FileMD5ScalarFieldEnum | FileMD5ScalarFieldEnum[]
  }

  /**
   * fileMD5 create
   */
  export type fileMD5CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fileMD5
     */
    select?: fileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the fileMD5
     */
    omit?: fileMD5Omit<ExtArgs> | null
    /**
     * The data needed to create a fileMD5.
     */
    data: XOR<fileMD5CreateInput, fileMD5UncheckedCreateInput>
  }

  /**
   * fileMD5 createMany
   */
  export type fileMD5CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fileMD5s.
     */
    data: fileMD5CreateManyInput | fileMD5CreateManyInput[]
  }

  /**
   * fileMD5 update
   */
  export type fileMD5UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fileMD5
     */
    select?: fileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the fileMD5
     */
    omit?: fileMD5Omit<ExtArgs> | null
    /**
     * The data needed to update a fileMD5.
     */
    data: XOR<fileMD5UpdateInput, fileMD5UncheckedUpdateInput>
    /**
     * Choose, which fileMD5 to update.
     */
    where: fileMD5WhereUniqueInput
  }

  /**
   * fileMD5 updateMany
   */
  export type fileMD5UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fileMD5s.
     */
    data: XOR<fileMD5UpdateManyMutationInput, fileMD5UncheckedUpdateManyInput>
    /**
     * Filter which fileMD5s to update
     */
    where?: fileMD5WhereInput
    /**
     * Limit how many fileMD5s to update.
     */
    limit?: number
  }

  /**
   * fileMD5 upsert
   */
  export type fileMD5UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fileMD5
     */
    select?: fileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the fileMD5
     */
    omit?: fileMD5Omit<ExtArgs> | null
    /**
     * The filter to search for the fileMD5 to update in case it exists.
     */
    where: fileMD5WhereUniqueInput
    /**
     * In case the fileMD5 found by the `where` argument doesn't exist, create a new fileMD5 with this data.
     */
    create: XOR<fileMD5CreateInput, fileMD5UncheckedCreateInput>
    /**
     * In case the fileMD5 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fileMD5UpdateInput, fileMD5UncheckedUpdateInput>
  }

  /**
   * fileMD5 delete
   */
  export type fileMD5DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fileMD5
     */
    select?: fileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the fileMD5
     */
    omit?: fileMD5Omit<ExtArgs> | null
    /**
     * Filter which fileMD5 to delete.
     */
    where: fileMD5WhereUniqueInput
  }

  /**
   * fileMD5 deleteMany
   */
  export type fileMD5DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fileMD5s to delete
     */
    where?: fileMD5WhereInput
    /**
     * Limit how many fileMD5s to delete.
     */
    limit?: number
  }

  /**
   * fileMD5 findRaw
   */
  export type fileMD5FindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * fileMD5 aggregateRaw
   */
  export type fileMD5AggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * fileMD5 without action
   */
  export type fileMD5DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fileMD5
     */
    select?: fileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the fileMD5
     */
    omit?: fileMD5Omit<ExtArgs> | null
  }


  /**
   * Model institutions
   */

  export type AggregateInstitutions = {
    _count: InstitutionsCountAggregateOutputType | null
    _avg: InstitutionsAvgAggregateOutputType | null
    _sum: InstitutionsSumAggregateOutputType | null
    _min: InstitutionsMinAggregateOutputType | null
    _max: InstitutionsMaxAggregateOutputType | null
  }

  export type InstitutionsAvgAggregateOutputType = {
    submitterCount: number | null
  }

  export type InstitutionsSumAggregateOutputType = {
    submitterCount: number | null
  }

  export type InstitutionsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    name: string | null
    status: string | null
    submitterCount: number | null
    updatedAt: Date | null
  }

  export type InstitutionsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    name: string | null
    status: string | null
    submitterCount: number | null
    updatedAt: Date | null
  }

  export type InstitutionsCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    status: number
    submitterCount: number
    updatedAt: number
    _all: number
  }


  export type InstitutionsAvgAggregateInputType = {
    submitterCount?: true
  }

  export type InstitutionsSumAggregateInputType = {
    submitterCount?: true
  }

  export type InstitutionsMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    status?: true
    submitterCount?: true
    updatedAt?: true
  }

  export type InstitutionsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    status?: true
    submitterCount?: true
    updatedAt?: true
  }

  export type InstitutionsCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    status?: true
    submitterCount?: true
    updatedAt?: true
    _all?: true
  }

  export type InstitutionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which institutions to aggregate.
     */
    where?: institutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionsOrderByWithRelationInput | institutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: institutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned institutions
    **/
    _count?: true | InstitutionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstitutionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstitutionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionsMaxAggregateInputType
  }

  export type GetInstitutionsAggregateType<T extends InstitutionsAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitutions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitutions[P]>
      : GetScalarType<T[P], AggregateInstitutions[P]>
  }




  export type institutionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: institutionsWhereInput
    orderBy?: institutionsOrderByWithAggregationInput | institutionsOrderByWithAggregationInput[]
    by: InstitutionsScalarFieldEnum[] | InstitutionsScalarFieldEnum
    having?: institutionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionsCountAggregateInputType | true
    _avg?: InstitutionsAvgAggregateInputType
    _sum?: InstitutionsSumAggregateInputType
    _min?: InstitutionsMinAggregateInputType
    _max?: InstitutionsMaxAggregateInputType
  }

  export type InstitutionsGroupByOutputType = {
    id: string
    createdAt: Date | null
    name: string
    status: string
    submitterCount: number | null
    updatedAt: Date | null
    _count: InstitutionsCountAggregateOutputType | null
    _avg: InstitutionsAvgAggregateOutputType | null
    _sum: InstitutionsSumAggregateOutputType | null
    _min: InstitutionsMinAggregateOutputType | null
    _max: InstitutionsMaxAggregateOutputType | null
  }

  type GetInstitutionsGroupByPayload<T extends institutionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionsGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionsGroupByOutputType[P]>
        }
      >
    >


  export type institutionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    status?: boolean
    submitterCount?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["institutions"]>



  export type institutionsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    status?: boolean
    submitterCount?: boolean
    updatedAt?: boolean
  }

  export type institutionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "status" | "submitterCount" | "updatedAt", ExtArgs["result"]["institutions"]>

  export type $institutionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "institutions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date | null
      name: string
      status: string
      submitterCount: number | null
      updatedAt: Date | null
    }, ExtArgs["result"]["institutions"]>
    composites: {}
  }

  type institutionsGetPayload<S extends boolean | null | undefined | institutionsDefaultArgs> = $Result.GetResult<Prisma.$institutionsPayload, S>

  type institutionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<institutionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstitutionsCountAggregateInputType | true
    }

  export interface institutionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['institutions'], meta: { name: 'institutions' } }
    /**
     * Find zero or one Institutions that matches the filter.
     * @param {institutionsFindUniqueArgs} args - Arguments to find a Institutions
     * @example
     * // Get one Institutions
     * const institutions = await prisma.institutions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends institutionsFindUniqueArgs>(args: SelectSubset<T, institutionsFindUniqueArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institutions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {institutionsFindUniqueOrThrowArgs} args - Arguments to find a Institutions
     * @example
     * // Get one Institutions
     * const institutions = await prisma.institutions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends institutionsFindUniqueOrThrowArgs>(args: SelectSubset<T, institutionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsFindFirstArgs} args - Arguments to find a Institutions
     * @example
     * // Get one Institutions
     * const institutions = await prisma.institutions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends institutionsFindFirstArgs>(args?: SelectSubset<T, institutionsFindFirstArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institutions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsFindFirstOrThrowArgs} args - Arguments to find a Institutions
     * @example
     * // Get one Institutions
     * const institutions = await prisma.institutions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends institutionsFindFirstOrThrowArgs>(args?: SelectSubset<T, institutionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutions
     * const institutions = await prisma.institutions.findMany()
     * 
     * // Get first 10 Institutions
     * const institutions = await prisma.institutions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionsWithIdOnly = await prisma.institutions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends institutionsFindManyArgs>(args?: SelectSubset<T, institutionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institutions.
     * @param {institutionsCreateArgs} args - Arguments to create a Institutions.
     * @example
     * // Create one Institutions
     * const Institutions = await prisma.institutions.create({
     *   data: {
     *     // ... data to create a Institutions
     *   }
     * })
     * 
     */
    create<T extends institutionsCreateArgs>(args: SelectSubset<T, institutionsCreateArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institutions.
     * @param {institutionsCreateManyArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institutions = await prisma.institutions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends institutionsCreateManyArgs>(args?: SelectSubset<T, institutionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Institutions.
     * @param {institutionsDeleteArgs} args - Arguments to delete one Institutions.
     * @example
     * // Delete one Institutions
     * const Institutions = await prisma.institutions.delete({
     *   where: {
     *     // ... filter to delete one Institutions
     *   }
     * })
     * 
     */
    delete<T extends institutionsDeleteArgs>(args: SelectSubset<T, institutionsDeleteArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institutions.
     * @param {institutionsUpdateArgs} args - Arguments to update one Institutions.
     * @example
     * // Update one Institutions
     * const institutions = await prisma.institutions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends institutionsUpdateArgs>(args: SelectSubset<T, institutionsUpdateArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institutions.
     * @param {institutionsDeleteManyArgs} args - Arguments to filter Institutions to delete.
     * @example
     * // Delete a few Institutions
     * const { count } = await prisma.institutions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends institutionsDeleteManyArgs>(args?: SelectSubset<T, institutionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutions
     * const institutions = await prisma.institutions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends institutionsUpdateManyArgs>(args: SelectSubset<T, institutionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Institutions.
     * @param {institutionsUpsertArgs} args - Arguments to update or create a Institutions.
     * @example
     * // Update or create a Institutions
     * const institutions = await prisma.institutions.upsert({
     *   create: {
     *     // ... data to create a Institutions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institutions we want to update
     *   }
     * })
     */
    upsert<T extends institutionsUpsertArgs>(args: SelectSubset<T, institutionsUpsertArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutions that matches the filter.
     * @param {institutionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const institutions = await prisma.institutions.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: institutionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Institutions.
     * @param {institutionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const institutions = await prisma.institutions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: institutionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsCountArgs} args - Arguments to filter Institutions to count.
     * @example
     * // Count the number of Institutions
     * const count = await prisma.institutions.count({
     *   where: {
     *     // ... the filter for the Institutions we want to count
     *   }
     * })
    **/
    count<T extends institutionsCountArgs>(
      args?: Subset<T, institutionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionsAggregateArgs>(args: Subset<T, InstitutionsAggregateArgs>): Prisma.PrismaPromise<GetInstitutionsAggregateType<T>>

    /**
     * Group by Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends institutionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: institutionsGroupByArgs['orderBy'] }
        : { orderBy?: institutionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, institutionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the institutions model
   */
  readonly fields: institutionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for institutions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__institutionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the institutions model
   */
  interface institutionsFieldRefs {
    readonly id: FieldRef<"institutions", 'String'>
    readonly createdAt: FieldRef<"institutions", 'DateTime'>
    readonly name: FieldRef<"institutions", 'String'>
    readonly status: FieldRef<"institutions", 'String'>
    readonly submitterCount: FieldRef<"institutions", 'Int'>
    readonly updatedAt: FieldRef<"institutions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * institutions findUnique
   */
  export type institutionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institutions
     */
    omit?: institutionsOmit<ExtArgs> | null
    /**
     * Filter, which institutions to fetch.
     */
    where: institutionsWhereUniqueInput
  }

  /**
   * institutions findUniqueOrThrow
   */
  export type institutionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institutions
     */
    omit?: institutionsOmit<ExtArgs> | null
    /**
     * Filter, which institutions to fetch.
     */
    where: institutionsWhereUniqueInput
  }

  /**
   * institutions findFirst
   */
  export type institutionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institutions
     */
    omit?: institutionsOmit<ExtArgs> | null
    /**
     * Filter, which institutions to fetch.
     */
    where?: institutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionsOrderByWithRelationInput | institutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institutions.
     */
    cursor?: institutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institutions.
     */
    distinct?: InstitutionsScalarFieldEnum | InstitutionsScalarFieldEnum[]
  }

  /**
   * institutions findFirstOrThrow
   */
  export type institutionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institutions
     */
    omit?: institutionsOmit<ExtArgs> | null
    /**
     * Filter, which institutions to fetch.
     */
    where?: institutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionsOrderByWithRelationInput | institutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institutions.
     */
    cursor?: institutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institutions.
     */
    distinct?: InstitutionsScalarFieldEnum | InstitutionsScalarFieldEnum[]
  }

  /**
   * institutions findMany
   */
  export type institutionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institutions
     */
    omit?: institutionsOmit<ExtArgs> | null
    /**
     * Filter, which institutions to fetch.
     */
    where?: institutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionsOrderByWithRelationInput | institutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing institutions.
     */
    cursor?: institutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    distinct?: InstitutionsScalarFieldEnum | InstitutionsScalarFieldEnum[]
  }

  /**
   * institutions create
   */
  export type institutionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institutions
     */
    omit?: institutionsOmit<ExtArgs> | null
    /**
     * The data needed to create a institutions.
     */
    data: XOR<institutionsCreateInput, institutionsUncheckedCreateInput>
  }

  /**
   * institutions createMany
   */
  export type institutionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many institutions.
     */
    data: institutionsCreateManyInput | institutionsCreateManyInput[]
  }

  /**
   * institutions update
   */
  export type institutionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institutions
     */
    omit?: institutionsOmit<ExtArgs> | null
    /**
     * The data needed to update a institutions.
     */
    data: XOR<institutionsUpdateInput, institutionsUncheckedUpdateInput>
    /**
     * Choose, which institutions to update.
     */
    where: institutionsWhereUniqueInput
  }

  /**
   * institutions updateMany
   */
  export type institutionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update institutions.
     */
    data: XOR<institutionsUpdateManyMutationInput, institutionsUncheckedUpdateManyInput>
    /**
     * Filter which institutions to update
     */
    where?: institutionsWhereInput
    /**
     * Limit how many institutions to update.
     */
    limit?: number
  }

  /**
   * institutions upsert
   */
  export type institutionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institutions
     */
    omit?: institutionsOmit<ExtArgs> | null
    /**
     * The filter to search for the institutions to update in case it exists.
     */
    where: institutionsWhereUniqueInput
    /**
     * In case the institutions found by the `where` argument doesn't exist, create a new institutions with this data.
     */
    create: XOR<institutionsCreateInput, institutionsUncheckedCreateInput>
    /**
     * In case the institutions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<institutionsUpdateInput, institutionsUncheckedUpdateInput>
  }

  /**
   * institutions delete
   */
  export type institutionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institutions
     */
    omit?: institutionsOmit<ExtArgs> | null
    /**
     * Filter which institutions to delete.
     */
    where: institutionsWhereUniqueInput
  }

  /**
   * institutions deleteMany
   */
  export type institutionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which institutions to delete
     */
    where?: institutionsWhereInput
    /**
     * Limit how many institutions to delete.
     */
    limit?: number
  }

  /**
   * institutions findRaw
   */
  export type institutionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * institutions aggregateRaw
   */
  export type institutionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * institutions without action
   */
  export type institutionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the institutions
     */
    omit?: institutionsOmit<ExtArgs> | null
  }


  /**
   * Model logs
   */

  export type AggregateLogs = {
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  export type LogsAvgAggregateOutputType = {
    timestamp: number | null
  }

  export type LogsSumAggregateOutputType = {
    timestamp: number | null
  }

  export type LogsMinAggregateOutputType = {
    id: string | null
    action: string | null
    applicationID: string | null
    eventType: string | null
    localtime: Date | null
    newState: string | null
    prevState: string | null
    submissionID: string | null
    timestamp: number | null
    userEmail: string | null
    userID: string | null
    userIDP: string | null
    userName: string | null
  }

  export type LogsMaxAggregateOutputType = {
    id: string | null
    action: string | null
    applicationID: string | null
    eventType: string | null
    localtime: Date | null
    newState: string | null
    prevState: string | null
    submissionID: string | null
    timestamp: number | null
    userEmail: string | null
    userID: string | null
    userIDP: string | null
    userName: string | null
  }

  export type LogsCountAggregateOutputType = {
    id: number
    action: number
    applicationID: number
    eventType: number
    localtime: number
    newProfile: number
    newState: number
    prevProfile: number
    prevState: number
    submissionID: number
    timestamp: number
    userEmail: number
    userID: number
    userIDP: number
    userName: number
    _all: number
  }


  export type LogsAvgAggregateInputType = {
    timestamp?: true
  }

  export type LogsSumAggregateInputType = {
    timestamp?: true
  }

  export type LogsMinAggregateInputType = {
    id?: true
    action?: true
    applicationID?: true
    eventType?: true
    localtime?: true
    newState?: true
    prevState?: true
    submissionID?: true
    timestamp?: true
    userEmail?: true
    userID?: true
    userIDP?: true
    userName?: true
  }

  export type LogsMaxAggregateInputType = {
    id?: true
    action?: true
    applicationID?: true
    eventType?: true
    localtime?: true
    newState?: true
    prevState?: true
    submissionID?: true
    timestamp?: true
    userEmail?: true
    userID?: true
    userIDP?: true
    userName?: true
  }

  export type LogsCountAggregateInputType = {
    id?: true
    action?: true
    applicationID?: true
    eventType?: true
    localtime?: true
    newProfile?: true
    newState?: true
    prevProfile?: true
    prevState?: true
    submissionID?: true
    timestamp?: true
    userEmail?: true
    userID?: true
    userIDP?: true
    userName?: true
    _all?: true
  }

  export type LogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs to aggregate.
     */
    where?: logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logsOrderByWithRelationInput | logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logs
    **/
    _count?: true | LogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogsMaxAggregateInputType
  }

  export type GetLogsAggregateType<T extends LogsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs[P]>
      : GetScalarType<T[P], AggregateLogs[P]>
  }




  export type logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logsWhereInput
    orderBy?: logsOrderByWithAggregationInput | logsOrderByWithAggregationInput[]
    by: LogsScalarFieldEnum[] | LogsScalarFieldEnum
    having?: logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogsCountAggregateInputType | true
    _avg?: LogsAvgAggregateInputType
    _sum?: LogsSumAggregateInputType
    _min?: LogsMinAggregateInputType
    _max?: LogsMaxAggregateInputType
  }

  export type LogsGroupByOutputType = {
    id: string
    action: string | null
    applicationID: string | null
    eventType: string
    localtime: Date
    newProfile: JsonValue | null
    newState: string | null
    prevProfile: JsonValue | null
    prevState: string | null
    submissionID: string | null
    timestamp: number
    userEmail: string
    userID: string
    userIDP: string | null
    userName: string | null
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  type GetLogsGroupByPayload<T extends logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogsGroupByOutputType[P]>
            : GetScalarType<T[P], LogsGroupByOutputType[P]>
        }
      >
    >


  export type logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    applicationID?: boolean
    eventDetail?: boolean | LogsEventDetailDefaultArgs<ExtArgs>
    eventType?: boolean
    localtime?: boolean
    newProfile?: boolean
    newState?: boolean
    prevProfile?: boolean
    prevState?: boolean
    submissionID?: boolean
    timestamp?: boolean
    userEmail?: boolean
    userID?: boolean
    userIDP?: boolean
    userName?: boolean
  }, ExtArgs["result"]["logs"]>



  export type logsSelectScalar = {
    id?: boolean
    action?: boolean
    applicationID?: boolean
    eventType?: boolean
    localtime?: boolean
    newProfile?: boolean
    newState?: boolean
    prevProfile?: boolean
    prevState?: boolean
    submissionID?: boolean
    timestamp?: boolean
    userEmail?: boolean
    userID?: boolean
    userIDP?: boolean
    userName?: boolean
  }

  export type logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "applicationID" | "eventDetail" | "eventType" | "localtime" | "newProfile" | "newState" | "prevProfile" | "prevState" | "submissionID" | "timestamp" | "userEmail" | "userID" | "userIDP" | "userName", ExtArgs["result"]["logs"]>
  export type logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string | null
      applicationID: string | null
      eventType: string
      localtime: Date
      newProfile: Prisma.JsonValue | null
      newState: string | null
      prevProfile: Prisma.JsonValue | null
      prevState: string | null
      submissionID: string | null
      timestamp: number
      userEmail: string
      userID: string
      userIDP: string | null
      userName: string | null
    }, ExtArgs["result"]["logs"]>
    composites: {
      eventDetail: Prisma.$LogsEventDetailPayload | null
    }
  }

  type logsGetPayload<S extends boolean | null | undefined | logsDefaultArgs> = $Result.GetResult<Prisma.$logsPayload, S>

  type logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogsCountAggregateInputType | true
    }

  export interface logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['logs'], meta: { name: 'logs' } }
    /**
     * Find zero or one Logs that matches the filter.
     * @param {logsFindUniqueArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends logsFindUniqueArgs>(args: SelectSubset<T, logsFindUniqueArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {logsFindUniqueOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends logsFindUniqueOrThrowArgs>(args: SelectSubset<T, logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsFindFirstArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends logsFindFirstArgs>(args?: SelectSubset<T, logsFindFirstArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsFindFirstOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends logsFindFirstOrThrowArgs>(args?: SelectSubset<T, logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.logs.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logsWithIdOnly = await prisma.logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends logsFindManyArgs>(args?: SelectSubset<T, logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Logs.
     * @param {logsCreateArgs} args - Arguments to create a Logs.
     * @example
     * // Create one Logs
     * const Logs = await prisma.logs.create({
     *   data: {
     *     // ... data to create a Logs
     *   }
     * })
     * 
     */
    create<T extends logsCreateArgs>(args: SelectSubset<T, logsCreateArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {logsCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const logs = await prisma.logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends logsCreateManyArgs>(args?: SelectSubset<T, logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logs.
     * @param {logsDeleteArgs} args - Arguments to delete one Logs.
     * @example
     * // Delete one Logs
     * const Logs = await prisma.logs.delete({
     *   where: {
     *     // ... filter to delete one Logs
     *   }
     * })
     * 
     */
    delete<T extends logsDeleteArgs>(args: SelectSubset<T, logsDeleteArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Logs.
     * @param {logsUpdateArgs} args - Arguments to update one Logs.
     * @example
     * // Update one Logs
     * const logs = await prisma.logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends logsUpdateArgs>(args: SelectSubset<T, logsUpdateArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {logsDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends logsDeleteManyArgs>(args?: SelectSubset<T, logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const logs = await prisma.logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends logsUpdateManyArgs>(args: SelectSubset<T, logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logs.
     * @param {logsUpsertArgs} args - Arguments to update or create a Logs.
     * @example
     * // Update or create a Logs
     * const logs = await prisma.logs.upsert({
     *   create: {
     *     // ... data to create a Logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs we want to update
     *   }
     * })
     */
    upsert<T extends logsUpsertArgs>(args: SelectSubset<T, logsUpsertArgs<ExtArgs>>): Prisma__logsClient<$Result.GetResult<Prisma.$logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * @param {logsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const logs = await prisma.logs.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: logsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Logs.
     * @param {logsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const logs = await prisma.logs.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: logsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.logs.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends logsCountArgs>(
      args?: Subset<T, logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogsAggregateArgs>(args: Subset<T, LogsAggregateArgs>): Prisma.PrismaPromise<GetLogsAggregateType<T>>

    /**
     * Group by Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: logsGroupByArgs['orderBy'] }
        : { orderBy?: logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the logs model
   */
  readonly fields: logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the logs model
   */
  interface logsFieldRefs {
    readonly id: FieldRef<"logs", 'String'>
    readonly action: FieldRef<"logs", 'String'>
    readonly applicationID: FieldRef<"logs", 'String'>
    readonly eventType: FieldRef<"logs", 'String'>
    readonly localtime: FieldRef<"logs", 'DateTime'>
    readonly newProfile: FieldRef<"logs", 'Json'>
    readonly newState: FieldRef<"logs", 'String'>
    readonly prevProfile: FieldRef<"logs", 'Json'>
    readonly prevState: FieldRef<"logs", 'String'>
    readonly submissionID: FieldRef<"logs", 'String'>
    readonly timestamp: FieldRef<"logs", 'Float'>
    readonly userEmail: FieldRef<"logs", 'String'>
    readonly userID: FieldRef<"logs", 'String'>
    readonly userIDP: FieldRef<"logs", 'String'>
    readonly userName: FieldRef<"logs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * logs findUnique
   */
  export type logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logsInclude<ExtArgs> | null
    /**
     * Filter, which logs to fetch.
     */
    where: logsWhereUniqueInput
  }

  /**
   * logs findUniqueOrThrow
   */
  export type logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logsInclude<ExtArgs> | null
    /**
     * Filter, which logs to fetch.
     */
    where: logsWhereUniqueInput
  }

  /**
   * logs findFirst
   */
  export type logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logsInclude<ExtArgs> | null
    /**
     * Filter, which logs to fetch.
     */
    where?: logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logsOrderByWithRelationInput | logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs.
     */
    cursor?: logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * logs findFirstOrThrow
   */
  export type logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logsInclude<ExtArgs> | null
    /**
     * Filter, which logs to fetch.
     */
    where?: logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logsOrderByWithRelationInput | logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs.
     */
    cursor?: logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * logs findMany
   */
  export type logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logsInclude<ExtArgs> | null
    /**
     * Filter, which logs to fetch.
     */
    where?: logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: logsOrderByWithRelationInput | logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logs.
     */
    cursor?: logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * logs create
   */
  export type logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logsInclude<ExtArgs> | null
    /**
     * The data needed to create a logs.
     */
    data: XOR<logsCreateInput, logsUncheckedCreateInput>
  }

  /**
   * logs createMany
   */
  export type logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many logs.
     */
    data: logsCreateManyInput | logsCreateManyInput[]
  }

  /**
   * logs update
   */
  export type logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logsInclude<ExtArgs> | null
    /**
     * The data needed to update a logs.
     */
    data: XOR<logsUpdateInput, logsUncheckedUpdateInput>
    /**
     * Choose, which logs to update.
     */
    where: logsWhereUniqueInput
  }

  /**
   * logs updateMany
   */
  export type logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update logs.
     */
    data: XOR<logsUpdateManyMutationInput, logsUncheckedUpdateManyInput>
    /**
     * Filter which logs to update
     */
    where?: logsWhereInput
    /**
     * Limit how many logs to update.
     */
    limit?: number
  }

  /**
   * logs upsert
   */
  export type logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logsInclude<ExtArgs> | null
    /**
     * The filter to search for the logs to update in case it exists.
     */
    where: logsWhereUniqueInput
    /**
     * In case the logs found by the `where` argument doesn't exist, create a new logs with this data.
     */
    create: XOR<logsCreateInput, logsUncheckedCreateInput>
    /**
     * In case the logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<logsUpdateInput, logsUncheckedUpdateInput>
  }

  /**
   * logs delete
   */
  export type logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logsInclude<ExtArgs> | null
    /**
     * Filter which logs to delete.
     */
    where: logsWhereUniqueInput
  }

  /**
   * logs deleteMany
   */
  export type logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs to delete
     */
    where?: logsWhereInput
    /**
     * Limit how many logs to delete.
     */
    limit?: number
  }

  /**
   * logs findRaw
   */
  export type logsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * logs aggregateRaw
   */
  export type logsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * logs without action
   */
  export type logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs
     */
    select?: logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logs
     */
    omit?: logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logsInclude<ExtArgs> | null
  }


  /**
   * Model organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    abbreviation: string | null
    bucketName: string | null
    conciergeEmail: string | null
    conciergeID: string | null
    conciergeName: string | null
    createdAt: Date | null
    description: string | null
    name: string | null
    rootPath: string | null
    status: string | null
    updateAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    abbreviation: string | null
    bucketName: string | null
    conciergeEmail: string | null
    conciergeID: string | null
    conciergeName: string | null
    createdAt: Date | null
    description: string | null
    name: string | null
    rootPath: string | null
    status: string | null
    updateAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    abbreviation: number
    bucketName: number
    conciergeEmail: number
    conciergeID: number
    conciergeName: number
    createdAt: number
    description: number
    name: number
    rootPath: number
    status: number
    updateAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    abbreviation?: true
    bucketName?: true
    conciergeEmail?: true
    conciergeID?: true
    conciergeName?: true
    createdAt?: true
    description?: true
    name?: true
    rootPath?: true
    status?: true
    updateAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    abbreviation?: true
    bucketName?: true
    conciergeEmail?: true
    conciergeID?: true
    conciergeName?: true
    createdAt?: true
    description?: true
    name?: true
    rootPath?: true
    status?: true
    updateAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    abbreviation?: true
    bucketName?: true
    conciergeEmail?: true
    conciergeID?: true
    conciergeName?: true
    createdAt?: true
    description?: true
    name?: true
    rootPath?: true
    status?: true
    updateAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organization to aggregate.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type organizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organizationWhereInput
    orderBy?: organizationOrderByWithAggregationInput | organizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: organizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    abbreviation: string | null
    bucketName: string | null
    conciergeEmail: string | null
    conciergeID: string | null
    conciergeName: string | null
    createdAt: Date
    description: string | null
    name: string
    rootPath: string | null
    status: string
    updateAt: Date
    updatedAt: Date | null
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends organizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type organizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    abbreviation?: boolean
    bucketName?: boolean
    conciergeEmail?: boolean
    conciergeID?: boolean
    conciergeName?: boolean
    createdAt?: boolean
    description?: boolean
    name?: boolean
    rootPath?: boolean
    status?: boolean
    studies?: boolean | StudyByIDDefaultArgs<ExtArgs>
    updateAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>



  export type organizationSelectScalar = {
    id?: boolean
    abbreviation?: boolean
    bucketName?: boolean
    conciergeEmail?: boolean
    conciergeID?: boolean
    conciergeName?: boolean
    createdAt?: boolean
    description?: boolean
    name?: boolean
    rootPath?: boolean
    status?: boolean
    updateAt?: boolean
    updatedAt?: boolean
  }

  export type organizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "abbreviation" | "bucketName" | "conciergeEmail" | "conciergeID" | "conciergeName" | "createdAt" | "description" | "name" | "rootPath" | "status" | "studies" | "updateAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type organizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $organizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "organization"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      abbreviation: string | null
      bucketName: string | null
      conciergeEmail: string | null
      conciergeID: string | null
      conciergeName: string | null
      createdAt: Date
      description: string | null
      name: string
      rootPath: string | null
      status: string
      updateAt: Date
      /**
       * Multiple data types found: String: 50%, DateTime (Date): 50% out of 4 sampled entries
       */
      updatedAt: Date | null
    }, ExtArgs["result"]["organization"]>
    composites: {
      studies: Prisma.$StudyByIDPayload[]
    }
  }

  type organizationGetPayload<S extends boolean | null | undefined | organizationDefaultArgs> = $Result.GetResult<Prisma.$organizationPayload, S>

  type organizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<organizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface organizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['organization'], meta: { name: 'organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {organizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends organizationFindUniqueArgs>(args: SelectSubset<T, organizationFindUniqueArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {organizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends organizationFindUniqueOrThrowArgs>(args: SelectSubset<T, organizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends organizationFindFirstArgs>(args?: SelectSubset<T, organizationFindFirstArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends organizationFindFirstOrThrowArgs>(args?: SelectSubset<T, organizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends organizationFindManyArgs>(args?: SelectSubset<T, organizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {organizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends organizationCreateArgs>(args: SelectSubset<T, organizationCreateArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {organizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends organizationCreateManyArgs>(args?: SelectSubset<T, organizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {organizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends organizationDeleteArgs>(args: SelectSubset<T, organizationDeleteArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {organizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends organizationUpdateArgs>(args: SelectSubset<T, organizationUpdateArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {organizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends organizationDeleteManyArgs>(args?: SelectSubset<T, organizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends organizationUpdateManyArgs>(args: SelectSubset<T, organizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {organizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends organizationUpsertArgs>(args: SelectSubset<T, organizationUpsertArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * @param {organizationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const organization = await prisma.organization.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: organizationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Organization.
     * @param {organizationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const organization = await prisma.organization.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: organizationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends organizationCountArgs>(
      args?: Subset<T, organizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends organizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: organizationGroupByArgs['orderBy'] }
        : { orderBy?: organizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, organizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the organization model
   */
  readonly fields: organizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__organizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the organization model
   */
  interface organizationFieldRefs {
    readonly id: FieldRef<"organization", 'String'>
    readonly abbreviation: FieldRef<"organization", 'String'>
    readonly bucketName: FieldRef<"organization", 'String'>
    readonly conciergeEmail: FieldRef<"organization", 'String'>
    readonly conciergeID: FieldRef<"organization", 'String'>
    readonly conciergeName: FieldRef<"organization", 'String'>
    readonly createdAt: FieldRef<"organization", 'DateTime'>
    readonly description: FieldRef<"organization", 'String'>
    readonly name: FieldRef<"organization", 'String'>
    readonly rootPath: FieldRef<"organization", 'String'>
    readonly status: FieldRef<"organization", 'String'>
    readonly updateAt: FieldRef<"organization", 'DateTime'>
    readonly updatedAt: FieldRef<"organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * organization findUnique
   */
  export type organizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization findUniqueOrThrow
   */
  export type organizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization findFirst
   */
  export type organizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * organization findFirstOrThrow
   */
  export type organizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * organization findMany
   */
  export type organizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organizations.
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * organization create
   */
  export type organizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * The data needed to create a organization.
     */
    data: XOR<organizationCreateInput, organizationUncheckedCreateInput>
  }

  /**
   * organization createMany
   */
  export type organizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many organizations.
     */
    data: organizationCreateManyInput | organizationCreateManyInput[]
  }

  /**
   * organization update
   */
  export type organizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * The data needed to update a organization.
     */
    data: XOR<organizationUpdateInput, organizationUncheckedUpdateInput>
    /**
     * Choose, which organization to update.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization updateMany
   */
  export type organizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update organizations.
     */
    data: XOR<organizationUpdateManyMutationInput, organizationUncheckedUpdateManyInput>
    /**
     * Filter which organizations to update
     */
    where?: organizationWhereInput
    /**
     * Limit how many organizations to update.
     */
    limit?: number
  }

  /**
   * organization upsert
   */
  export type organizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * The filter to search for the organization to update in case it exists.
     */
    where: organizationWhereUniqueInput
    /**
     * In case the organization found by the `where` argument doesn't exist, create a new organization with this data.
     */
    create: XOR<organizationCreateInput, organizationUncheckedCreateInput>
    /**
     * In case the organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<organizationUpdateInput, organizationUncheckedUpdateInput>
  }

  /**
   * organization delete
   */
  export type organizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter which organization to delete.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization deleteMany
   */
  export type organizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organizations to delete
     */
    where?: organizationWhereInput
    /**
     * Limit how many organizations to delete.
     */
    limit?: number
  }

  /**
   * organization findRaw
   */
  export type organizationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * organization aggregateRaw
   */
  export type organizationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * organization without action
   */
  export type organizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
  }


  /**
   * Model qcResults
   */

  export type AggregateQcResults = {
    _count: QcResultsCountAggregateOutputType | null
    _avg: QcResultsAvgAggregateOutputType | null
    _sum: QcResultsSumAggregateOutputType | null
    _min: QcResultsMinAggregateOutputType | null
    _max: QcResultsMaxAggregateOutputType | null
  }

  export type QcResultsAvgAggregateOutputType = {
    displayID: number | null
  }

  export type QcResultsSumAggregateOutputType = {
    displayID: number | null
  }

  export type QcResultsMinAggregateOutputType = {
    id: string | null
    dataRecordID: string | null
    displayID: number | null
    latestBatchID: string | null
    origin: string | null
    severity: string | null
    submissionID: string | null
    submittedID: string | null
    type: string | null
    uploadedDate: Date | null
    validatedDate: Date | null
    validationType: string | null
  }

  export type QcResultsMaxAggregateOutputType = {
    id: string | null
    dataRecordID: string | null
    displayID: number | null
    latestBatchID: string | null
    origin: string | null
    severity: string | null
    submissionID: string | null
    submittedID: string | null
    type: string | null
    uploadedDate: Date | null
    validatedDate: Date | null
    validationType: string | null
  }

  export type QcResultsCountAggregateOutputType = {
    id: number
    batchIDs: number
    dataRecordID: number
    displayID: number
    latestBatchID: number
    origin: number
    severity: number
    submissionID: number
    submittedID: number
    type: number
    uploadedDate: number
    validatedDate: number
    validationType: number
    _all: number
  }


  export type QcResultsAvgAggregateInputType = {
    displayID?: true
  }

  export type QcResultsSumAggregateInputType = {
    displayID?: true
  }

  export type QcResultsMinAggregateInputType = {
    id?: true
    dataRecordID?: true
    displayID?: true
    latestBatchID?: true
    origin?: true
    severity?: true
    submissionID?: true
    submittedID?: true
    type?: true
    uploadedDate?: true
    validatedDate?: true
    validationType?: true
  }

  export type QcResultsMaxAggregateInputType = {
    id?: true
    dataRecordID?: true
    displayID?: true
    latestBatchID?: true
    origin?: true
    severity?: true
    submissionID?: true
    submittedID?: true
    type?: true
    uploadedDate?: true
    validatedDate?: true
    validationType?: true
  }

  export type QcResultsCountAggregateInputType = {
    id?: true
    batchIDs?: true
    dataRecordID?: true
    displayID?: true
    latestBatchID?: true
    origin?: true
    severity?: true
    submissionID?: true
    submittedID?: true
    type?: true
    uploadedDate?: true
    validatedDate?: true
    validationType?: true
    _all?: true
  }

  export type QcResultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qcResults to aggregate.
     */
    where?: qcResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcResults to fetch.
     */
    orderBy?: qcResultsOrderByWithRelationInput | qcResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qcResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qcResults
    **/
    _count?: true | QcResultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QcResultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QcResultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QcResultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QcResultsMaxAggregateInputType
  }

  export type GetQcResultsAggregateType<T extends QcResultsAggregateArgs> = {
        [P in keyof T & keyof AggregateQcResults]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQcResults[P]>
      : GetScalarType<T[P], AggregateQcResults[P]>
  }




  export type qcResultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qcResultsWhereInput
    orderBy?: qcResultsOrderByWithAggregationInput | qcResultsOrderByWithAggregationInput[]
    by: QcResultsScalarFieldEnum[] | QcResultsScalarFieldEnum
    having?: qcResultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QcResultsCountAggregateInputType | true
    _avg?: QcResultsAvgAggregateInputType
    _sum?: QcResultsSumAggregateInputType
    _min?: QcResultsMinAggregateInputType
    _max?: QcResultsMaxAggregateInputType
  }

  export type QcResultsGroupByOutputType = {
    id: string
    batchIDs: string[]
    dataRecordID: string
    displayID: number
    latestBatchID: string
    origin: string | null
    severity: string
    submissionID: string
    submittedID: string
    type: string
    uploadedDate: Date
    validatedDate: Date
    validationType: string
    _count: QcResultsCountAggregateOutputType | null
    _avg: QcResultsAvgAggregateOutputType | null
    _sum: QcResultsSumAggregateOutputType | null
    _min: QcResultsMinAggregateOutputType | null
    _max: QcResultsMaxAggregateOutputType | null
  }

  type GetQcResultsGroupByPayload<T extends qcResultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QcResultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QcResultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QcResultsGroupByOutputType[P]>
            : GetScalarType<T[P], QcResultsGroupByOutputType[P]>
        }
      >
    >


  export type qcResultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchIDs?: boolean
    dataRecordID?: boolean
    displayID?: boolean
    errors?: boolean | ErrorDefaultArgs<ExtArgs>
    latestBatchID?: boolean
    origin?: boolean
    severity?: boolean
    submissionID?: boolean
    submittedID?: boolean
    type?: boolean
    uploadedDate?: boolean
    validatedDate?: boolean
    validationType?: boolean
    warnings?: boolean | ErrorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qcResults"]>



  export type qcResultsSelectScalar = {
    id?: boolean
    batchIDs?: boolean
    dataRecordID?: boolean
    displayID?: boolean
    latestBatchID?: boolean
    origin?: boolean
    severity?: boolean
    submissionID?: boolean
    submittedID?: boolean
    type?: boolean
    uploadedDate?: boolean
    validatedDate?: boolean
    validationType?: boolean
  }

  export type qcResultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "batchIDs" | "dataRecordID" | "displayID" | "errors" | "latestBatchID" | "origin" | "severity" | "submissionID" | "submittedID" | "type" | "uploadedDate" | "validatedDate" | "validationType" | "warnings", ExtArgs["result"]["qcResults"]>
  export type qcResultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $qcResultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qcResults"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batchIDs: string[]
      dataRecordID: string
      displayID: number
      latestBatchID: string
      origin: string | null
      severity: string
      submissionID: string
      submittedID: string
      type: string
      uploadedDate: Date
      validatedDate: Date
      validationType: string
    }, ExtArgs["result"]["qcResults"]>
    composites: {
      errors: Prisma.$ErrorPayload[]
      warnings: Prisma.$ErrorPayload[]
    }
  }

  type qcResultsGetPayload<S extends boolean | null | undefined | qcResultsDefaultArgs> = $Result.GetResult<Prisma.$qcResultsPayload, S>

  type qcResultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qcResultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QcResultsCountAggregateInputType | true
    }

  export interface qcResultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qcResults'], meta: { name: 'qcResults' } }
    /**
     * Find zero or one QcResults that matches the filter.
     * @param {qcResultsFindUniqueArgs} args - Arguments to find a QcResults
     * @example
     * // Get one QcResults
     * const qcResults = await prisma.qcResults.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qcResultsFindUniqueArgs>(args: SelectSubset<T, qcResultsFindUniqueArgs<ExtArgs>>): Prisma__qcResultsClient<$Result.GetResult<Prisma.$qcResultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QcResults that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qcResultsFindUniqueOrThrowArgs} args - Arguments to find a QcResults
     * @example
     * // Get one QcResults
     * const qcResults = await prisma.qcResults.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qcResultsFindUniqueOrThrowArgs>(args: SelectSubset<T, qcResultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qcResultsClient<$Result.GetResult<Prisma.$qcResultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcResultsFindFirstArgs} args - Arguments to find a QcResults
     * @example
     * // Get one QcResults
     * const qcResults = await prisma.qcResults.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qcResultsFindFirstArgs>(args?: SelectSubset<T, qcResultsFindFirstArgs<ExtArgs>>): Prisma__qcResultsClient<$Result.GetResult<Prisma.$qcResultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcResults that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcResultsFindFirstOrThrowArgs} args - Arguments to find a QcResults
     * @example
     * // Get one QcResults
     * const qcResults = await prisma.qcResults.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qcResultsFindFirstOrThrowArgs>(args?: SelectSubset<T, qcResultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__qcResultsClient<$Result.GetResult<Prisma.$qcResultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QcResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcResultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QcResults
     * const qcResults = await prisma.qcResults.findMany()
     * 
     * // Get first 10 QcResults
     * const qcResults = await prisma.qcResults.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qcResultsWithIdOnly = await prisma.qcResults.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends qcResultsFindManyArgs>(args?: SelectSubset<T, qcResultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qcResultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QcResults.
     * @param {qcResultsCreateArgs} args - Arguments to create a QcResults.
     * @example
     * // Create one QcResults
     * const QcResults = await prisma.qcResults.create({
     *   data: {
     *     // ... data to create a QcResults
     *   }
     * })
     * 
     */
    create<T extends qcResultsCreateArgs>(args: SelectSubset<T, qcResultsCreateArgs<ExtArgs>>): Prisma__qcResultsClient<$Result.GetResult<Prisma.$qcResultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QcResults.
     * @param {qcResultsCreateManyArgs} args - Arguments to create many QcResults.
     * @example
     * // Create many QcResults
     * const qcResults = await prisma.qcResults.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qcResultsCreateManyArgs>(args?: SelectSubset<T, qcResultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QcResults.
     * @param {qcResultsDeleteArgs} args - Arguments to delete one QcResults.
     * @example
     * // Delete one QcResults
     * const QcResults = await prisma.qcResults.delete({
     *   where: {
     *     // ... filter to delete one QcResults
     *   }
     * })
     * 
     */
    delete<T extends qcResultsDeleteArgs>(args: SelectSubset<T, qcResultsDeleteArgs<ExtArgs>>): Prisma__qcResultsClient<$Result.GetResult<Prisma.$qcResultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QcResults.
     * @param {qcResultsUpdateArgs} args - Arguments to update one QcResults.
     * @example
     * // Update one QcResults
     * const qcResults = await prisma.qcResults.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qcResultsUpdateArgs>(args: SelectSubset<T, qcResultsUpdateArgs<ExtArgs>>): Prisma__qcResultsClient<$Result.GetResult<Prisma.$qcResultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QcResults.
     * @param {qcResultsDeleteManyArgs} args - Arguments to filter QcResults to delete.
     * @example
     * // Delete a few QcResults
     * const { count } = await prisma.qcResults.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qcResultsDeleteManyArgs>(args?: SelectSubset<T, qcResultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QcResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcResultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QcResults
     * const qcResults = await prisma.qcResults.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qcResultsUpdateManyArgs>(args: SelectSubset<T, qcResultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QcResults.
     * @param {qcResultsUpsertArgs} args - Arguments to update or create a QcResults.
     * @example
     * // Update or create a QcResults
     * const qcResults = await prisma.qcResults.upsert({
     *   create: {
     *     // ... data to create a QcResults
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QcResults we want to update
     *   }
     * })
     */
    upsert<T extends qcResultsUpsertArgs>(args: SelectSubset<T, qcResultsUpsertArgs<ExtArgs>>): Prisma__qcResultsClient<$Result.GetResult<Prisma.$qcResultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QcResults that matches the filter.
     * @param {qcResultsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const qcResults = await prisma.qcResults.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: qcResultsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a QcResults.
     * @param {qcResultsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const qcResults = await prisma.qcResults.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: qcResultsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of QcResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcResultsCountArgs} args - Arguments to filter QcResults to count.
     * @example
     * // Count the number of QcResults
     * const count = await prisma.qcResults.count({
     *   where: {
     *     // ... the filter for the QcResults we want to count
     *   }
     * })
    **/
    count<T extends qcResultsCountArgs>(
      args?: Subset<T, qcResultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QcResultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QcResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QcResultsAggregateArgs>(args: Subset<T, QcResultsAggregateArgs>): Prisma.PrismaPromise<GetQcResultsAggregateType<T>>

    /**
     * Group by QcResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcResultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qcResultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qcResultsGroupByArgs['orderBy'] }
        : { orderBy?: qcResultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qcResultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQcResultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qcResults model
   */
  readonly fields: qcResultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qcResults.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qcResultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qcResults model
   */
  interface qcResultsFieldRefs {
    readonly id: FieldRef<"qcResults", 'String'>
    readonly batchIDs: FieldRef<"qcResults", 'String[]'>
    readonly dataRecordID: FieldRef<"qcResults", 'String'>
    readonly displayID: FieldRef<"qcResults", 'Int'>
    readonly latestBatchID: FieldRef<"qcResults", 'String'>
    readonly origin: FieldRef<"qcResults", 'String'>
    readonly severity: FieldRef<"qcResults", 'String'>
    readonly submissionID: FieldRef<"qcResults", 'String'>
    readonly submittedID: FieldRef<"qcResults", 'String'>
    readonly type: FieldRef<"qcResults", 'String'>
    readonly uploadedDate: FieldRef<"qcResults", 'DateTime'>
    readonly validatedDate: FieldRef<"qcResults", 'DateTime'>
    readonly validationType: FieldRef<"qcResults", 'String'>
  }
    

  // Custom InputTypes
  /**
   * qcResults findUnique
   */
  export type qcResultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcResults
     */
    select?: qcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qcResults
     */
    omit?: qcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qcResultsInclude<ExtArgs> | null
    /**
     * Filter, which qcResults to fetch.
     */
    where: qcResultsWhereUniqueInput
  }

  /**
   * qcResults findUniqueOrThrow
   */
  export type qcResultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcResults
     */
    select?: qcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qcResults
     */
    omit?: qcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qcResultsInclude<ExtArgs> | null
    /**
     * Filter, which qcResults to fetch.
     */
    where: qcResultsWhereUniqueInput
  }

  /**
   * qcResults findFirst
   */
  export type qcResultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcResults
     */
    select?: qcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qcResults
     */
    omit?: qcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qcResultsInclude<ExtArgs> | null
    /**
     * Filter, which qcResults to fetch.
     */
    where?: qcResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcResults to fetch.
     */
    orderBy?: qcResultsOrderByWithRelationInput | qcResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qcResults.
     */
    cursor?: qcResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qcResults.
     */
    distinct?: QcResultsScalarFieldEnum | QcResultsScalarFieldEnum[]
  }

  /**
   * qcResults findFirstOrThrow
   */
  export type qcResultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcResults
     */
    select?: qcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qcResults
     */
    omit?: qcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qcResultsInclude<ExtArgs> | null
    /**
     * Filter, which qcResults to fetch.
     */
    where?: qcResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcResults to fetch.
     */
    orderBy?: qcResultsOrderByWithRelationInput | qcResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qcResults.
     */
    cursor?: qcResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qcResults.
     */
    distinct?: QcResultsScalarFieldEnum | QcResultsScalarFieldEnum[]
  }

  /**
   * qcResults findMany
   */
  export type qcResultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcResults
     */
    select?: qcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qcResults
     */
    omit?: qcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qcResultsInclude<ExtArgs> | null
    /**
     * Filter, which qcResults to fetch.
     */
    where?: qcResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcResults to fetch.
     */
    orderBy?: qcResultsOrderByWithRelationInput | qcResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qcResults.
     */
    cursor?: qcResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcResults.
     */
    skip?: number
    distinct?: QcResultsScalarFieldEnum | QcResultsScalarFieldEnum[]
  }

  /**
   * qcResults create
   */
  export type qcResultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcResults
     */
    select?: qcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qcResults
     */
    omit?: qcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qcResultsInclude<ExtArgs> | null
    /**
     * The data needed to create a qcResults.
     */
    data: XOR<qcResultsCreateInput, qcResultsUncheckedCreateInput>
  }

  /**
   * qcResults createMany
   */
  export type qcResultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qcResults.
     */
    data: qcResultsCreateManyInput | qcResultsCreateManyInput[]
  }

  /**
   * qcResults update
   */
  export type qcResultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcResults
     */
    select?: qcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qcResults
     */
    omit?: qcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qcResultsInclude<ExtArgs> | null
    /**
     * The data needed to update a qcResults.
     */
    data: XOR<qcResultsUpdateInput, qcResultsUncheckedUpdateInput>
    /**
     * Choose, which qcResults to update.
     */
    where: qcResultsWhereUniqueInput
  }

  /**
   * qcResults updateMany
   */
  export type qcResultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qcResults.
     */
    data: XOR<qcResultsUpdateManyMutationInput, qcResultsUncheckedUpdateManyInput>
    /**
     * Filter which qcResults to update
     */
    where?: qcResultsWhereInput
    /**
     * Limit how many qcResults to update.
     */
    limit?: number
  }

  /**
   * qcResults upsert
   */
  export type qcResultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcResults
     */
    select?: qcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qcResults
     */
    omit?: qcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qcResultsInclude<ExtArgs> | null
    /**
     * The filter to search for the qcResults to update in case it exists.
     */
    where: qcResultsWhereUniqueInput
    /**
     * In case the qcResults found by the `where` argument doesn't exist, create a new qcResults with this data.
     */
    create: XOR<qcResultsCreateInput, qcResultsUncheckedCreateInput>
    /**
     * In case the qcResults was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qcResultsUpdateInput, qcResultsUncheckedUpdateInput>
  }

  /**
   * qcResults delete
   */
  export type qcResultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcResults
     */
    select?: qcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qcResults
     */
    omit?: qcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qcResultsInclude<ExtArgs> | null
    /**
     * Filter which qcResults to delete.
     */
    where: qcResultsWhereUniqueInput
  }

  /**
   * qcResults deleteMany
   */
  export type qcResultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qcResults to delete
     */
    where?: qcResultsWhereInput
    /**
     * Limit how many qcResults to delete.
     */
    limit?: number
  }

  /**
   * qcResults findRaw
   */
  export type qcResultsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * qcResults aggregateRaw
   */
  export type qcResultsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * qcResults without action
   */
  export type qcResultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcResults
     */
    select?: qcResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qcResults
     */
    omit?: qcResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qcResultsInclude<ExtArgs> | null
  }


  /**
   * Model release
   */

  export type AggregateRelease = {
    _count: ReleaseCountAggregateOutputType | null
    _min: ReleaseMinAggregateOutputType | null
    _max: ReleaseMaxAggregateOutputType | null
  }

  export type ReleaseMinAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    createdAt: Date | null
    dataCommons: string | null
    entityType: string | null
    nodeID: string | null
    nodeType: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    updatedAt: Date | null
  }

  export type ReleaseMaxAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    createdAt: Date | null
    dataCommons: string | null
    entityType: string | null
    nodeID: string | null
    nodeType: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    updatedAt: Date | null
  }

  export type ReleaseCountAggregateOutputType = {
    id: number
    CRDC_ID: number
    createdAt: number
    dataCommons: number
    entityType: number
    nodeID: number
    nodeType: number
    props: number
    status: number
    studyID: number
    submissionID: number
    updatedAt: number
    _all: number
  }


  export type ReleaseMinAggregateInputType = {
    id?: true
    CRDC_ID?: true
    createdAt?: true
    dataCommons?: true
    entityType?: true
    nodeID?: true
    nodeType?: true
    status?: true
    studyID?: true
    submissionID?: true
    updatedAt?: true
  }

  export type ReleaseMaxAggregateInputType = {
    id?: true
    CRDC_ID?: true
    createdAt?: true
    dataCommons?: true
    entityType?: true
    nodeID?: true
    nodeType?: true
    status?: true
    studyID?: true
    submissionID?: true
    updatedAt?: true
  }

  export type ReleaseCountAggregateInputType = {
    id?: true
    CRDC_ID?: true
    createdAt?: true
    dataCommons?: true
    entityType?: true
    nodeID?: true
    nodeType?: true
    props?: true
    status?: true
    studyID?: true
    submissionID?: true
    updatedAt?: true
    _all?: true
  }

  export type ReleaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which release to aggregate.
     */
    where?: releaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of releases to fetch.
     */
    orderBy?: releaseOrderByWithRelationInput | releaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: releaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned releases
    **/
    _count?: true | ReleaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReleaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReleaseMaxAggregateInputType
  }

  export type GetReleaseAggregateType<T extends ReleaseAggregateArgs> = {
        [P in keyof T & keyof AggregateRelease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelease[P]>
      : GetScalarType<T[P], AggregateRelease[P]>
  }




  export type releaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: releaseWhereInput
    orderBy?: releaseOrderByWithAggregationInput | releaseOrderByWithAggregationInput[]
    by: ReleaseScalarFieldEnum[] | ReleaseScalarFieldEnum
    having?: releaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReleaseCountAggregateInputType | true
    _min?: ReleaseMinAggregateInputType
    _max?: ReleaseMaxAggregateInputType
  }

  export type ReleaseGroupByOutputType = {
    id: string
    CRDC_ID: string | null
    createdAt: Date
    dataCommons: string
    entityType: string | null
    nodeID: string
    nodeType: string
    props: JsonValue
    status: string
    studyID: string | null
    submissionID: string
    updatedAt: Date | null
    _count: ReleaseCountAggregateOutputType | null
    _min: ReleaseMinAggregateOutputType | null
    _max: ReleaseMaxAggregateOutputType | null
  }

  type GetReleaseGroupByPayload<T extends releaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReleaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReleaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReleaseGroupByOutputType[P]>
            : GetScalarType<T[P], ReleaseGroupByOutputType[P]>
        }
      >
    >


  export type releaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CRDC_ID?: boolean
    createdAt?: boolean
    dataCommons?: boolean
    entityType?: boolean
    nodeID?: boolean
    nodeType?: boolean
    parents?: boolean | ParentDefaultArgs<ExtArgs>
    props?: boolean
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["release"]>



  export type releaseSelectScalar = {
    id?: boolean
    CRDC_ID?: boolean
    createdAt?: boolean
    dataCommons?: boolean
    entityType?: boolean
    nodeID?: boolean
    nodeType?: boolean
    props?: boolean
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    updatedAt?: boolean
  }

  export type releaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "CRDC_ID" | "createdAt" | "dataCommons" | "entityType" | "nodeID" | "nodeType" | "parents" | "props" | "status" | "studyID" | "submissionID" | "updatedAt", ExtArgs["result"]["release"]>
  export type releaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $releasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "release"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      CRDC_ID: string | null
      createdAt: Date
      dataCommons: string
      entityType: string | null
      nodeID: string
      nodeType: string
      props: Prisma.JsonValue
      status: string
      studyID: string | null
      submissionID: string
      updatedAt: Date | null
    }, ExtArgs["result"]["release"]>
    composites: {
      parents: Prisma.$ParentPayload[]
    }
  }

  type releaseGetPayload<S extends boolean | null | undefined | releaseDefaultArgs> = $Result.GetResult<Prisma.$releasePayload, S>

  type releaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<releaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReleaseCountAggregateInputType | true
    }

  export interface releaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['release'], meta: { name: 'release' } }
    /**
     * Find zero or one Release that matches the filter.
     * @param {releaseFindUniqueArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends releaseFindUniqueArgs>(args: SelectSubset<T, releaseFindUniqueArgs<ExtArgs>>): Prisma__releaseClient<$Result.GetResult<Prisma.$releasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Release that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {releaseFindUniqueOrThrowArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends releaseFindUniqueOrThrowArgs>(args: SelectSubset<T, releaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__releaseClient<$Result.GetResult<Prisma.$releasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Release that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {releaseFindFirstArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends releaseFindFirstArgs>(args?: SelectSubset<T, releaseFindFirstArgs<ExtArgs>>): Prisma__releaseClient<$Result.GetResult<Prisma.$releasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Release that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {releaseFindFirstOrThrowArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends releaseFindFirstOrThrowArgs>(args?: SelectSubset<T, releaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__releaseClient<$Result.GetResult<Prisma.$releasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Releases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {releaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Releases
     * const releases = await prisma.release.findMany()
     * 
     * // Get first 10 Releases
     * const releases = await prisma.release.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const releaseWithIdOnly = await prisma.release.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends releaseFindManyArgs>(args?: SelectSubset<T, releaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$releasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Release.
     * @param {releaseCreateArgs} args - Arguments to create a Release.
     * @example
     * // Create one Release
     * const Release = await prisma.release.create({
     *   data: {
     *     // ... data to create a Release
     *   }
     * })
     * 
     */
    create<T extends releaseCreateArgs>(args: SelectSubset<T, releaseCreateArgs<ExtArgs>>): Prisma__releaseClient<$Result.GetResult<Prisma.$releasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Releases.
     * @param {releaseCreateManyArgs} args - Arguments to create many Releases.
     * @example
     * // Create many Releases
     * const release = await prisma.release.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends releaseCreateManyArgs>(args?: SelectSubset<T, releaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Release.
     * @param {releaseDeleteArgs} args - Arguments to delete one Release.
     * @example
     * // Delete one Release
     * const Release = await prisma.release.delete({
     *   where: {
     *     // ... filter to delete one Release
     *   }
     * })
     * 
     */
    delete<T extends releaseDeleteArgs>(args: SelectSubset<T, releaseDeleteArgs<ExtArgs>>): Prisma__releaseClient<$Result.GetResult<Prisma.$releasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Release.
     * @param {releaseUpdateArgs} args - Arguments to update one Release.
     * @example
     * // Update one Release
     * const release = await prisma.release.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends releaseUpdateArgs>(args: SelectSubset<T, releaseUpdateArgs<ExtArgs>>): Prisma__releaseClient<$Result.GetResult<Prisma.$releasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Releases.
     * @param {releaseDeleteManyArgs} args - Arguments to filter Releases to delete.
     * @example
     * // Delete a few Releases
     * const { count } = await prisma.release.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends releaseDeleteManyArgs>(args?: SelectSubset<T, releaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {releaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Releases
     * const release = await prisma.release.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends releaseUpdateManyArgs>(args: SelectSubset<T, releaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Release.
     * @param {releaseUpsertArgs} args - Arguments to update or create a Release.
     * @example
     * // Update or create a Release
     * const release = await prisma.release.upsert({
     *   create: {
     *     // ... data to create a Release
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Release we want to update
     *   }
     * })
     */
    upsert<T extends releaseUpsertArgs>(args: SelectSubset<T, releaseUpsertArgs<ExtArgs>>): Prisma__releaseClient<$Result.GetResult<Prisma.$releasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Releases that matches the filter.
     * @param {releaseFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const release = await prisma.release.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: releaseFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Release.
     * @param {releaseAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const release = await prisma.release.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: releaseAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {releaseCountArgs} args - Arguments to filter Releases to count.
     * @example
     * // Count the number of Releases
     * const count = await prisma.release.count({
     *   where: {
     *     // ... the filter for the Releases we want to count
     *   }
     * })
    **/
    count<T extends releaseCountArgs>(
      args?: Subset<T, releaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReleaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Release.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReleaseAggregateArgs>(args: Subset<T, ReleaseAggregateArgs>): Prisma.PrismaPromise<GetReleaseAggregateType<T>>

    /**
     * Group by Release.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {releaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends releaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: releaseGroupByArgs['orderBy'] }
        : { orderBy?: releaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, releaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReleaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the release model
   */
  readonly fields: releaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for release.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__releaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the release model
   */
  interface releaseFieldRefs {
    readonly id: FieldRef<"release", 'String'>
    readonly CRDC_ID: FieldRef<"release", 'String'>
    readonly createdAt: FieldRef<"release", 'DateTime'>
    readonly dataCommons: FieldRef<"release", 'String'>
    readonly entityType: FieldRef<"release", 'String'>
    readonly nodeID: FieldRef<"release", 'String'>
    readonly nodeType: FieldRef<"release", 'String'>
    readonly props: FieldRef<"release", 'Json'>
    readonly status: FieldRef<"release", 'String'>
    readonly studyID: FieldRef<"release", 'String'>
    readonly submissionID: FieldRef<"release", 'String'>
    readonly updatedAt: FieldRef<"release", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * release findUnique
   */
  export type releaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the release
     */
    select?: releaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the release
     */
    omit?: releaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: releaseInclude<ExtArgs> | null
    /**
     * Filter, which release to fetch.
     */
    where: releaseWhereUniqueInput
  }

  /**
   * release findUniqueOrThrow
   */
  export type releaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the release
     */
    select?: releaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the release
     */
    omit?: releaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: releaseInclude<ExtArgs> | null
    /**
     * Filter, which release to fetch.
     */
    where: releaseWhereUniqueInput
  }

  /**
   * release findFirst
   */
  export type releaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the release
     */
    select?: releaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the release
     */
    omit?: releaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: releaseInclude<ExtArgs> | null
    /**
     * Filter, which release to fetch.
     */
    where?: releaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of releases to fetch.
     */
    orderBy?: releaseOrderByWithRelationInput | releaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for releases.
     */
    cursor?: releaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of releases.
     */
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * release findFirstOrThrow
   */
  export type releaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the release
     */
    select?: releaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the release
     */
    omit?: releaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: releaseInclude<ExtArgs> | null
    /**
     * Filter, which release to fetch.
     */
    where?: releaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of releases to fetch.
     */
    orderBy?: releaseOrderByWithRelationInput | releaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for releases.
     */
    cursor?: releaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of releases.
     */
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * release findMany
   */
  export type releaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the release
     */
    select?: releaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the release
     */
    omit?: releaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: releaseInclude<ExtArgs> | null
    /**
     * Filter, which releases to fetch.
     */
    where?: releaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of releases to fetch.
     */
    orderBy?: releaseOrderByWithRelationInput | releaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing releases.
     */
    cursor?: releaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` releases.
     */
    skip?: number
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * release create
   */
  export type releaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the release
     */
    select?: releaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the release
     */
    omit?: releaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: releaseInclude<ExtArgs> | null
    /**
     * The data needed to create a release.
     */
    data: XOR<releaseCreateInput, releaseUncheckedCreateInput>
  }

  /**
   * release createMany
   */
  export type releaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many releases.
     */
    data: releaseCreateManyInput | releaseCreateManyInput[]
  }

  /**
   * release update
   */
  export type releaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the release
     */
    select?: releaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the release
     */
    omit?: releaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: releaseInclude<ExtArgs> | null
    /**
     * The data needed to update a release.
     */
    data: XOR<releaseUpdateInput, releaseUncheckedUpdateInput>
    /**
     * Choose, which release to update.
     */
    where: releaseWhereUniqueInput
  }

  /**
   * release updateMany
   */
  export type releaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update releases.
     */
    data: XOR<releaseUpdateManyMutationInput, releaseUncheckedUpdateManyInput>
    /**
     * Filter which releases to update
     */
    where?: releaseWhereInput
    /**
     * Limit how many releases to update.
     */
    limit?: number
  }

  /**
   * release upsert
   */
  export type releaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the release
     */
    select?: releaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the release
     */
    omit?: releaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: releaseInclude<ExtArgs> | null
    /**
     * The filter to search for the release to update in case it exists.
     */
    where: releaseWhereUniqueInput
    /**
     * In case the release found by the `where` argument doesn't exist, create a new release with this data.
     */
    create: XOR<releaseCreateInput, releaseUncheckedCreateInput>
    /**
     * In case the release was found with the provided `where` argument, update it with this data.
     */
    update: XOR<releaseUpdateInput, releaseUncheckedUpdateInput>
  }

  /**
   * release delete
   */
  export type releaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the release
     */
    select?: releaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the release
     */
    omit?: releaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: releaseInclude<ExtArgs> | null
    /**
     * Filter which release to delete.
     */
    where: releaseWhereUniqueInput
  }

  /**
   * release deleteMany
   */
  export type releaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which releases to delete
     */
    where?: releaseWhereInput
    /**
     * Limit how many releases to delete.
     */
    limit?: number
  }

  /**
   * release findRaw
   */
  export type releaseFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * release aggregateRaw
   */
  export type releaseAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * release without action
   */
  export type releaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the release
     */
    select?: releaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the release
     */
    omit?: releaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: releaseInclude<ExtArgs> | null
  }


  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsMinAggregateOutputType = {
    id: string | null
    expires: Date | null
    lastModified: Date | null
    session: string | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: string | null
    expires: Date | null
    lastModified: Date | null
    session: string | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    expires: number
    lastModified: number
    session: number
    _all: number
  }


  export type SessionsMinAggregateInputType = {
    id?: true
    expires?: true
    lastModified?: true
    session?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    expires?: true
    lastModified?: true
    session?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    expires?: true
    lastModified?: true
    session?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    id: string
    expires: Date
    lastModified: Date
    session: string
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expires?: boolean
    lastModified?: boolean
    session?: boolean
  }, ExtArgs["result"]["sessions"]>



  export type sessionsSelectScalar = {
    id?: boolean
    expires?: boolean
    lastModified?: boolean
    session?: boolean
  }

  export type sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expires" | "lastModified" | "session", ExtArgs["result"]["sessions"]>

  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expires: Date
      lastModified: Date
      session: string
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionsFindUniqueArgs>(args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionsFindFirstArgs>(args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionsFindManyArgs>(args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends sessionsCreateArgs>(args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionsCreateManyArgs>(args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends sessionsDeleteArgs>(args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionsUpdateArgs>(args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionsDeleteManyArgs>(args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionsUpdateManyArgs>(args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends sessionsUpsertArgs>(args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {sessionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sessions = await prisma.sessions.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: sessionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Sessions.
     * @param {sessionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sessions = await prisma.sessions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: sessionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions model
   */
  interface sessionsFieldRefs {
    readonly id: FieldRef<"sessions", 'String'>
    readonly expires: FieldRef<"sessions", 'DateTime'>
    readonly lastModified: FieldRef<"sessions", 'DateTime'>
    readonly session: FieldRef<"sessions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }

  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
  }

  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }

  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * sessions findRaw
   */
  export type sessionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * sessions aggregateRaw
   */
  export type sessionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
  }


  /**
   * Model submissions
   */

  export type AggregateSubmissions = {
    _count: SubmissionsCountAggregateOutputType | null
    _avg: SubmissionsAvgAggregateOutputType | null
    _sum: SubmissionsSumAggregateOutputType | null
    _min: SubmissionsMinAggregateOutputType | null
    _max: SubmissionsMaxAggregateOutputType | null
  }

  export type SubmissionsAvgAggregateOutputType = {
    nodeCount: number | null
  }

  export type SubmissionsSumAggregateOutputType = {
    nodeCount: number | null
  }

  export type SubmissionsMinAggregateOutputType = {
    id: string | null
    ORCID: string | null
    accessedAt: Date | null
    archived: boolean | null
    bucketName: string | null
    collborators: string | null
    conciergeEmail: string | null
    conciergeName: string | null
    controlledAccess: boolean | null
    createdAt: Date | null
    crossSubmissionStatus: string | null
    dataCommons: string | null
    dataCommonsDisplayName: string | null
    dataType: string | null
    dbGaPID: string | null
    deletingData: boolean | null
    fileValidationStatus: string | null
    finalInactiveReminder: boolean | null
    inactiveReminder: boolean | null
    inactiveReminder_30: boolean | null
    inactiveReminder_60: boolean | null
    inactiveReminder_7: boolean | null
    intention: string | null
    metadataValidationStatus: string | null
    modelVersion: string | null
    name: string | null
    nodeCount: number | null
    reviewComment: string | null
    rootPath: string | null
    status: string | null
    studyAbbreviation: string | null
    studyID: string | null
    submitterID: string | null
    submitterName: string | null
    updatedAt: Date | null
    validationEnded: Date | null
    validationScope: string | null
    validationStarted: Date | null
  }

  export type SubmissionsMaxAggregateOutputType = {
    id: string | null
    ORCID: string | null
    accessedAt: Date | null
    archived: boolean | null
    bucketName: string | null
    collborators: string | null
    conciergeEmail: string | null
    conciergeName: string | null
    controlledAccess: boolean | null
    createdAt: Date | null
    crossSubmissionStatus: string | null
    dataCommons: string | null
    dataCommonsDisplayName: string | null
    dataType: string | null
    dbGaPID: string | null
    deletingData: boolean | null
    fileValidationStatus: string | null
    finalInactiveReminder: boolean | null
    inactiveReminder: boolean | null
    inactiveReminder_30: boolean | null
    inactiveReminder_60: boolean | null
    inactiveReminder_7: boolean | null
    intention: string | null
    metadataValidationStatus: string | null
    modelVersion: string | null
    name: string | null
    nodeCount: number | null
    reviewComment: string | null
    rootPath: string | null
    status: string | null
    studyAbbreviation: string | null
    studyID: string | null
    submitterID: string | null
    submitterName: string | null
    updatedAt: Date | null
    validationEnded: Date | null
    validationScope: string | null
    validationStarted: Date | null
  }

  export type SubmissionsCountAggregateOutputType = {
    id: number
    ORCID: number
    accessedAt: number
    archived: number
    bucketName: number
    collborators: number
    conciergeEmail: number
    conciergeName: number
    controlledAccess: number
    createdAt: number
    crossSubmissionStatus: number
    dataCommons: number
    dataCommonsDisplayName: number
    dataType: number
    dbGaPID: number
    deletingData: number
    fileValidationStatus: number
    finalInactiveReminder: number
    inactiveReminder: number
    inactiveReminder_30: number
    inactiveReminder_60: number
    inactiveReminder_7: number
    intention: number
    metadataValidationStatus: number
    modelVersion: number
    name: number
    nodeCount: number
    reviewComment: number
    rootPath: number
    status: number
    studyAbbreviation: number
    studyID: number
    submitterID: number
    submitterName: number
    updatedAt: number
    validationEnded: number
    validationScope: number
    validationStarted: number
    validationType: number
    _all: number
  }


  export type SubmissionsAvgAggregateInputType = {
    nodeCount?: true
  }

  export type SubmissionsSumAggregateInputType = {
    nodeCount?: true
  }

  export type SubmissionsMinAggregateInputType = {
    id?: true
    ORCID?: true
    accessedAt?: true
    archived?: true
    bucketName?: true
    collborators?: true
    conciergeEmail?: true
    conciergeName?: true
    controlledAccess?: true
    createdAt?: true
    crossSubmissionStatus?: true
    dataCommons?: true
    dataCommonsDisplayName?: true
    dataType?: true
    dbGaPID?: true
    deletingData?: true
    fileValidationStatus?: true
    finalInactiveReminder?: true
    inactiveReminder?: true
    inactiveReminder_30?: true
    inactiveReminder_60?: true
    inactiveReminder_7?: true
    intention?: true
    metadataValidationStatus?: true
    modelVersion?: true
    name?: true
    nodeCount?: true
    reviewComment?: true
    rootPath?: true
    status?: true
    studyAbbreviation?: true
    studyID?: true
    submitterID?: true
    submitterName?: true
    updatedAt?: true
    validationEnded?: true
    validationScope?: true
    validationStarted?: true
  }

  export type SubmissionsMaxAggregateInputType = {
    id?: true
    ORCID?: true
    accessedAt?: true
    archived?: true
    bucketName?: true
    collborators?: true
    conciergeEmail?: true
    conciergeName?: true
    controlledAccess?: true
    createdAt?: true
    crossSubmissionStatus?: true
    dataCommons?: true
    dataCommonsDisplayName?: true
    dataType?: true
    dbGaPID?: true
    deletingData?: true
    fileValidationStatus?: true
    finalInactiveReminder?: true
    inactiveReminder?: true
    inactiveReminder_30?: true
    inactiveReminder_60?: true
    inactiveReminder_7?: true
    intention?: true
    metadataValidationStatus?: true
    modelVersion?: true
    name?: true
    nodeCount?: true
    reviewComment?: true
    rootPath?: true
    status?: true
    studyAbbreviation?: true
    studyID?: true
    submitterID?: true
    submitterName?: true
    updatedAt?: true
    validationEnded?: true
    validationScope?: true
    validationStarted?: true
  }

  export type SubmissionsCountAggregateInputType = {
    id?: true
    ORCID?: true
    accessedAt?: true
    archived?: true
    bucketName?: true
    collborators?: true
    conciergeEmail?: true
    conciergeName?: true
    controlledAccess?: true
    createdAt?: true
    crossSubmissionStatus?: true
    dataCommons?: true
    dataCommonsDisplayName?: true
    dataType?: true
    dbGaPID?: true
    deletingData?: true
    fileValidationStatus?: true
    finalInactiveReminder?: true
    inactiveReminder?: true
    inactiveReminder_30?: true
    inactiveReminder_60?: true
    inactiveReminder_7?: true
    intention?: true
    metadataValidationStatus?: true
    modelVersion?: true
    name?: true
    nodeCount?: true
    reviewComment?: true
    rootPath?: true
    status?: true
    studyAbbreviation?: true
    studyID?: true
    submitterID?: true
    submitterName?: true
    updatedAt?: true
    validationEnded?: true
    validationScope?: true
    validationStarted?: true
    validationType?: true
    _all?: true
  }

  export type SubmissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which submissions to aggregate.
     */
    where?: submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submissions to fetch.
     */
    orderBy?: submissionsOrderByWithRelationInput | submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned submissions
    **/
    _count?: true | SubmissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionsMaxAggregateInputType
  }

  export type GetSubmissionsAggregateType<T extends SubmissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmissions[P]>
      : GetScalarType<T[P], AggregateSubmissions[P]>
  }




  export type submissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: submissionsWhereInput
    orderBy?: submissionsOrderByWithAggregationInput | submissionsOrderByWithAggregationInput[]
    by: SubmissionsScalarFieldEnum[] | SubmissionsScalarFieldEnum
    having?: submissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionsCountAggregateInputType | true
    _avg?: SubmissionsAvgAggregateInputType
    _sum?: SubmissionsSumAggregateInputType
    _min?: SubmissionsMinAggregateInputType
    _max?: SubmissionsMaxAggregateInputType
  }

  export type SubmissionsGroupByOutputType = {
    id: string
    ORCID: string | null
    accessedAt: Date
    archived: boolean | null
    bucketName: string
    collborators: string | null
    conciergeEmail: string | null
    conciergeName: string | null
    controlledAccess: boolean | null
    createdAt: Date
    crossSubmissionStatus: string | null
    dataCommons: string
    dataCommonsDisplayName: string | null
    dataType: string
    dbGaPID: string | null
    deletingData: boolean | null
    fileValidationStatus: string | null
    finalInactiveReminder: boolean | null
    inactiveReminder: boolean | null
    inactiveReminder_30: boolean | null
    inactiveReminder_60: boolean | null
    inactiveReminder_7: boolean | null
    intention: string
    metadataValidationStatus: string | null
    modelVersion: string
    name: string
    nodeCount: number | null
    reviewComment: string | null
    rootPath: string
    status: string
    studyAbbreviation: string | null
    studyID: string
    submitterID: string
    submitterName: string
    updatedAt: Date
    validationEnded: Date | null
    validationScope: string | null
    validationStarted: Date | null
    validationType: string[]
    _count: SubmissionsCountAggregateOutputType | null
    _avg: SubmissionsAvgAggregateOutputType | null
    _sum: SubmissionsSumAggregateOutputType | null
    _min: SubmissionsMinAggregateOutputType | null
    _max: SubmissionsMaxAggregateOutputType | null
  }

  type GetSubmissionsGroupByPayload<T extends submissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionsGroupByOutputType[P]>
        }
      >
    >


  export type submissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ORCID?: boolean
    accessedAt?: boolean
    archived?: boolean
    bucketName?: boolean
    collaborators?: boolean | CollaboratorDefaultArgs<ExtArgs>
    collborators?: boolean
    conciergeEmail?: boolean
    conciergeName?: boolean
    controlledAccess?: boolean
    createdAt?: boolean
    crossSubmissionStatus?: boolean
    dataCommons?: boolean
    dataCommonsDisplayName?: boolean
    dataFileSize?: boolean | DataFileSizeDefaultArgs<ExtArgs>
    dataType?: boolean
    dbGaPID?: boolean
    deletingData?: boolean
    fileValidationStatus?: boolean
    finalInactiveReminder?: boolean
    history?: boolean | HistoryDefaultArgs<ExtArgs>
    inactiveReminder?: boolean
    inactiveReminder_30?: boolean
    inactiveReminder_60?: boolean
    inactiveReminder_7?: boolean
    intention?: boolean
    metadataValidationStatus?: boolean
    modelVersion?: boolean
    name?: boolean
    nodeCount?: boolean
    organization?: boolean | OrgInfoDefaultArgs<ExtArgs>
    reviewComment?: boolean
    rootPath?: boolean
    status?: boolean
    studyAbbreviation?: boolean
    studyID?: boolean
    submitterID?: boolean
    submitterName?: boolean
    updatedAt?: boolean
    validationEnded?: boolean
    validationScope?: boolean
    validationStarted?: boolean
    validationType?: boolean
  }, ExtArgs["result"]["submissions"]>



  export type submissionsSelectScalar = {
    id?: boolean
    ORCID?: boolean
    accessedAt?: boolean
    archived?: boolean
    bucketName?: boolean
    collborators?: boolean
    conciergeEmail?: boolean
    conciergeName?: boolean
    controlledAccess?: boolean
    createdAt?: boolean
    crossSubmissionStatus?: boolean
    dataCommons?: boolean
    dataCommonsDisplayName?: boolean
    dataType?: boolean
    dbGaPID?: boolean
    deletingData?: boolean
    fileValidationStatus?: boolean
    finalInactiveReminder?: boolean
    inactiveReminder?: boolean
    inactiveReminder_30?: boolean
    inactiveReminder_60?: boolean
    inactiveReminder_7?: boolean
    intention?: boolean
    metadataValidationStatus?: boolean
    modelVersion?: boolean
    name?: boolean
    nodeCount?: boolean
    reviewComment?: boolean
    rootPath?: boolean
    status?: boolean
    studyAbbreviation?: boolean
    studyID?: boolean
    submitterID?: boolean
    submitterName?: boolean
    updatedAt?: boolean
    validationEnded?: boolean
    validationScope?: boolean
    validationStarted?: boolean
    validationType?: boolean
  }

  export type submissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ORCID" | "accessedAt" | "archived" | "bucketName" | "collaborators" | "collborators" | "conciergeEmail" | "conciergeName" | "controlledAccess" | "createdAt" | "crossSubmissionStatus" | "dataCommons" | "dataCommonsDisplayName" | "dataFileSize" | "dataType" | "dbGaPID" | "deletingData" | "fileValidationStatus" | "finalInactiveReminder" | "history" | "inactiveReminder" | "inactiveReminder_30" | "inactiveReminder_60" | "inactiveReminder_7" | "intention" | "metadataValidationStatus" | "modelVersion" | "name" | "nodeCount" | "organization" | "reviewComment" | "rootPath" | "status" | "studyAbbreviation" | "studyID" | "submitterID" | "submitterName" | "updatedAt" | "validationEnded" | "validationScope" | "validationStarted" | "validationType", ExtArgs["result"]["submissions"]>
  export type submissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $submissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "submissions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ORCID: string | null
      accessedAt: Date
      archived: boolean | null
      bucketName: string
      collborators: string | null
      conciergeEmail: string | null
      conciergeName: string | null
      controlledAccess: boolean | null
      createdAt: Date
      /**
       * Multiple data types found: String: 92.9%, Boolean: 7.1% out of 375 sampled entries
       */
      crossSubmissionStatus: string | null
      dataCommons: string
      dataCommonsDisplayName: string | null
      dataType: string
      dbGaPID: string | null
      deletingData: boolean | null
      /**
       * Multiple data types found: String: 98.5%, Boolean: 1.5% out of 375 sampled entries
       */
      fileValidationStatus: string | null
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      finalInactiveReminder: boolean | null
      inactiveReminder: boolean | null
      inactiveReminder_30: boolean | null
      inactiveReminder_60: boolean | null
      inactiveReminder_7: boolean | null
      intention: string
      /**
       * Multiple data types found: String: 99.5%, Boolean: 0.5% out of 375 sampled entries
       */
      metadataValidationStatus: string | null
      modelVersion: string
      name: string
      nodeCount: number | null
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      reviewComment: string | null
      rootPath: string
      status: string
      studyAbbreviation: string | null
      studyID: string
      submitterID: string
      submitterName: string
      updatedAt: Date
      validationEnded: Date | null
      validationScope: string | null
      validationStarted: Date | null
      validationType: string[]
    }, ExtArgs["result"]["submissions"]>
    composites: {
      collaborators: Prisma.$CollaboratorPayload[]
      dataFileSize: Prisma.$DataFileSizePayload
      history: Prisma.$HistoryPayload[]
      organization: Prisma.$OrgInfoPayload
    }
  }

  type submissionsGetPayload<S extends boolean | null | undefined | submissionsDefaultArgs> = $Result.GetResult<Prisma.$submissionsPayload, S>

  type submissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<submissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubmissionsCountAggregateInputType | true
    }

  export interface submissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['submissions'], meta: { name: 'submissions' } }
    /**
     * Find zero or one Submissions that matches the filter.
     * @param {submissionsFindUniqueArgs} args - Arguments to find a Submissions
     * @example
     * // Get one Submissions
     * const submissions = await prisma.submissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends submissionsFindUniqueArgs>(args: SelectSubset<T, submissionsFindUniqueArgs<ExtArgs>>): Prisma__submissionsClient<$Result.GetResult<Prisma.$submissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Submissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {submissionsFindUniqueOrThrowArgs} args - Arguments to find a Submissions
     * @example
     * // Get one Submissions
     * const submissions = await prisma.submissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends submissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, submissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__submissionsClient<$Result.GetResult<Prisma.$submissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionsFindFirstArgs} args - Arguments to find a Submissions
     * @example
     * // Get one Submissions
     * const submissions = await prisma.submissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends submissionsFindFirstArgs>(args?: SelectSubset<T, submissionsFindFirstArgs<ExtArgs>>): Prisma__submissionsClient<$Result.GetResult<Prisma.$submissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Submissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionsFindFirstOrThrowArgs} args - Arguments to find a Submissions
     * @example
     * // Get one Submissions
     * const submissions = await prisma.submissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends submissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, submissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__submissionsClient<$Result.GetResult<Prisma.$submissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submissions
     * const submissions = await prisma.submissions.findMany()
     * 
     * // Get first 10 Submissions
     * const submissions = await prisma.submissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionsWithIdOnly = await prisma.submissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends submissionsFindManyArgs>(args?: SelectSubset<T, submissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$submissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Submissions.
     * @param {submissionsCreateArgs} args - Arguments to create a Submissions.
     * @example
     * // Create one Submissions
     * const Submissions = await prisma.submissions.create({
     *   data: {
     *     // ... data to create a Submissions
     *   }
     * })
     * 
     */
    create<T extends submissionsCreateArgs>(args: SelectSubset<T, submissionsCreateArgs<ExtArgs>>): Prisma__submissionsClient<$Result.GetResult<Prisma.$submissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Submissions.
     * @param {submissionsCreateManyArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submissions = await prisma.submissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends submissionsCreateManyArgs>(args?: SelectSubset<T, submissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Submissions.
     * @param {submissionsDeleteArgs} args - Arguments to delete one Submissions.
     * @example
     * // Delete one Submissions
     * const Submissions = await prisma.submissions.delete({
     *   where: {
     *     // ... filter to delete one Submissions
     *   }
     * })
     * 
     */
    delete<T extends submissionsDeleteArgs>(args: SelectSubset<T, submissionsDeleteArgs<ExtArgs>>): Prisma__submissionsClient<$Result.GetResult<Prisma.$submissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Submissions.
     * @param {submissionsUpdateArgs} args - Arguments to update one Submissions.
     * @example
     * // Update one Submissions
     * const submissions = await prisma.submissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends submissionsUpdateArgs>(args: SelectSubset<T, submissionsUpdateArgs<ExtArgs>>): Prisma__submissionsClient<$Result.GetResult<Prisma.$submissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Submissions.
     * @param {submissionsDeleteManyArgs} args - Arguments to filter Submissions to delete.
     * @example
     * // Delete a few Submissions
     * const { count } = await prisma.submissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends submissionsDeleteManyArgs>(args?: SelectSubset<T, submissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submissions
     * const submissions = await prisma.submissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends submissionsUpdateManyArgs>(args: SelectSubset<T, submissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Submissions.
     * @param {submissionsUpsertArgs} args - Arguments to update or create a Submissions.
     * @example
     * // Update or create a Submissions
     * const submissions = await prisma.submissions.upsert({
     *   create: {
     *     // ... data to create a Submissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submissions we want to update
     *   }
     * })
     */
    upsert<T extends submissionsUpsertArgs>(args: SelectSubset<T, submissionsUpsertArgs<ExtArgs>>): Prisma__submissionsClient<$Result.GetResult<Prisma.$submissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Submissions that matches the filter.
     * @param {submissionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const submissions = await prisma.submissions.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: submissionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Submissions.
     * @param {submissionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const submissions = await prisma.submissions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: submissionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionsCountArgs} args - Arguments to filter Submissions to count.
     * @example
     * // Count the number of Submissions
     * const count = await prisma.submissions.count({
     *   where: {
     *     // ... the filter for the Submissions we want to count
     *   }
     * })
    **/
    count<T extends submissionsCountArgs>(
      args?: Subset<T, submissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionsAggregateArgs>(args: Subset<T, SubmissionsAggregateArgs>): Prisma.PrismaPromise<GetSubmissionsAggregateType<T>>

    /**
     * Group by Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {submissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends submissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: submissionsGroupByArgs['orderBy'] }
        : { orderBy?: submissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, submissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the submissions model
   */
  readonly fields: submissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for submissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__submissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the submissions model
   */
  interface submissionsFieldRefs {
    readonly id: FieldRef<"submissions", 'String'>
    readonly ORCID: FieldRef<"submissions", 'String'>
    readonly accessedAt: FieldRef<"submissions", 'DateTime'>
    readonly archived: FieldRef<"submissions", 'Boolean'>
    readonly bucketName: FieldRef<"submissions", 'String'>
    readonly collborators: FieldRef<"submissions", 'String'>
    readonly conciergeEmail: FieldRef<"submissions", 'String'>
    readonly conciergeName: FieldRef<"submissions", 'String'>
    readonly controlledAccess: FieldRef<"submissions", 'Boolean'>
    readonly createdAt: FieldRef<"submissions", 'DateTime'>
    readonly crossSubmissionStatus: FieldRef<"submissions", 'String'>
    readonly dataCommons: FieldRef<"submissions", 'String'>
    readonly dataCommonsDisplayName: FieldRef<"submissions", 'String'>
    readonly dataType: FieldRef<"submissions", 'String'>
    readonly dbGaPID: FieldRef<"submissions", 'String'>
    readonly deletingData: FieldRef<"submissions", 'Boolean'>
    readonly fileValidationStatus: FieldRef<"submissions", 'String'>
    readonly finalInactiveReminder: FieldRef<"submissions", 'Boolean'>
    readonly inactiveReminder: FieldRef<"submissions", 'Boolean'>
    readonly inactiveReminder_30: FieldRef<"submissions", 'Boolean'>
    readonly inactiveReminder_60: FieldRef<"submissions", 'Boolean'>
    readonly inactiveReminder_7: FieldRef<"submissions", 'Boolean'>
    readonly intention: FieldRef<"submissions", 'String'>
    readonly metadataValidationStatus: FieldRef<"submissions", 'String'>
    readonly modelVersion: FieldRef<"submissions", 'String'>
    readonly name: FieldRef<"submissions", 'String'>
    readonly nodeCount: FieldRef<"submissions", 'Int'>
    readonly reviewComment: FieldRef<"submissions", 'String'>
    readonly rootPath: FieldRef<"submissions", 'String'>
    readonly status: FieldRef<"submissions", 'String'>
    readonly studyAbbreviation: FieldRef<"submissions", 'String'>
    readonly studyID: FieldRef<"submissions", 'String'>
    readonly submitterID: FieldRef<"submissions", 'String'>
    readonly submitterName: FieldRef<"submissions", 'String'>
    readonly updatedAt: FieldRef<"submissions", 'DateTime'>
    readonly validationEnded: FieldRef<"submissions", 'DateTime'>
    readonly validationScope: FieldRef<"submissions", 'String'>
    readonly validationStarted: FieldRef<"submissions", 'DateTime'>
    readonly validationType: FieldRef<"submissions", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * submissions findUnique
   */
  export type submissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submissions
     */
    select?: submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the submissions
     */
    omit?: submissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: submissionsInclude<ExtArgs> | null
    /**
     * Filter, which submissions to fetch.
     */
    where: submissionsWhereUniqueInput
  }

  /**
   * submissions findUniqueOrThrow
   */
  export type submissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submissions
     */
    select?: submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the submissions
     */
    omit?: submissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: submissionsInclude<ExtArgs> | null
    /**
     * Filter, which submissions to fetch.
     */
    where: submissionsWhereUniqueInput
  }

  /**
   * submissions findFirst
   */
  export type submissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submissions
     */
    select?: submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the submissions
     */
    omit?: submissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: submissionsInclude<ExtArgs> | null
    /**
     * Filter, which submissions to fetch.
     */
    where?: submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submissions to fetch.
     */
    orderBy?: submissionsOrderByWithRelationInput | submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for submissions.
     */
    cursor?: submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of submissions.
     */
    distinct?: SubmissionsScalarFieldEnum | SubmissionsScalarFieldEnum[]
  }

  /**
   * submissions findFirstOrThrow
   */
  export type submissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submissions
     */
    select?: submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the submissions
     */
    omit?: submissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: submissionsInclude<ExtArgs> | null
    /**
     * Filter, which submissions to fetch.
     */
    where?: submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submissions to fetch.
     */
    orderBy?: submissionsOrderByWithRelationInput | submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for submissions.
     */
    cursor?: submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of submissions.
     */
    distinct?: SubmissionsScalarFieldEnum | SubmissionsScalarFieldEnum[]
  }

  /**
   * submissions findMany
   */
  export type submissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submissions
     */
    select?: submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the submissions
     */
    omit?: submissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: submissionsInclude<ExtArgs> | null
    /**
     * Filter, which submissions to fetch.
     */
    where?: submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of submissions to fetch.
     */
    orderBy?: submissionsOrderByWithRelationInput | submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing submissions.
     */
    cursor?: submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` submissions.
     */
    skip?: number
    distinct?: SubmissionsScalarFieldEnum | SubmissionsScalarFieldEnum[]
  }

  /**
   * submissions create
   */
  export type submissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submissions
     */
    select?: submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the submissions
     */
    omit?: submissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: submissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a submissions.
     */
    data: XOR<submissionsCreateInput, submissionsUncheckedCreateInput>
  }

  /**
   * submissions createMany
   */
  export type submissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many submissions.
     */
    data: submissionsCreateManyInput | submissionsCreateManyInput[]
  }

  /**
   * submissions update
   */
  export type submissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submissions
     */
    select?: submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the submissions
     */
    omit?: submissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: submissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a submissions.
     */
    data: XOR<submissionsUpdateInput, submissionsUncheckedUpdateInput>
    /**
     * Choose, which submissions to update.
     */
    where: submissionsWhereUniqueInput
  }

  /**
   * submissions updateMany
   */
  export type submissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update submissions.
     */
    data: XOR<submissionsUpdateManyMutationInput, submissionsUncheckedUpdateManyInput>
    /**
     * Filter which submissions to update
     */
    where?: submissionsWhereInput
    /**
     * Limit how many submissions to update.
     */
    limit?: number
  }

  /**
   * submissions upsert
   */
  export type submissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submissions
     */
    select?: submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the submissions
     */
    omit?: submissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: submissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the submissions to update in case it exists.
     */
    where: submissionsWhereUniqueInput
    /**
     * In case the submissions found by the `where` argument doesn't exist, create a new submissions with this data.
     */
    create: XOR<submissionsCreateInput, submissionsUncheckedCreateInput>
    /**
     * In case the submissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<submissionsUpdateInput, submissionsUncheckedUpdateInput>
  }

  /**
   * submissions delete
   */
  export type submissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submissions
     */
    select?: submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the submissions
     */
    omit?: submissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: submissionsInclude<ExtArgs> | null
    /**
     * Filter which submissions to delete.
     */
    where: submissionsWhereUniqueInput
  }

  /**
   * submissions deleteMany
   */
  export type submissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which submissions to delete
     */
    where?: submissionsWhereInput
    /**
     * Limit how many submissions to delete.
     */
    limit?: number
  }

  /**
   * submissions findRaw
   */
  export type submissionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * submissions aggregateRaw
   */
  export type submissionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * submissions without action
   */
  export type submissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the submissions
     */
    select?: submissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the submissions
     */
    omit?: submissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: submissionsInclude<ExtArgs> | null
  }


  /**
   * Model synonyms
   */

  export type AggregateSynonyms = {
    _count: SynonymsCountAggregateOutputType | null
    _min: SynonymsMinAggregateOutputType | null
    _max: SynonymsMaxAggregateOutputType | null
  }

  export type SynonymsMinAggregateOutputType = {
    equivalent_term: string | null
    synonym_term: string | null
  }

  export type SynonymsMaxAggregateOutputType = {
    equivalent_term: string | null
    synonym_term: string | null
  }

  export type SynonymsCountAggregateOutputType = {
    id: number
    equivalent_term: number
    synonym_term: number
    _all: number
  }


  export type SynonymsMinAggregateInputType = {
    equivalent_term?: true
    synonym_term?: true
  }

  export type SynonymsMaxAggregateInputType = {
    equivalent_term?: true
    synonym_term?: true
  }

  export type SynonymsCountAggregateInputType = {
    id?: true
    equivalent_term?: true
    synonym_term?: true
    _all?: true
  }

  export type SynonymsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which synonyms to aggregate.
     */
    where?: synonymsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of synonyms to fetch.
     */
    orderBy?: synonymsOrderByWithRelationInput | synonymsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: synonymsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` synonyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` synonyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned synonyms
    **/
    _count?: true | SynonymsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SynonymsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SynonymsMaxAggregateInputType
  }

  export type GetSynonymsAggregateType<T extends SynonymsAggregateArgs> = {
        [P in keyof T & keyof AggregateSynonyms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSynonyms[P]>
      : GetScalarType<T[P], AggregateSynonyms[P]>
  }




  export type synonymsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: synonymsWhereInput
    orderBy?: synonymsOrderByWithAggregationInput | synonymsOrderByWithAggregationInput[]
    by: SynonymsScalarFieldEnum[] | SynonymsScalarFieldEnum
    having?: synonymsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SynonymsCountAggregateInputType | true
    _min?: SynonymsMinAggregateInputType
    _max?: SynonymsMaxAggregateInputType
  }

  export type SynonymsGroupByOutputType = {
    id: JsonValue
    equivalent_term: string
    synonym_term: string
    _count: SynonymsCountAggregateOutputType | null
    _min: SynonymsMinAggregateOutputType | null
    _max: SynonymsMaxAggregateOutputType | null
  }

  type GetSynonymsGroupByPayload<T extends synonymsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SynonymsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SynonymsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SynonymsGroupByOutputType[P]>
            : GetScalarType<T[P], SynonymsGroupByOutputType[P]>
        }
      >
    >


  export type synonymsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equivalent_term?: boolean
    synonym_term?: boolean
  }, ExtArgs["result"]["synonyms"]>



  export type synonymsSelectScalar = {
    id?: boolean
    equivalent_term?: boolean
    synonym_term?: boolean
  }

  export type synonymsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equivalent_term" | "synonym_term", ExtArgs["result"]["synonyms"]>

  export type $synonymsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "synonyms"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      /**
       * Multiple data types found: String: 47.5%, String (ObjectId): 52.5% out of 1000 sampled entries
       */
      id: Prisma.JsonValue
      equivalent_term: string
      synonym_term: string
    }, ExtArgs["result"]["synonyms"]>
    composites: {}
  }

  type synonymsGetPayload<S extends boolean | null | undefined | synonymsDefaultArgs> = $Result.GetResult<Prisma.$synonymsPayload, S>

  type synonymsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<synonymsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SynonymsCountAggregateInputType | true
    }

  export interface synonymsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['synonyms'], meta: { name: 'synonyms' } }
    /**
     * Find zero or one Synonyms that matches the filter.
     * @param {synonymsFindUniqueArgs} args - Arguments to find a Synonyms
     * @example
     * // Get one Synonyms
     * const synonyms = await prisma.synonyms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends synonymsFindUniqueArgs>(args: SelectSubset<T, synonymsFindUniqueArgs<ExtArgs>>): Prisma__synonymsClient<$Result.GetResult<Prisma.$synonymsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Synonyms that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {synonymsFindUniqueOrThrowArgs} args - Arguments to find a Synonyms
     * @example
     * // Get one Synonyms
     * const synonyms = await prisma.synonyms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends synonymsFindUniqueOrThrowArgs>(args: SelectSubset<T, synonymsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__synonymsClient<$Result.GetResult<Prisma.$synonymsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Synonyms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {synonymsFindFirstArgs} args - Arguments to find a Synonyms
     * @example
     * // Get one Synonyms
     * const synonyms = await prisma.synonyms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends synonymsFindFirstArgs>(args?: SelectSubset<T, synonymsFindFirstArgs<ExtArgs>>): Prisma__synonymsClient<$Result.GetResult<Prisma.$synonymsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Synonyms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {synonymsFindFirstOrThrowArgs} args - Arguments to find a Synonyms
     * @example
     * // Get one Synonyms
     * const synonyms = await prisma.synonyms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends synonymsFindFirstOrThrowArgs>(args?: SelectSubset<T, synonymsFindFirstOrThrowArgs<ExtArgs>>): Prisma__synonymsClient<$Result.GetResult<Prisma.$synonymsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Synonyms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {synonymsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Synonyms
     * const synonyms = await prisma.synonyms.findMany()
     * 
     * // Get first 10 Synonyms
     * const synonyms = await prisma.synonyms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const synonymsWithIdOnly = await prisma.synonyms.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends synonymsFindManyArgs>(args?: SelectSubset<T, synonymsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$synonymsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Synonyms.
     * @param {synonymsCreateArgs} args - Arguments to create a Synonyms.
     * @example
     * // Create one Synonyms
     * const Synonyms = await prisma.synonyms.create({
     *   data: {
     *     // ... data to create a Synonyms
     *   }
     * })
     * 
     */
    create<T extends synonymsCreateArgs>(args: SelectSubset<T, synonymsCreateArgs<ExtArgs>>): Prisma__synonymsClient<$Result.GetResult<Prisma.$synonymsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Synonyms.
     * @param {synonymsCreateManyArgs} args - Arguments to create many Synonyms.
     * @example
     * // Create many Synonyms
     * const synonyms = await prisma.synonyms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends synonymsCreateManyArgs>(args?: SelectSubset<T, synonymsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Synonyms.
     * @param {synonymsDeleteArgs} args - Arguments to delete one Synonyms.
     * @example
     * // Delete one Synonyms
     * const Synonyms = await prisma.synonyms.delete({
     *   where: {
     *     // ... filter to delete one Synonyms
     *   }
     * })
     * 
     */
    delete<T extends synonymsDeleteArgs>(args: SelectSubset<T, synonymsDeleteArgs<ExtArgs>>): Prisma__synonymsClient<$Result.GetResult<Prisma.$synonymsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Synonyms.
     * @param {synonymsUpdateArgs} args - Arguments to update one Synonyms.
     * @example
     * // Update one Synonyms
     * const synonyms = await prisma.synonyms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends synonymsUpdateArgs>(args: SelectSubset<T, synonymsUpdateArgs<ExtArgs>>): Prisma__synonymsClient<$Result.GetResult<Prisma.$synonymsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Synonyms.
     * @param {synonymsDeleteManyArgs} args - Arguments to filter Synonyms to delete.
     * @example
     * // Delete a few Synonyms
     * const { count } = await prisma.synonyms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends synonymsDeleteManyArgs>(args?: SelectSubset<T, synonymsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Synonyms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {synonymsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Synonyms
     * const synonyms = await prisma.synonyms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends synonymsUpdateManyArgs>(args: SelectSubset<T, synonymsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Synonyms.
     * @param {synonymsUpsertArgs} args - Arguments to update or create a Synonyms.
     * @example
     * // Update or create a Synonyms
     * const synonyms = await prisma.synonyms.upsert({
     *   create: {
     *     // ... data to create a Synonyms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Synonyms we want to update
     *   }
     * })
     */
    upsert<T extends synonymsUpsertArgs>(args: SelectSubset<T, synonymsUpsertArgs<ExtArgs>>): Prisma__synonymsClient<$Result.GetResult<Prisma.$synonymsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Synonyms that matches the filter.
     * @param {synonymsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const synonyms = await prisma.synonyms.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: synonymsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Synonyms.
     * @param {synonymsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const synonyms = await prisma.synonyms.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: synonymsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Synonyms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {synonymsCountArgs} args - Arguments to filter Synonyms to count.
     * @example
     * // Count the number of Synonyms
     * const count = await prisma.synonyms.count({
     *   where: {
     *     // ... the filter for the Synonyms we want to count
     *   }
     * })
    **/
    count<T extends synonymsCountArgs>(
      args?: Subset<T, synonymsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SynonymsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Synonyms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SynonymsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SynonymsAggregateArgs>(args: Subset<T, SynonymsAggregateArgs>): Prisma.PrismaPromise<GetSynonymsAggregateType<T>>

    /**
     * Group by Synonyms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {synonymsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends synonymsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: synonymsGroupByArgs['orderBy'] }
        : { orderBy?: synonymsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, synonymsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSynonymsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the synonyms model
   */
  readonly fields: synonymsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for synonyms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__synonymsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the synonyms model
   */
  interface synonymsFieldRefs {
    readonly id: FieldRef<"synonyms", 'Json'>
    readonly equivalent_term: FieldRef<"synonyms", 'String'>
    readonly synonym_term: FieldRef<"synonyms", 'String'>
  }
    

  // Custom InputTypes
  /**
   * synonyms findUnique
   */
  export type synonymsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the synonyms
     */
    select?: synonymsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the synonyms
     */
    omit?: synonymsOmit<ExtArgs> | null
    /**
     * Filter, which synonyms to fetch.
     */
    where: synonymsWhereUniqueInput
  }

  /**
   * synonyms findUniqueOrThrow
   */
  export type synonymsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the synonyms
     */
    select?: synonymsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the synonyms
     */
    omit?: synonymsOmit<ExtArgs> | null
    /**
     * Filter, which synonyms to fetch.
     */
    where: synonymsWhereUniqueInput
  }

  /**
   * synonyms findFirst
   */
  export type synonymsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the synonyms
     */
    select?: synonymsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the synonyms
     */
    omit?: synonymsOmit<ExtArgs> | null
    /**
     * Filter, which synonyms to fetch.
     */
    where?: synonymsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of synonyms to fetch.
     */
    orderBy?: synonymsOrderByWithRelationInput | synonymsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for synonyms.
     */
    cursor?: synonymsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` synonyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` synonyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of synonyms.
     */
    distinct?: SynonymsScalarFieldEnum | SynonymsScalarFieldEnum[]
  }

  /**
   * synonyms findFirstOrThrow
   */
  export type synonymsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the synonyms
     */
    select?: synonymsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the synonyms
     */
    omit?: synonymsOmit<ExtArgs> | null
    /**
     * Filter, which synonyms to fetch.
     */
    where?: synonymsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of synonyms to fetch.
     */
    orderBy?: synonymsOrderByWithRelationInput | synonymsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for synonyms.
     */
    cursor?: synonymsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` synonyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` synonyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of synonyms.
     */
    distinct?: SynonymsScalarFieldEnum | SynonymsScalarFieldEnum[]
  }

  /**
   * synonyms findMany
   */
  export type synonymsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the synonyms
     */
    select?: synonymsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the synonyms
     */
    omit?: synonymsOmit<ExtArgs> | null
    /**
     * Filter, which synonyms to fetch.
     */
    where?: synonymsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of synonyms to fetch.
     */
    orderBy?: synonymsOrderByWithRelationInput | synonymsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing synonyms.
     */
    cursor?: synonymsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` synonyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` synonyms.
     */
    skip?: number
    distinct?: SynonymsScalarFieldEnum | SynonymsScalarFieldEnum[]
  }

  /**
   * synonyms create
   */
  export type synonymsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the synonyms
     */
    select?: synonymsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the synonyms
     */
    omit?: synonymsOmit<ExtArgs> | null
    /**
     * The data needed to create a synonyms.
     */
    data: XOR<synonymsCreateInput, synonymsUncheckedCreateInput>
  }

  /**
   * synonyms createMany
   */
  export type synonymsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many synonyms.
     */
    data: synonymsCreateManyInput | synonymsCreateManyInput[]
  }

  /**
   * synonyms update
   */
  export type synonymsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the synonyms
     */
    select?: synonymsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the synonyms
     */
    omit?: synonymsOmit<ExtArgs> | null
    /**
     * The data needed to update a synonyms.
     */
    data: XOR<synonymsUpdateInput, synonymsUncheckedUpdateInput>
    /**
     * Choose, which synonyms to update.
     */
    where: synonymsWhereUniqueInput
  }

  /**
   * synonyms updateMany
   */
  export type synonymsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update synonyms.
     */
    data: XOR<synonymsUpdateManyMutationInput, synonymsUncheckedUpdateManyInput>
    /**
     * Filter which synonyms to update
     */
    where?: synonymsWhereInput
    /**
     * Limit how many synonyms to update.
     */
    limit?: number
  }

  /**
   * synonyms upsert
   */
  export type synonymsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the synonyms
     */
    select?: synonymsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the synonyms
     */
    omit?: synonymsOmit<ExtArgs> | null
    /**
     * The filter to search for the synonyms to update in case it exists.
     */
    where: synonymsWhereUniqueInput
    /**
     * In case the synonyms found by the `where` argument doesn't exist, create a new synonyms with this data.
     */
    create: XOR<synonymsCreateInput, synonymsUncheckedCreateInput>
    /**
     * In case the synonyms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<synonymsUpdateInput, synonymsUncheckedUpdateInput>
  }

  /**
   * synonyms delete
   */
  export type synonymsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the synonyms
     */
    select?: synonymsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the synonyms
     */
    omit?: synonymsOmit<ExtArgs> | null
    /**
     * Filter which synonyms to delete.
     */
    where: synonymsWhereUniqueInput
  }

  /**
   * synonyms deleteMany
   */
  export type synonymsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which synonyms to delete
     */
    where?: synonymsWhereInput
    /**
     * Limit how many synonyms to delete.
     */
    limit?: number
  }

  /**
   * synonyms findRaw
   */
  export type synonymsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * synonyms aggregateRaw
   */
  export type synonymsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * synonyms without action
   */
  export type synonymsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the synonyms
     */
    select?: synonymsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the synonyms
     */
    omit?: synonymsOmit<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    IDP: string | null
    createdAt: Date | null
    email: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    status: string | null
    updateAt: Date | null
    userStatus: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    IDP: string | null
    createdAt: Date | null
    email: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    status: string | null
    updateAt: Date | null
    userStatus: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    IDP: number
    createdAt: number
    dataCommons: number
    email: number
    firstName: number
    lastName: number
    notifications: number
    permissions: number
    role: number
    status: number
    tokens: number
    updateAt: number
    userStatus: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    IDP?: true
    createdAt?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    updateAt?: true
    userStatus?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    IDP?: true
    createdAt?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    updateAt?: true
    userStatus?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    IDP?: true
    createdAt?: true
    dataCommons?: true
    email?: true
    firstName?: true
    lastName?: true
    notifications?: true
    permissions?: true
    role?: true
    status?: true
    tokens?: true
    updateAt?: true
    userStatus?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    IDP: string
    createdAt: Date
    dataCommons: string[]
    email: string
    firstName: string
    lastName: string
    notifications: string[]
    permissions: string[]
    role: string
    status: string | null
    tokens: string[]
    updateAt: Date
    userStatus: string
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    IDP?: boolean
    createdAt?: boolean
    dataCommons?: boolean
    email?: boolean
    firstName?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    lastName?: boolean
    notifications?: boolean
    organization?: boolean | OrgInfoDefaultArgs<ExtArgs>
    permissions?: boolean
    role?: boolean
    status?: boolean
    studies?: boolean | StudyByIDDefaultArgs<ExtArgs>
    tokens?: boolean
    updateAt?: boolean
    userStatus?: boolean
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    id?: boolean
    IDP?: boolean
    createdAt?: boolean
    dataCommons?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    notifications?: boolean
    permissions?: boolean
    role?: boolean
    status?: boolean
    tokens?: boolean
    updateAt?: boolean
    userStatus?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "IDP" | "createdAt" | "dataCommons" | "email" | "firstName" | "institution" | "lastName" | "notifications" | "organization" | "permissions" | "role" | "status" | "studies" | "tokens" | "updateAt" | "userStatus", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      IDP: string
      /**
       * Multiple data types found: String: 14.6%, DateTime (Date): 85.4% out of 48 sampled entries
       */
      createdAt: Date
      dataCommons: string[]
      email: string
      firstName: string
      lastName: string
      notifications: string[]
      permissions: string[]
      role: string
      status: string | null
      tokens: string[]
      /**
       * Multiple data types found: String: 2.1%, DateTime (Date): 97.9% out of 48 sampled entries
       */
      updateAt: Date
      userStatus: string
    }, ExtArgs["result"]["users"]>
    composites: {
      institution: Prisma.$InstitutionPayload | null
      organization: Prisma.$OrgInfoPayload | null
      studies: Prisma.$StudyByIDPayload[]
    }
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {usersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const users = await prisma.users.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: usersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Users.
     * @param {usersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const users = await prisma.users.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: usersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly IDP: FieldRef<"users", 'String'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly dataCommons: FieldRef<"users", 'String[]'>
    readonly email: FieldRef<"users", 'String'>
    readonly firstName: FieldRef<"users", 'String'>
    readonly lastName: FieldRef<"users", 'String'>
    readonly notifications: FieldRef<"users", 'String[]'>
    readonly permissions: FieldRef<"users", 'String[]'>
    readonly role: FieldRef<"users", 'String'>
    readonly status: FieldRef<"users", 'String'>
    readonly tokens: FieldRef<"users", 'String[]'>
    readonly updateAt: FieldRef<"users", 'DateTime'>
    readonly userStatus: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users findRaw
   */
  export type usersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users aggregateRaw
   */
  export type usersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model validation
   */

  export type AggregateValidation = {
    _count: ValidationCountAggregateOutputType | null
    _min: ValidationMinAggregateOutputType | null
    _max: ValidationMaxAggregateOutputType | null
  }

  export type ValidationMinAggregateOutputType = {
    id: string | null
    ended: Date | null
    scope: string | null
    started: Date | null
    status: string | null
    submissionID: string | null
  }

  export type ValidationMaxAggregateOutputType = {
    id: string | null
    ended: Date | null
    scope: string | null
    started: Date | null
    status: string | null
    submissionID: string | null
  }

  export type ValidationCountAggregateOutputType = {
    id: number
    ended: number
    scope: number
    started: number
    status: number
    submissionID: number
    type: number
    _all: number
  }


  export type ValidationMinAggregateInputType = {
    id?: true
    ended?: true
    scope?: true
    started?: true
    status?: true
    submissionID?: true
  }

  export type ValidationMaxAggregateInputType = {
    id?: true
    ended?: true
    scope?: true
    started?: true
    status?: true
    submissionID?: true
  }

  export type ValidationCountAggregateInputType = {
    id?: true
    ended?: true
    scope?: true
    started?: true
    status?: true
    submissionID?: true
    type?: true
    _all?: true
  }

  export type ValidationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which validation to aggregate.
     */
    where?: validationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of validations to fetch.
     */
    orderBy?: validationOrderByWithRelationInput | validationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: validationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` validations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned validations
    **/
    _count?: true | ValidationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ValidationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ValidationMaxAggregateInputType
  }

  export type GetValidationAggregateType<T extends ValidationAggregateArgs> = {
        [P in keyof T & keyof AggregateValidation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValidation[P]>
      : GetScalarType<T[P], AggregateValidation[P]>
  }




  export type validationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: validationWhereInput
    orderBy?: validationOrderByWithAggregationInput | validationOrderByWithAggregationInput[]
    by: ValidationScalarFieldEnum[] | ValidationScalarFieldEnum
    having?: validationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ValidationCountAggregateInputType | true
    _min?: ValidationMinAggregateInputType
    _max?: ValidationMaxAggregateInputType
  }

  export type ValidationGroupByOutputType = {
    id: string
    ended: Date | null
    scope: string | null
    started: Date
    status: string | null
    submissionID: string
    type: string[]
    _count: ValidationCountAggregateOutputType | null
    _min: ValidationMinAggregateOutputType | null
    _max: ValidationMaxAggregateOutputType | null
  }

  type GetValidationGroupByPayload<T extends validationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ValidationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ValidationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ValidationGroupByOutputType[P]>
            : GetScalarType<T[P], ValidationGroupByOutputType[P]>
        }
      >
    >


  export type validationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ended?: boolean
    scope?: boolean
    started?: boolean
    status?: boolean
    submissionID?: boolean
    type?: boolean
  }, ExtArgs["result"]["validation"]>



  export type validationSelectScalar = {
    id?: boolean
    ended?: boolean
    scope?: boolean
    started?: boolean
    status?: boolean
    submissionID?: boolean
    type?: boolean
  }

  export type validationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ended" | "scope" | "started" | "status" | "submissionID" | "type", ExtArgs["result"]["validation"]>

  export type $validationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "validation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ended: Date | null
      scope: string | null
      started: Date
      status: string | null
      submissionID: string
      type: string[]
    }, ExtArgs["result"]["validation"]>
    composites: {}
  }

  type validationGetPayload<S extends boolean | null | undefined | validationDefaultArgs> = $Result.GetResult<Prisma.$validationPayload, S>

  type validationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<validationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ValidationCountAggregateInputType | true
    }

  export interface validationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['validation'], meta: { name: 'validation' } }
    /**
     * Find zero or one Validation that matches the filter.
     * @param {validationFindUniqueArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends validationFindUniqueArgs>(args: SelectSubset<T, validationFindUniqueArgs<ExtArgs>>): Prisma__validationClient<$Result.GetResult<Prisma.$validationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Validation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {validationFindUniqueOrThrowArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends validationFindUniqueOrThrowArgs>(args: SelectSubset<T, validationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__validationClient<$Result.GetResult<Prisma.$validationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Validation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validationFindFirstArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends validationFindFirstArgs>(args?: SelectSubset<T, validationFindFirstArgs<ExtArgs>>): Prisma__validationClient<$Result.GetResult<Prisma.$validationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Validation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validationFindFirstOrThrowArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends validationFindFirstOrThrowArgs>(args?: SelectSubset<T, validationFindFirstOrThrowArgs<ExtArgs>>): Prisma__validationClient<$Result.GetResult<Prisma.$validationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Validations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Validations
     * const validations = await prisma.validation.findMany()
     * 
     * // Get first 10 Validations
     * const validations = await prisma.validation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const validationWithIdOnly = await prisma.validation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends validationFindManyArgs>(args?: SelectSubset<T, validationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$validationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Validation.
     * @param {validationCreateArgs} args - Arguments to create a Validation.
     * @example
     * // Create one Validation
     * const Validation = await prisma.validation.create({
     *   data: {
     *     // ... data to create a Validation
     *   }
     * })
     * 
     */
    create<T extends validationCreateArgs>(args: SelectSubset<T, validationCreateArgs<ExtArgs>>): Prisma__validationClient<$Result.GetResult<Prisma.$validationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Validations.
     * @param {validationCreateManyArgs} args - Arguments to create many Validations.
     * @example
     * // Create many Validations
     * const validation = await prisma.validation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends validationCreateManyArgs>(args?: SelectSubset<T, validationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Validation.
     * @param {validationDeleteArgs} args - Arguments to delete one Validation.
     * @example
     * // Delete one Validation
     * const Validation = await prisma.validation.delete({
     *   where: {
     *     // ... filter to delete one Validation
     *   }
     * })
     * 
     */
    delete<T extends validationDeleteArgs>(args: SelectSubset<T, validationDeleteArgs<ExtArgs>>): Prisma__validationClient<$Result.GetResult<Prisma.$validationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Validation.
     * @param {validationUpdateArgs} args - Arguments to update one Validation.
     * @example
     * // Update one Validation
     * const validation = await prisma.validation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends validationUpdateArgs>(args: SelectSubset<T, validationUpdateArgs<ExtArgs>>): Prisma__validationClient<$Result.GetResult<Prisma.$validationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Validations.
     * @param {validationDeleteManyArgs} args - Arguments to filter Validations to delete.
     * @example
     * // Delete a few Validations
     * const { count } = await prisma.validation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends validationDeleteManyArgs>(args?: SelectSubset<T, validationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Validations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Validations
     * const validation = await prisma.validation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends validationUpdateManyArgs>(args: SelectSubset<T, validationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Validation.
     * @param {validationUpsertArgs} args - Arguments to update or create a Validation.
     * @example
     * // Update or create a Validation
     * const validation = await prisma.validation.upsert({
     *   create: {
     *     // ... data to create a Validation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Validation we want to update
     *   }
     * })
     */
    upsert<T extends validationUpsertArgs>(args: SelectSubset<T, validationUpsertArgs<ExtArgs>>): Prisma__validationClient<$Result.GetResult<Prisma.$validationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Validations that matches the filter.
     * @param {validationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const validation = await prisma.validation.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: validationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Validation.
     * @param {validationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const validation = await prisma.validation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: validationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Validations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validationCountArgs} args - Arguments to filter Validations to count.
     * @example
     * // Count the number of Validations
     * const count = await prisma.validation.count({
     *   where: {
     *     // ... the filter for the Validations we want to count
     *   }
     * })
    **/
    count<T extends validationCountArgs>(
      args?: Subset<T, validationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ValidationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Validation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ValidationAggregateArgs>(args: Subset<T, ValidationAggregateArgs>): Prisma.PrismaPromise<GetValidationAggregateType<T>>

    /**
     * Group by Validation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {validationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends validationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: validationGroupByArgs['orderBy'] }
        : { orderBy?: validationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, validationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetValidationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the validation model
   */
  readonly fields: validationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for validation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__validationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the validation model
   */
  interface validationFieldRefs {
    readonly id: FieldRef<"validation", 'String'>
    readonly ended: FieldRef<"validation", 'DateTime'>
    readonly scope: FieldRef<"validation", 'String'>
    readonly started: FieldRef<"validation", 'DateTime'>
    readonly status: FieldRef<"validation", 'String'>
    readonly submissionID: FieldRef<"validation", 'String'>
    readonly type: FieldRef<"validation", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * validation findUnique
   */
  export type validationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validation
     */
    select?: validationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the validation
     */
    omit?: validationOmit<ExtArgs> | null
    /**
     * Filter, which validation to fetch.
     */
    where: validationWhereUniqueInput
  }

  /**
   * validation findUniqueOrThrow
   */
  export type validationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validation
     */
    select?: validationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the validation
     */
    omit?: validationOmit<ExtArgs> | null
    /**
     * Filter, which validation to fetch.
     */
    where: validationWhereUniqueInput
  }

  /**
   * validation findFirst
   */
  export type validationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validation
     */
    select?: validationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the validation
     */
    omit?: validationOmit<ExtArgs> | null
    /**
     * Filter, which validation to fetch.
     */
    where?: validationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of validations to fetch.
     */
    orderBy?: validationOrderByWithRelationInput | validationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for validations.
     */
    cursor?: validationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` validations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of validations.
     */
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * validation findFirstOrThrow
   */
  export type validationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validation
     */
    select?: validationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the validation
     */
    omit?: validationOmit<ExtArgs> | null
    /**
     * Filter, which validation to fetch.
     */
    where?: validationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of validations to fetch.
     */
    orderBy?: validationOrderByWithRelationInput | validationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for validations.
     */
    cursor?: validationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` validations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of validations.
     */
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * validation findMany
   */
  export type validationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validation
     */
    select?: validationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the validation
     */
    omit?: validationOmit<ExtArgs> | null
    /**
     * Filter, which validations to fetch.
     */
    where?: validationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of validations to fetch.
     */
    orderBy?: validationOrderByWithRelationInput | validationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing validations.
     */
    cursor?: validationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` validations.
     */
    skip?: number
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * validation create
   */
  export type validationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validation
     */
    select?: validationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the validation
     */
    omit?: validationOmit<ExtArgs> | null
    /**
     * The data needed to create a validation.
     */
    data: XOR<validationCreateInput, validationUncheckedCreateInput>
  }

  /**
   * validation createMany
   */
  export type validationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many validations.
     */
    data: validationCreateManyInput | validationCreateManyInput[]
  }

  /**
   * validation update
   */
  export type validationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validation
     */
    select?: validationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the validation
     */
    omit?: validationOmit<ExtArgs> | null
    /**
     * The data needed to update a validation.
     */
    data: XOR<validationUpdateInput, validationUncheckedUpdateInput>
    /**
     * Choose, which validation to update.
     */
    where: validationWhereUniqueInput
  }

  /**
   * validation updateMany
   */
  export type validationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update validations.
     */
    data: XOR<validationUpdateManyMutationInput, validationUncheckedUpdateManyInput>
    /**
     * Filter which validations to update
     */
    where?: validationWhereInput
    /**
     * Limit how many validations to update.
     */
    limit?: number
  }

  /**
   * validation upsert
   */
  export type validationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validation
     */
    select?: validationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the validation
     */
    omit?: validationOmit<ExtArgs> | null
    /**
     * The filter to search for the validation to update in case it exists.
     */
    where: validationWhereUniqueInput
    /**
     * In case the validation found by the `where` argument doesn't exist, create a new validation with this data.
     */
    create: XOR<validationCreateInput, validationUncheckedCreateInput>
    /**
     * In case the validation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<validationUpdateInput, validationUncheckedUpdateInput>
  }

  /**
   * validation delete
   */
  export type validationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validation
     */
    select?: validationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the validation
     */
    omit?: validationOmit<ExtArgs> | null
    /**
     * Filter which validation to delete.
     */
    where: validationWhereUniqueInput
  }

  /**
   * validation deleteMany
   */
  export type validationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which validations to delete
     */
    where?: validationWhereInput
    /**
     * Limit how many validations to delete.
     */
    limit?: number
  }

  /**
   * validation findRaw
   */
  export type validationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * validation aggregateRaw
   */
  export type validationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * validation without action
   */
  export type validationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the validation
     */
    select?: validationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the validation
     */
    omit?: validationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const CDEScalarFieldEnum: {
    id: 'id',
    CDECode: 'CDECode',
    CDEFullName: 'CDEFullName',
    CDEVersion: 'CDEVersion',
    PermissibleValues: 'PermissibleValues',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CDEScalarFieldEnum = (typeof CDEScalarFieldEnum)[keyof typeof CDEScalarFieldEnum]


  export const ApplicationsScalarFieldEnum: {
    id: 'id',
    ORCID: 'ORCID',
    PI: 'PI',
    controlledAccess: 'controlledAccess',
    createdAt: 'createdAt',
    inactiveReminder: 'inactiveReminder',
    openAccess: 'openAccess',
    programAbbreviation: 'programAbbreviation',
    programDescription: 'programDescription',
    programName: 'programName',
    questionnaireData: 'questionnaireData',
    reviewComment: 'reviewComment',
    status: 'status',
    studyAbbreviation: 'studyAbbreviation',
    studyName: 'studyName',
    submittedDate: 'submittedDate',
    updatedAt: 'updatedAt',
    version: 'version',
    wholeProgram: 'wholeProgram'
  };

  export type ApplicationsScalarFieldEnum = (typeof ApplicationsScalarFieldEnum)[keyof typeof ApplicationsScalarFieldEnum]


  export const ApprovedStudiesScalarFieldEnum: {
    id: 'id',
    ORCID: 'ORCID',
    PI: 'PI',
    controlledAccess: 'controlledAccess',
    createdAt: 'createdAt',
    dbGaPID: 'dbGaPID',
    openAccess: 'openAccess',
    originalOrg: 'originalOrg',
    primaryContactID: 'primaryContactID',
    programName: 'programName',
    studyAbbreviation: 'studyAbbreviation',
    studyName: 'studyName',
    updatedAt: 'updatedAt',
    useProgramPC: 'useProgramPC'
  };

  export type ApprovedStudiesScalarFieldEnum = (typeof ApprovedStudiesScalarFieldEnum)[keyof typeof ApprovedStudiesScalarFieldEnum]


  export const BatchScalarFieldEnum: {
    id: 'id',
    bucketName: 'bucketName',
    createdAt: 'createdAt',
    displayID: 'displayID',
    errors: 'errors',
    fileCount: 'fileCount',
    filePrefix: 'filePrefix',
    status: 'status',
    submissionID: 'submissionID',
    submitterID: 'submitterID',
    submitterName: 'submitterName',
    type: 'type',
    updatedAt: 'updatedAt',
    zipFileName: 'zipFileName'
  };

  export type BatchScalarFieldEnum = (typeof BatchScalarFieldEnum)[keyof typeof BatchScalarFieldEnum]


  export const ConfigurationScalarFieldEnum: {
    id: 'id',
    COMPLETED_RETENTION_DAYS: 'COMPLETED_RETENTION_DAYS',
    DASHBOARD_SESSION_TIMEOUT: 'DASHBOARD_SESSION_TIMEOUT',
    EMAIL_URL: 'EMAIL_URL',
    INACTIVE_APPLICATION_DAYS: 'INACTIVE_APPLICATION_DAYS',
    INACTIVE_SUBMISSION_DAYS_DELETE: 'INACTIVE_SUBMISSION_DAYS_DELETE',
    INACTIVE_USER_DAYS: 'INACTIVE_USER_DAYS',
    OFFICIAL_EMAIL: 'OFFICIAL_EMAIL',
    PRESIGN_EXPIRATION: 'PRESIGN_EXPIRATION',
    PROD_URL: 'PROD_URL',
    REMIND_APPLICATION_DAYS: 'REMIND_APPLICATION_DAYS',
    REVIEW_COMMITTEE_EMAIL: 'REVIEW_COMMITTEE_EMAIL',
    ROLE_TIMEOUT: 'ROLE_TIMEOUT',
    SCHEDULED_JOBS: 'SCHEDULED_JOBS',
    SUBMISSION_BUCKET: 'SUBMISSION_BUCKET',
    SUBMISSION_HELPDESK: 'SUBMISSION_HELPDESK',
    SUBMISSION_REQUEST_CONTACT_EMAIL: 'SUBMISSION_REQUEST_CONTACT_EMAIL',
    SUBMISSION_SYSTEM_PORTAL: 'SUBMISSION_SYSTEM_PORTAL',
    TECH_SUPPORT_EMAIL: 'TECH_SUPPORT_EMAIL',
    age: 'age',
    bucketName: 'bucketName',
    current: 'current',
    current_version: 'current_version',
    dashboardID: 'dashboardID',
    dataCommons: 'dataCommons',
    days: 'days',
    interval: 'interval',
    key: 'key',
    keys: 'keys',
    new: 'new',
    prefix: 'prefix',
    timeout: 'timeout',
    type: 'type',
    version: 'version'
  };

  export type ConfigurationScalarFieldEnum = (typeof ConfigurationScalarFieldEnum)[keyof typeof ConfigurationScalarFieldEnum]


  export const DataRecordsScalarFieldEnum: {
    id: 'id',
    CRDC_ID: 'CRDC_ID',
    IDPropName: 'IDPropName',
    batchIDs: 'batchIDs',
    createdAt: 'createdAt',
    dataCommons: 'dataCommons',
    entityType: 'entityType',
    latestBatchDisplayID: 'latestBatchDisplayID',
    latestBatchID: 'latestBatchID',
    lineNumber: 'lineNumber',
    nodeID: 'nodeID',
    nodeType: 'nodeType',
    orginalFileName: 'orginalFileName',
    props: 'props',
    qcResultID: 'qcResultID',
    rawData: 'rawData',
    status: 'status',
    studyID: 'studyID',
    submissionID: 'submissionID',
    updatedAt: 'updatedAt',
    uploadedDate: 'uploadedDate',
    validatedAt: 'validatedAt'
  };

  export type DataRecordsScalarFieldEnum = (typeof DataRecordsScalarFieldEnum)[keyof typeof DataRecordsScalarFieldEnum]


  export const DataRecordsArchivedScalarFieldEnum: {
    id: 'id',
    CRDC_ID: 'CRDC_ID',
    IDPropName: 'IDPropName',
    batchIDs: 'batchIDs',
    createdAt: 'createdAt',
    dataCommons: 'dataCommons',
    entityType: 'entityType',
    latestBatchDisplayID: 'latestBatchDisplayID',
    latestBatchID: 'latestBatchID',
    lineNumber: 'lineNumber',
    nodeID: 'nodeID',
    nodeType: 'nodeType',
    orginalFileName: 'orginalFileName',
    props: 'props',
    qcResultID: 'qcResultID',
    rawData: 'rawData',
    status: 'status',
    studyID: 'studyID',
    submissionID: 'submissionID',
    updatedAt: 'updatedAt',
    uploadedDate: 'uploadedDate',
    validatedAt: 'validatedAt'
  };

  export type DataRecordsArchivedScalarFieldEnum = (typeof DataRecordsArchivedScalarFieldEnum)[keyof typeof DataRecordsArchivedScalarFieldEnum]


  export const FileMD5ScalarFieldEnum: {
    id: 'id',
    LastModified: 'LastModified',
    createdAt: 'createdAt',
    fileName: 'fileName',
    md5: 'md5',
    submissionID: 'submissionID',
    updatedAt: 'updatedAt'
  };

  export type FileMD5ScalarFieldEnum = (typeof FileMD5ScalarFieldEnum)[keyof typeof FileMD5ScalarFieldEnum]


  export const InstitutionsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    status: 'status',
    submitterCount: 'submitterCount',
    updatedAt: 'updatedAt'
  };

  export type InstitutionsScalarFieldEnum = (typeof InstitutionsScalarFieldEnum)[keyof typeof InstitutionsScalarFieldEnum]


  export const LogsScalarFieldEnum: {
    id: 'id',
    action: 'action',
    applicationID: 'applicationID',
    eventType: 'eventType',
    localtime: 'localtime',
    newProfile: 'newProfile',
    newState: 'newState',
    prevProfile: 'prevProfile',
    prevState: 'prevState',
    submissionID: 'submissionID',
    timestamp: 'timestamp',
    userEmail: 'userEmail',
    userID: 'userID',
    userIDP: 'userIDP',
    userName: 'userName'
  };

  export type LogsScalarFieldEnum = (typeof LogsScalarFieldEnum)[keyof typeof LogsScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    abbreviation: 'abbreviation',
    bucketName: 'bucketName',
    conciergeEmail: 'conciergeEmail',
    conciergeID: 'conciergeID',
    conciergeName: 'conciergeName',
    createdAt: 'createdAt',
    description: 'description',
    name: 'name',
    rootPath: 'rootPath',
    status: 'status',
    updateAt: 'updateAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const QcResultsScalarFieldEnum: {
    id: 'id',
    batchIDs: 'batchIDs',
    dataRecordID: 'dataRecordID',
    displayID: 'displayID',
    latestBatchID: 'latestBatchID',
    origin: 'origin',
    severity: 'severity',
    submissionID: 'submissionID',
    submittedID: 'submittedID',
    type: 'type',
    uploadedDate: 'uploadedDate',
    validatedDate: 'validatedDate',
    validationType: 'validationType'
  };

  export type QcResultsScalarFieldEnum = (typeof QcResultsScalarFieldEnum)[keyof typeof QcResultsScalarFieldEnum]


  export const ReleaseScalarFieldEnum: {
    id: 'id',
    CRDC_ID: 'CRDC_ID',
    createdAt: 'createdAt',
    dataCommons: 'dataCommons',
    entityType: 'entityType',
    nodeID: 'nodeID',
    nodeType: 'nodeType',
    props: 'props',
    status: 'status',
    studyID: 'studyID',
    submissionID: 'submissionID',
    updatedAt: 'updatedAt'
  };

  export type ReleaseScalarFieldEnum = (typeof ReleaseScalarFieldEnum)[keyof typeof ReleaseScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    expires: 'expires',
    lastModified: 'lastModified',
    session: 'session'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const SubmissionsScalarFieldEnum: {
    id: 'id',
    ORCID: 'ORCID',
    accessedAt: 'accessedAt',
    archived: 'archived',
    bucketName: 'bucketName',
    collborators: 'collborators',
    conciergeEmail: 'conciergeEmail',
    conciergeName: 'conciergeName',
    controlledAccess: 'controlledAccess',
    createdAt: 'createdAt',
    crossSubmissionStatus: 'crossSubmissionStatus',
    dataCommons: 'dataCommons',
    dataCommonsDisplayName: 'dataCommonsDisplayName',
    dataType: 'dataType',
    dbGaPID: 'dbGaPID',
    deletingData: 'deletingData',
    fileValidationStatus: 'fileValidationStatus',
    finalInactiveReminder: 'finalInactiveReminder',
    inactiveReminder: 'inactiveReminder',
    inactiveReminder_30: 'inactiveReminder_30',
    inactiveReminder_60: 'inactiveReminder_60',
    inactiveReminder_7: 'inactiveReminder_7',
    intention: 'intention',
    metadataValidationStatus: 'metadataValidationStatus',
    modelVersion: 'modelVersion',
    name: 'name',
    nodeCount: 'nodeCount',
    reviewComment: 'reviewComment',
    rootPath: 'rootPath',
    status: 'status',
    studyAbbreviation: 'studyAbbreviation',
    studyID: 'studyID',
    submitterID: 'submitterID',
    submitterName: 'submitterName',
    updatedAt: 'updatedAt',
    validationEnded: 'validationEnded',
    validationScope: 'validationScope',
    validationStarted: 'validationStarted',
    validationType: 'validationType'
  };

  export type SubmissionsScalarFieldEnum = (typeof SubmissionsScalarFieldEnum)[keyof typeof SubmissionsScalarFieldEnum]


  export const SynonymsScalarFieldEnum: {
    id: 'id',
    equivalent_term: 'equivalent_term',
    synonym_term: 'synonym_term'
  };

  export type SynonymsScalarFieldEnum = (typeof SynonymsScalarFieldEnum)[keyof typeof SynonymsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    IDP: 'IDP',
    createdAt: 'createdAt',
    dataCommons: 'dataCommons',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    notifications: 'notifications',
    permissions: 'permissions',
    role: 'role',
    status: 'status',
    tokens: 'tokens',
    updateAt: 'updateAt',
    userStatus: 'userStatus'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const ValidationScalarFieldEnum: {
    id: 'id',
    ended: 'ended',
    scope: 'scope',
    started: 'started',
    status: 'status',
    submissionID: 'submissionID',
    type: 'type'
  };

  export type ValidationScalarFieldEnum = (typeof ValidationScalarFieldEnum)[keyof typeof ValidationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CDEWhereInput = {
    AND?: CDEWhereInput | CDEWhereInput[]
    OR?: CDEWhereInput[]
    NOT?: CDEWhereInput | CDEWhereInput[]
    id?: StringFilter<"CDE"> | string
    CDECode?: StringFilter<"CDE"> | string
    CDEFullName?: StringFilter<"CDE"> | string
    CDEVersion?: StringNullableFilter<"CDE"> | string | null
    PermissibleValues?: StringNullableListFilter<"CDE">
    createdAt?: DateTimeFilter<"CDE"> | Date | string
    updatedAt?: DateTimeFilter<"CDE"> | Date | string
  }

  export type CDEOrderByWithRelationInput = {
    id?: SortOrder
    CDECode?: SortOrder
    CDEFullName?: SortOrder
    CDEVersion?: SortOrder
    PermissibleValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CDEWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CDEWhereInput | CDEWhereInput[]
    OR?: CDEWhereInput[]
    NOT?: CDEWhereInput | CDEWhereInput[]
    CDECode?: StringFilter<"CDE"> | string
    CDEFullName?: StringFilter<"CDE"> | string
    CDEVersion?: StringNullableFilter<"CDE"> | string | null
    PermissibleValues?: StringNullableListFilter<"CDE">
    createdAt?: DateTimeFilter<"CDE"> | Date | string
    updatedAt?: DateTimeFilter<"CDE"> | Date | string
  }, "id">

  export type CDEOrderByWithAggregationInput = {
    id?: SortOrder
    CDECode?: SortOrder
    CDEFullName?: SortOrder
    CDEVersion?: SortOrder
    PermissibleValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CDECountOrderByAggregateInput
    _max?: CDEMaxOrderByAggregateInput
    _min?: CDEMinOrderByAggregateInput
  }

  export type CDEScalarWhereWithAggregatesInput = {
    AND?: CDEScalarWhereWithAggregatesInput | CDEScalarWhereWithAggregatesInput[]
    OR?: CDEScalarWhereWithAggregatesInput[]
    NOT?: CDEScalarWhereWithAggregatesInput | CDEScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CDE"> | string
    CDECode?: StringWithAggregatesFilter<"CDE"> | string
    CDEFullName?: StringWithAggregatesFilter<"CDE"> | string
    CDEVersion?: StringNullableWithAggregatesFilter<"CDE"> | string | null
    PermissibleValues?: StringNullableListFilter<"CDE">
    createdAt?: DateTimeWithAggregatesFilter<"CDE"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CDE"> | Date | string
  }

  export type applicationsWhereInput = {
    AND?: applicationsWhereInput | applicationsWhereInput[]
    OR?: applicationsWhereInput[]
    NOT?: applicationsWhereInput | applicationsWhereInput[]
    id?: StringFilter<"applications"> | string
    ORCID?: StringNullableFilter<"applications"> | string | null
    PI?: StringNullableFilter<"applications"> | string | null
    applicant?: XOR<ApplicantCompositeFilter, ApplicantObjectEqualityInput>
    controlledAccess?: BoolNullableFilter<"applications"> | boolean | null
    createdAt?: DateTimeFilter<"applications"> | Date | string
    history?: HistoryCompositeListFilter | HistoryObjectEqualityInput[]
    inactiveReminder?: BoolNullableFilter<"applications"> | boolean | null
    openAccess?: BoolNullableFilter<"applications"> | boolean | null
    organization?: XOR<OrgInfoCompositeFilter, OrgInfoObjectEqualityInput>
    programAbbreviation?: StringNullableFilter<"applications"> | string | null
    programDescription?: StringNullableFilter<"applications"> | string | null
    programName?: StringFilter<"applications"> | string
    questionnaireData?: StringFilter<"applications"> | string
    reviewComment?: StringNullableFilter<"applications"> | string | null
    status?: StringFilter<"applications"> | string
    studyAbbreviation?: StringFilter<"applications"> | string
    studyName?: StringFilter<"applications"> | string
    submittedDate?: DateTimeNullableFilter<"applications"> | Date | string | null
    updatedAt?: DateTimeFilter<"applications"> | Date | string
    version?: StringFilter<"applications"> | string
    wholeProgram?: BoolNullableFilter<"applications"> | boolean | null
  }

  export type applicationsOrderByWithRelationInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    applicant?: ApplicantOrderByInput
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    history?: HistoryOrderByCompositeAggregateInput
    inactiveReminder?: SortOrder
    openAccess?: SortOrder
    organization?: OrgInfoOrderByInput
    programAbbreviation?: SortOrder
    programDescription?: SortOrder
    programName?: SortOrder
    questionnaireData?: SortOrder
    reviewComment?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    submittedDate?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    wholeProgram?: SortOrder
  }

  export type applicationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: applicationsWhereInput | applicationsWhereInput[]
    OR?: applicationsWhereInput[]
    NOT?: applicationsWhereInput | applicationsWhereInput[]
    ORCID?: StringNullableFilter<"applications"> | string | null
    PI?: StringNullableFilter<"applications"> | string | null
    applicant?: XOR<ApplicantCompositeFilter, ApplicantObjectEqualityInput>
    controlledAccess?: BoolNullableFilter<"applications"> | boolean | null
    createdAt?: DateTimeFilter<"applications"> | Date | string
    history?: HistoryCompositeListFilter | HistoryObjectEqualityInput[]
    inactiveReminder?: BoolNullableFilter<"applications"> | boolean | null
    openAccess?: BoolNullableFilter<"applications"> | boolean | null
    organization?: XOR<OrgInfoCompositeFilter, OrgInfoObjectEqualityInput>
    programAbbreviation?: StringNullableFilter<"applications"> | string | null
    programDescription?: StringNullableFilter<"applications"> | string | null
    programName?: StringFilter<"applications"> | string
    questionnaireData?: StringFilter<"applications"> | string
    reviewComment?: StringNullableFilter<"applications"> | string | null
    status?: StringFilter<"applications"> | string
    studyAbbreviation?: StringFilter<"applications"> | string
    studyName?: StringFilter<"applications"> | string
    submittedDate?: DateTimeNullableFilter<"applications"> | Date | string | null
    updatedAt?: DateTimeFilter<"applications"> | Date | string
    version?: StringFilter<"applications"> | string
    wholeProgram?: BoolNullableFilter<"applications"> | boolean | null
  }, "id">

  export type applicationsOrderByWithAggregationInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    inactiveReminder?: SortOrder
    openAccess?: SortOrder
    programAbbreviation?: SortOrder
    programDescription?: SortOrder
    programName?: SortOrder
    questionnaireData?: SortOrder
    reviewComment?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    submittedDate?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    wholeProgram?: SortOrder
    _count?: applicationsCountOrderByAggregateInput
    _max?: applicationsMaxOrderByAggregateInput
    _min?: applicationsMinOrderByAggregateInput
  }

  export type applicationsScalarWhereWithAggregatesInput = {
    AND?: applicationsScalarWhereWithAggregatesInput | applicationsScalarWhereWithAggregatesInput[]
    OR?: applicationsScalarWhereWithAggregatesInput[]
    NOT?: applicationsScalarWhereWithAggregatesInput | applicationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"applications"> | string
    ORCID?: StringNullableWithAggregatesFilter<"applications"> | string | null
    PI?: StringNullableWithAggregatesFilter<"applications"> | string | null
    controlledAccess?: BoolNullableWithAggregatesFilter<"applications"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"applications"> | Date | string
    inactiveReminder?: BoolNullableWithAggregatesFilter<"applications"> | boolean | null
    openAccess?: BoolNullableWithAggregatesFilter<"applications"> | boolean | null
    programAbbreviation?: StringNullableWithAggregatesFilter<"applications"> | string | null
    programDescription?: StringNullableWithAggregatesFilter<"applications"> | string | null
    programName?: StringWithAggregatesFilter<"applications"> | string
    questionnaireData?: StringWithAggregatesFilter<"applications"> | string
    reviewComment?: StringNullableWithAggregatesFilter<"applications"> | string | null
    status?: StringWithAggregatesFilter<"applications"> | string
    studyAbbreviation?: StringWithAggregatesFilter<"applications"> | string
    studyName?: StringWithAggregatesFilter<"applications"> | string
    submittedDate?: DateTimeNullableWithAggregatesFilter<"applications"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"applications"> | Date | string
    version?: StringWithAggregatesFilter<"applications"> | string
    wholeProgram?: BoolNullableWithAggregatesFilter<"applications"> | boolean | null
  }

  export type approvedStudiesWhereInput = {
    AND?: approvedStudiesWhereInput | approvedStudiesWhereInput[]
    OR?: approvedStudiesWhereInput[]
    NOT?: approvedStudiesWhereInput | approvedStudiesWhereInput[]
    id?: StringFilter<"approvedStudies"> | string
    ORCID?: StringNullableFilter<"approvedStudies"> | string | null
    PI?: StringNullableFilter<"approvedStudies"> | string | null
    controlledAccess?: BoolFilter<"approvedStudies"> | boolean
    createdAt?: DateTimeFilter<"approvedStudies"> | Date | string
    dbGaPID?: StringNullableFilter<"approvedStudies"> | string | null
    openAccess?: BoolNullableFilter<"approvedStudies"> | boolean | null
    originalOrg?: StringNullableFilter<"approvedStudies"> | string | null
    primaryContactID?: StringNullableFilter<"approvedStudies"> | string | null
    programName?: StringNullableFilter<"approvedStudies"> | string | null
    studyAbbreviation?: StringFilter<"approvedStudies"> | string
    studyName?: StringFilter<"approvedStudies"> | string
    updatedAt?: DateTimeFilter<"approvedStudies"> | Date | string
    useProgramPC?: BoolNullableFilter<"approvedStudies"> | boolean | null
  }

  export type approvedStudiesOrderByWithRelationInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    dbGaPID?: SortOrder
    openAccess?: SortOrder
    originalOrg?: SortOrder
    primaryContactID?: SortOrder
    programName?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    updatedAt?: SortOrder
    useProgramPC?: SortOrder
  }

  export type approvedStudiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: approvedStudiesWhereInput | approvedStudiesWhereInput[]
    OR?: approvedStudiesWhereInput[]
    NOT?: approvedStudiesWhereInput | approvedStudiesWhereInput[]
    ORCID?: StringNullableFilter<"approvedStudies"> | string | null
    PI?: StringNullableFilter<"approvedStudies"> | string | null
    controlledAccess?: BoolFilter<"approvedStudies"> | boolean
    createdAt?: DateTimeFilter<"approvedStudies"> | Date | string
    dbGaPID?: StringNullableFilter<"approvedStudies"> | string | null
    openAccess?: BoolNullableFilter<"approvedStudies"> | boolean | null
    originalOrg?: StringNullableFilter<"approvedStudies"> | string | null
    primaryContactID?: StringNullableFilter<"approvedStudies"> | string | null
    programName?: StringNullableFilter<"approvedStudies"> | string | null
    studyAbbreviation?: StringFilter<"approvedStudies"> | string
    studyName?: StringFilter<"approvedStudies"> | string
    updatedAt?: DateTimeFilter<"approvedStudies"> | Date | string
    useProgramPC?: BoolNullableFilter<"approvedStudies"> | boolean | null
  }, "id">

  export type approvedStudiesOrderByWithAggregationInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    dbGaPID?: SortOrder
    openAccess?: SortOrder
    originalOrg?: SortOrder
    primaryContactID?: SortOrder
    programName?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    updatedAt?: SortOrder
    useProgramPC?: SortOrder
    _count?: approvedStudiesCountOrderByAggregateInput
    _max?: approvedStudiesMaxOrderByAggregateInput
    _min?: approvedStudiesMinOrderByAggregateInput
  }

  export type approvedStudiesScalarWhereWithAggregatesInput = {
    AND?: approvedStudiesScalarWhereWithAggregatesInput | approvedStudiesScalarWhereWithAggregatesInput[]
    OR?: approvedStudiesScalarWhereWithAggregatesInput[]
    NOT?: approvedStudiesScalarWhereWithAggregatesInput | approvedStudiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"approvedStudies"> | string
    ORCID?: StringNullableWithAggregatesFilter<"approvedStudies"> | string | null
    PI?: StringNullableWithAggregatesFilter<"approvedStudies"> | string | null
    controlledAccess?: BoolWithAggregatesFilter<"approvedStudies"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"approvedStudies"> | Date | string
    dbGaPID?: StringNullableWithAggregatesFilter<"approvedStudies"> | string | null
    openAccess?: BoolNullableWithAggregatesFilter<"approvedStudies"> | boolean | null
    originalOrg?: StringNullableWithAggregatesFilter<"approvedStudies"> | string | null
    primaryContactID?: StringNullableWithAggregatesFilter<"approvedStudies"> | string | null
    programName?: StringNullableWithAggregatesFilter<"approvedStudies"> | string | null
    studyAbbreviation?: StringWithAggregatesFilter<"approvedStudies"> | string
    studyName?: StringWithAggregatesFilter<"approvedStudies"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"approvedStudies"> | Date | string
    useProgramPC?: BoolNullableWithAggregatesFilter<"approvedStudies"> | boolean | null
  }

  export type batchWhereInput = {
    AND?: batchWhereInput | batchWhereInput[]
    OR?: batchWhereInput[]
    NOT?: batchWhereInput | batchWhereInput[]
    id?: StringFilter<"batch"> | string
    bucketName?: StringFilter<"batch"> | string
    createdAt?: DateTimeFilter<"batch"> | Date | string
    displayID?: IntFilter<"batch"> | number
    errors?: StringNullableListFilter<"batch">
    fileCount?: IntFilter<"batch"> | number
    filePrefix?: StringFilter<"batch"> | string
    files?: BatchFilesCompositeListFilter | BatchFilesObjectEqualityInput[]
    status?: StringFilter<"batch"> | string
    submissionID?: StringFilter<"batch"> | string
    submitterID?: StringNullableFilter<"batch"> | string | null
    submitterName?: StringNullableFilter<"batch"> | string | null
    type?: StringFilter<"batch"> | string
    updatedAt?: DateTimeFilter<"batch"> | Date | string
    zipFileName?: StringNullableFilter<"batch"> | string | null
  }

  export type batchOrderByWithRelationInput = {
    id?: SortOrder
    bucketName?: SortOrder
    createdAt?: SortOrder
    displayID?: SortOrder
    errors?: SortOrder
    fileCount?: SortOrder
    filePrefix?: SortOrder
    files?: BatchFilesOrderByCompositeAggregateInput
    status?: SortOrder
    submissionID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    zipFileName?: SortOrder
  }

  export type batchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: batchWhereInput | batchWhereInput[]
    OR?: batchWhereInput[]
    NOT?: batchWhereInput | batchWhereInput[]
    bucketName?: StringFilter<"batch"> | string
    createdAt?: DateTimeFilter<"batch"> | Date | string
    displayID?: IntFilter<"batch"> | number
    errors?: StringNullableListFilter<"batch">
    fileCount?: IntFilter<"batch"> | number
    filePrefix?: StringFilter<"batch"> | string
    files?: BatchFilesCompositeListFilter | BatchFilesObjectEqualityInput[]
    status?: StringFilter<"batch"> | string
    submissionID?: StringFilter<"batch"> | string
    submitterID?: StringNullableFilter<"batch"> | string | null
    submitterName?: StringNullableFilter<"batch"> | string | null
    type?: StringFilter<"batch"> | string
    updatedAt?: DateTimeFilter<"batch"> | Date | string
    zipFileName?: StringNullableFilter<"batch"> | string | null
  }, "id">

  export type batchOrderByWithAggregationInput = {
    id?: SortOrder
    bucketName?: SortOrder
    createdAt?: SortOrder
    displayID?: SortOrder
    errors?: SortOrder
    fileCount?: SortOrder
    filePrefix?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    zipFileName?: SortOrder
    _count?: batchCountOrderByAggregateInput
    _avg?: batchAvgOrderByAggregateInput
    _max?: batchMaxOrderByAggregateInput
    _min?: batchMinOrderByAggregateInput
    _sum?: batchSumOrderByAggregateInput
  }

  export type batchScalarWhereWithAggregatesInput = {
    AND?: batchScalarWhereWithAggregatesInput | batchScalarWhereWithAggregatesInput[]
    OR?: batchScalarWhereWithAggregatesInput[]
    NOT?: batchScalarWhereWithAggregatesInput | batchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"batch"> | string
    bucketName?: StringWithAggregatesFilter<"batch"> | string
    createdAt?: DateTimeWithAggregatesFilter<"batch"> | Date | string
    displayID?: IntWithAggregatesFilter<"batch"> | number
    errors?: StringNullableListFilter<"batch">
    fileCount?: IntWithAggregatesFilter<"batch"> | number
    filePrefix?: StringWithAggregatesFilter<"batch"> | string
    status?: StringWithAggregatesFilter<"batch"> | string
    submissionID?: StringWithAggregatesFilter<"batch"> | string
    submitterID?: StringNullableWithAggregatesFilter<"batch"> | string | null
    submitterName?: StringNullableWithAggregatesFilter<"batch"> | string | null
    type?: StringWithAggregatesFilter<"batch"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"batch"> | Date | string
    zipFileName?: StringNullableWithAggregatesFilter<"batch"> | string | null
  }

  export type configurationWhereInput = {
    AND?: configurationWhereInput | configurationWhereInput[]
    OR?: configurationWhereInput[]
    NOT?: configurationWhereInput | configurationWhereInput[]
    id?: StringFilter<"configuration"> | string
    COMPLETED_RETENTION_DAYS?: IntNullableFilter<"configuration"> | number | null
    DASHBOARD_SESSION_TIMEOUT?: IntNullableFilter<"configuration"> | number | null
    Defaults?: PBACDefaultsCompositeListFilter | PBACDefaultsObjectEqualityInput[]
    EMAIL_URL?: StringNullableFilter<"configuration"> | string | null
    INACTIVE_APPLICATION_DAYS?: IntNullableFilter<"configuration"> | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: IntNullableFilter<"configuration"> | number | null
    INACTIVE_USER_DAYS?: IntNullableFilter<"configuration"> | number | null
    OFFICIAL_EMAIL?: StringNullableFilter<"configuration"> | string | null
    PRESIGN_EXPIRATION?: IntNullableFilter<"configuration"> | number | null
    PROD_URL?: StringNullableFilter<"configuration"> | string | null
    REMIND_APPLICATION_DAYS?: IntNullableFilter<"configuration"> | number | null
    REVIEW_COMMITTEE_EMAIL?: StringNullableListFilter<"configuration">
    ROLE_TIMEOUT?: IntNullableFilter<"configuration"> | number | null
    SCHEDULED_JOBS?: StringNullableFilter<"configuration"> | string | null
    SUBMISSION_BUCKET?: StringNullableFilter<"configuration"> | string | null
    SUBMISSION_HELPDESK?: StringNullableFilter<"configuration"> | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: StringNullableFilter<"configuration"> | string | null
    SUBMISSION_SYSTEM_PORTAL?: StringNullableFilter<"configuration"> | string | null
    TECH_SUPPORT_EMAIL?: StringNullableFilter<"configuration"> | string | null
    age?: IntNullableFilter<"configuration"> | number | null
    bucketName?: StringNullableFilter<"configuration"> | string | null
    current?: StringNullableFilter<"configuration"> | string | null
    current_version?: StringNullableFilter<"configuration"> | string | null
    dashboardID?: StringNullableFilter<"configuration"> | string | null
    dataCommons?: StringNullableFilter<"configuration"> | string | null
    days?: IntNullableFilter<"configuration"> | number | null
    interval?: IntNullableFilter<"configuration"> | number | null
    key?: StringNullableListFilter<"configuration">
    keys?: JsonNullableFilter<"configuration">
    new?: StringNullableFilter<"configuration"> | string | null
    prefix?: StringNullableFilter<"configuration"> | string | null
    tag?: XOR<ConfigurationTagNullableCompositeFilter, ConfigurationTagObjectEqualityInput> | null
    timeout?: IntNullableFilter<"configuration"> | number | null
    type?: StringFilter<"configuration"> | string
    version?: StringNullableFilter<"configuration"> | string | null
  }

  export type configurationOrderByWithRelationInput = {
    id?: SortOrder
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    Defaults?: PBACDefaultsOrderByCompositeAggregateInput
    EMAIL_URL?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    OFFICIAL_EMAIL?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    PROD_URL?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    REVIEW_COMMITTEE_EMAIL?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    SCHEDULED_JOBS?: SortOrder
    SUBMISSION_BUCKET?: SortOrder
    SUBMISSION_HELPDESK?: SortOrder
    SUBMISSION_REQUEST_CONTACT_EMAIL?: SortOrder
    SUBMISSION_SYSTEM_PORTAL?: SortOrder
    TECH_SUPPORT_EMAIL?: SortOrder
    age?: SortOrder
    bucketName?: SortOrder
    current?: SortOrder
    current_version?: SortOrder
    dashboardID?: SortOrder
    dataCommons?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    key?: SortOrder
    keys?: SortOrder
    new?: SortOrder
    prefix?: SortOrder
    tag?: ConfigurationTagOrderByInput
    timeout?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type configurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: configurationWhereInput | configurationWhereInput[]
    OR?: configurationWhereInput[]
    NOT?: configurationWhereInput | configurationWhereInput[]
    COMPLETED_RETENTION_DAYS?: IntNullableFilter<"configuration"> | number | null
    DASHBOARD_SESSION_TIMEOUT?: IntNullableFilter<"configuration"> | number | null
    Defaults?: PBACDefaultsCompositeListFilter | PBACDefaultsObjectEqualityInput[]
    EMAIL_URL?: StringNullableFilter<"configuration"> | string | null
    INACTIVE_APPLICATION_DAYS?: IntNullableFilter<"configuration"> | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: IntNullableFilter<"configuration"> | number | null
    INACTIVE_USER_DAYS?: IntNullableFilter<"configuration"> | number | null
    OFFICIAL_EMAIL?: StringNullableFilter<"configuration"> | string | null
    PRESIGN_EXPIRATION?: IntNullableFilter<"configuration"> | number | null
    PROD_URL?: StringNullableFilter<"configuration"> | string | null
    REMIND_APPLICATION_DAYS?: IntNullableFilter<"configuration"> | number | null
    REVIEW_COMMITTEE_EMAIL?: StringNullableListFilter<"configuration">
    ROLE_TIMEOUT?: IntNullableFilter<"configuration"> | number | null
    SCHEDULED_JOBS?: StringNullableFilter<"configuration"> | string | null
    SUBMISSION_BUCKET?: StringNullableFilter<"configuration"> | string | null
    SUBMISSION_HELPDESK?: StringNullableFilter<"configuration"> | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: StringNullableFilter<"configuration"> | string | null
    SUBMISSION_SYSTEM_PORTAL?: StringNullableFilter<"configuration"> | string | null
    TECH_SUPPORT_EMAIL?: StringNullableFilter<"configuration"> | string | null
    age?: IntNullableFilter<"configuration"> | number | null
    bucketName?: StringNullableFilter<"configuration"> | string | null
    current?: StringNullableFilter<"configuration"> | string | null
    current_version?: StringNullableFilter<"configuration"> | string | null
    dashboardID?: StringNullableFilter<"configuration"> | string | null
    dataCommons?: StringNullableFilter<"configuration"> | string | null
    days?: IntNullableFilter<"configuration"> | number | null
    interval?: IntNullableFilter<"configuration"> | number | null
    key?: StringNullableListFilter<"configuration">
    keys?: JsonNullableFilter<"configuration">
    new?: StringNullableFilter<"configuration"> | string | null
    prefix?: StringNullableFilter<"configuration"> | string | null
    tag?: XOR<ConfigurationTagNullableCompositeFilter, ConfigurationTagObjectEqualityInput> | null
    timeout?: IntNullableFilter<"configuration"> | number | null
    type?: StringFilter<"configuration"> | string
    version?: StringNullableFilter<"configuration"> | string | null
  }, "id">

  export type configurationOrderByWithAggregationInput = {
    id?: SortOrder
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    EMAIL_URL?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    OFFICIAL_EMAIL?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    PROD_URL?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    REVIEW_COMMITTEE_EMAIL?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    SCHEDULED_JOBS?: SortOrder
    SUBMISSION_BUCKET?: SortOrder
    SUBMISSION_HELPDESK?: SortOrder
    SUBMISSION_REQUEST_CONTACT_EMAIL?: SortOrder
    SUBMISSION_SYSTEM_PORTAL?: SortOrder
    TECH_SUPPORT_EMAIL?: SortOrder
    age?: SortOrder
    bucketName?: SortOrder
    current?: SortOrder
    current_version?: SortOrder
    dashboardID?: SortOrder
    dataCommons?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    key?: SortOrder
    keys?: SortOrder
    new?: SortOrder
    prefix?: SortOrder
    timeout?: SortOrder
    type?: SortOrder
    version?: SortOrder
    _count?: configurationCountOrderByAggregateInput
    _avg?: configurationAvgOrderByAggregateInput
    _max?: configurationMaxOrderByAggregateInput
    _min?: configurationMinOrderByAggregateInput
    _sum?: configurationSumOrderByAggregateInput
  }

  export type configurationScalarWhereWithAggregatesInput = {
    AND?: configurationScalarWhereWithAggregatesInput | configurationScalarWhereWithAggregatesInput[]
    OR?: configurationScalarWhereWithAggregatesInput[]
    NOT?: configurationScalarWhereWithAggregatesInput | configurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"configuration"> | string
    COMPLETED_RETENTION_DAYS?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    DASHBOARD_SESSION_TIMEOUT?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    EMAIL_URL?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    INACTIVE_APPLICATION_DAYS?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    INACTIVE_USER_DAYS?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    OFFICIAL_EMAIL?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    PRESIGN_EXPIRATION?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    PROD_URL?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    REMIND_APPLICATION_DAYS?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    REVIEW_COMMITTEE_EMAIL?: StringNullableListFilter<"configuration">
    ROLE_TIMEOUT?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    SCHEDULED_JOBS?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    SUBMISSION_BUCKET?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    SUBMISSION_HELPDESK?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    SUBMISSION_SYSTEM_PORTAL?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    TECH_SUPPORT_EMAIL?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    age?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    bucketName?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    current?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    current_version?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    dashboardID?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    dataCommons?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    days?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    interval?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    key?: StringNullableListFilter<"configuration">
    keys?: JsonNullableWithAggregatesFilter<"configuration">
    new?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    prefix?: StringNullableWithAggregatesFilter<"configuration"> | string | null
    timeout?: IntNullableWithAggregatesFilter<"configuration"> | number | null
    type?: StringWithAggregatesFilter<"configuration"> | string
    version?: StringNullableWithAggregatesFilter<"configuration"> | string | null
  }

  export type dataRecordsWhereInput = {
    AND?: dataRecordsWhereInput | dataRecordsWhereInput[]
    OR?: dataRecordsWhereInput[]
    NOT?: dataRecordsWhereInput | dataRecordsWhereInput[]
    id?: StringFilter<"dataRecords"> | string
    CRDC_ID?: StringNullableFilter<"dataRecords"> | string | null
    IDPropName?: StringFilter<"dataRecords"> | string
    additionalErrors?: AdditionalErrorCompositeListFilter | AdditionalErrorObjectEqualityInput[]
    batchIDs?: StringNullableListFilter<"dataRecords">
    createdAt?: DateTimeFilter<"dataRecords"> | Date | string
    dataCommons?: StringFilter<"dataRecords"> | string
    entityType?: StringNullableFilter<"dataRecords"> | string | null
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchDisplayID?: IntFilter<"dataRecords"> | number
    latestBatchID?: StringFilter<"dataRecords"> | string
    lineNumber?: IntFilter<"dataRecords"> | number
    nodeID?: StringFilter<"dataRecords"> | string
    nodeType?: StringFilter<"dataRecords"> | string
    orginalFileName?: StringFilter<"dataRecords"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"dataRecords">
    qcResultID?: StringNullableFilter<"dataRecords"> | string | null
    rawData?: JsonFilter<"dataRecords">
    s3FileInfo?: XOR<S3FileInfoNullableCompositeFilter, S3FileInfoObjectEqualityInput> | null
    status?: StringFilter<"dataRecords"> | string
    studyID?: StringFilter<"dataRecords"> | string
    submissionID?: StringFilter<"dataRecords"> | string
    updatedAt?: DateTimeFilter<"dataRecords"> | Date | string
    uploadedDate?: DateTimeFilter<"dataRecords"> | Date | string
    validatedAt?: DateTimeNullableFilter<"dataRecords"> | Date | string | null
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
  }

  export type dataRecordsOrderByWithRelationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    additionalErrors?: AdditionalErrorOrderByCompositeAggregateInput
    batchIDs?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    errors?: ErrorOrderByCompositeAggregateInput
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    parents?: ParentOrderByCompositeAggregateInput
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    s3FileInfo?: S3FileInfoOrderByInput
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    warnings?: ErrorOrderByCompositeAggregateInput
  }

  export type dataRecordsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: dataRecordsWhereInput | dataRecordsWhereInput[]
    OR?: dataRecordsWhereInput[]
    NOT?: dataRecordsWhereInput | dataRecordsWhereInput[]
    CRDC_ID?: StringNullableFilter<"dataRecords"> | string | null
    IDPropName?: StringFilter<"dataRecords"> | string
    additionalErrors?: AdditionalErrorCompositeListFilter | AdditionalErrorObjectEqualityInput[]
    batchIDs?: StringNullableListFilter<"dataRecords">
    createdAt?: DateTimeFilter<"dataRecords"> | Date | string
    dataCommons?: StringFilter<"dataRecords"> | string
    entityType?: StringNullableFilter<"dataRecords"> | string | null
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchDisplayID?: IntFilter<"dataRecords"> | number
    latestBatchID?: StringFilter<"dataRecords"> | string
    lineNumber?: IntFilter<"dataRecords"> | number
    nodeID?: StringFilter<"dataRecords"> | string
    nodeType?: StringFilter<"dataRecords"> | string
    orginalFileName?: StringFilter<"dataRecords"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"dataRecords">
    qcResultID?: StringNullableFilter<"dataRecords"> | string | null
    rawData?: JsonFilter<"dataRecords">
    s3FileInfo?: XOR<S3FileInfoNullableCompositeFilter, S3FileInfoObjectEqualityInput> | null
    status?: StringFilter<"dataRecords"> | string
    studyID?: StringFilter<"dataRecords"> | string
    submissionID?: StringFilter<"dataRecords"> | string
    updatedAt?: DateTimeFilter<"dataRecords"> | Date | string
    uploadedDate?: DateTimeFilter<"dataRecords"> | Date | string
    validatedAt?: DateTimeNullableFilter<"dataRecords"> | Date | string | null
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
  }, "id">

  export type dataRecordsOrderByWithAggregationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    batchIDs?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    _count?: dataRecordsCountOrderByAggregateInput
    _avg?: dataRecordsAvgOrderByAggregateInput
    _max?: dataRecordsMaxOrderByAggregateInput
    _min?: dataRecordsMinOrderByAggregateInput
    _sum?: dataRecordsSumOrderByAggregateInput
  }

  export type dataRecordsScalarWhereWithAggregatesInput = {
    AND?: dataRecordsScalarWhereWithAggregatesInput | dataRecordsScalarWhereWithAggregatesInput[]
    OR?: dataRecordsScalarWhereWithAggregatesInput[]
    NOT?: dataRecordsScalarWhereWithAggregatesInput | dataRecordsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"dataRecords"> | string
    CRDC_ID?: StringNullableWithAggregatesFilter<"dataRecords"> | string | null
    IDPropName?: StringWithAggregatesFilter<"dataRecords"> | string
    batchIDs?: StringNullableListFilter<"dataRecords">
    createdAt?: DateTimeWithAggregatesFilter<"dataRecords"> | Date | string
    dataCommons?: StringWithAggregatesFilter<"dataRecords"> | string
    entityType?: StringNullableWithAggregatesFilter<"dataRecords"> | string | null
    latestBatchDisplayID?: IntWithAggregatesFilter<"dataRecords"> | number
    latestBatchID?: StringWithAggregatesFilter<"dataRecords"> | string
    lineNumber?: IntWithAggregatesFilter<"dataRecords"> | number
    nodeID?: StringWithAggregatesFilter<"dataRecords"> | string
    nodeType?: StringWithAggregatesFilter<"dataRecords"> | string
    orginalFileName?: StringWithAggregatesFilter<"dataRecords"> | string
    props?: JsonWithAggregatesFilter<"dataRecords">
    qcResultID?: StringNullableWithAggregatesFilter<"dataRecords"> | string | null
    rawData?: JsonWithAggregatesFilter<"dataRecords">
    status?: StringWithAggregatesFilter<"dataRecords"> | string
    studyID?: StringWithAggregatesFilter<"dataRecords"> | string
    submissionID?: StringWithAggregatesFilter<"dataRecords"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"dataRecords"> | Date | string
    uploadedDate?: DateTimeWithAggregatesFilter<"dataRecords"> | Date | string
    validatedAt?: DateTimeNullableWithAggregatesFilter<"dataRecords"> | Date | string | null
  }

  export type dataRecordsArchivedWhereInput = {
    AND?: dataRecordsArchivedWhereInput | dataRecordsArchivedWhereInput[]
    OR?: dataRecordsArchivedWhereInput[]
    NOT?: dataRecordsArchivedWhereInput | dataRecordsArchivedWhereInput[]
    id?: StringFilter<"dataRecordsArchived"> | string
    CRDC_ID?: StringNullableFilter<"dataRecordsArchived"> | string | null
    IDPropName?: StringFilter<"dataRecordsArchived"> | string
    additionalErrors?: AdditionalErrorCompositeListFilter | AdditionalErrorObjectEqualityInput[]
    batchIDs?: StringNullableListFilter<"dataRecordsArchived">
    createdAt?: DateTimeFilter<"dataRecordsArchived"> | Date | string
    dataCommons?: StringFilter<"dataRecordsArchived"> | string
    entityType?: StringNullableFilter<"dataRecordsArchived"> | string | null
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchDisplayID?: IntFilter<"dataRecordsArchived"> | number
    latestBatchID?: StringFilter<"dataRecordsArchived"> | string
    lineNumber?: IntFilter<"dataRecordsArchived"> | number
    nodeID?: StringFilter<"dataRecordsArchived"> | string
    nodeType?: StringFilter<"dataRecordsArchived"> | string
    orginalFileName?: StringFilter<"dataRecordsArchived"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"dataRecordsArchived">
    qcResultID?: StringNullableFilter<"dataRecordsArchived"> | string | null
    rawData?: JsonFilter<"dataRecordsArchived">
    s3FileInfo?: XOR<S3FileInfoNullableCompositeFilter, S3FileInfoObjectEqualityInput> | null
    status?: StringFilter<"dataRecordsArchived"> | string
    studyID?: StringNullableFilter<"dataRecordsArchived"> | string | null
    submissionID?: StringFilter<"dataRecordsArchived"> | string
    updatedAt?: DateTimeFilter<"dataRecordsArchived"> | Date | string
    uploadedDate?: DateTimeFilter<"dataRecordsArchived"> | Date | string
    validatedAt?: DateTimeNullableFilter<"dataRecordsArchived"> | Date | string | null
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
  }

  export type dataRecordsArchivedOrderByWithRelationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    additionalErrors?: AdditionalErrorOrderByCompositeAggregateInput
    batchIDs?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    errors?: ErrorOrderByCompositeAggregateInput
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    parents?: ParentOrderByCompositeAggregateInput
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    s3FileInfo?: S3FileInfoOrderByInput
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    warnings?: ErrorOrderByCompositeAggregateInput
  }

  export type dataRecordsArchivedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: dataRecordsArchivedWhereInput | dataRecordsArchivedWhereInput[]
    OR?: dataRecordsArchivedWhereInput[]
    NOT?: dataRecordsArchivedWhereInput | dataRecordsArchivedWhereInput[]
    CRDC_ID?: StringNullableFilter<"dataRecordsArchived"> | string | null
    IDPropName?: StringFilter<"dataRecordsArchived"> | string
    additionalErrors?: AdditionalErrorCompositeListFilter | AdditionalErrorObjectEqualityInput[]
    batchIDs?: StringNullableListFilter<"dataRecordsArchived">
    createdAt?: DateTimeFilter<"dataRecordsArchived"> | Date | string
    dataCommons?: StringFilter<"dataRecordsArchived"> | string
    entityType?: StringNullableFilter<"dataRecordsArchived"> | string | null
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchDisplayID?: IntFilter<"dataRecordsArchived"> | number
    latestBatchID?: StringFilter<"dataRecordsArchived"> | string
    lineNumber?: IntFilter<"dataRecordsArchived"> | number
    nodeID?: StringFilter<"dataRecordsArchived"> | string
    nodeType?: StringFilter<"dataRecordsArchived"> | string
    orginalFileName?: StringFilter<"dataRecordsArchived"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"dataRecordsArchived">
    qcResultID?: StringNullableFilter<"dataRecordsArchived"> | string | null
    rawData?: JsonFilter<"dataRecordsArchived">
    s3FileInfo?: XOR<S3FileInfoNullableCompositeFilter, S3FileInfoObjectEqualityInput> | null
    status?: StringFilter<"dataRecordsArchived"> | string
    studyID?: StringNullableFilter<"dataRecordsArchived"> | string | null
    submissionID?: StringFilter<"dataRecordsArchived"> | string
    updatedAt?: DateTimeFilter<"dataRecordsArchived"> | Date | string
    uploadedDate?: DateTimeFilter<"dataRecordsArchived"> | Date | string
    validatedAt?: DateTimeNullableFilter<"dataRecordsArchived"> | Date | string | null
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
  }, "id">

  export type dataRecordsArchivedOrderByWithAggregationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    batchIDs?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    _count?: dataRecordsArchivedCountOrderByAggregateInput
    _avg?: dataRecordsArchivedAvgOrderByAggregateInput
    _max?: dataRecordsArchivedMaxOrderByAggregateInput
    _min?: dataRecordsArchivedMinOrderByAggregateInput
    _sum?: dataRecordsArchivedSumOrderByAggregateInput
  }

  export type dataRecordsArchivedScalarWhereWithAggregatesInput = {
    AND?: dataRecordsArchivedScalarWhereWithAggregatesInput | dataRecordsArchivedScalarWhereWithAggregatesInput[]
    OR?: dataRecordsArchivedScalarWhereWithAggregatesInput[]
    NOT?: dataRecordsArchivedScalarWhereWithAggregatesInput | dataRecordsArchivedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"dataRecordsArchived"> | string
    CRDC_ID?: StringNullableWithAggregatesFilter<"dataRecordsArchived"> | string | null
    IDPropName?: StringWithAggregatesFilter<"dataRecordsArchived"> | string
    batchIDs?: StringNullableListFilter<"dataRecordsArchived">
    createdAt?: DateTimeWithAggregatesFilter<"dataRecordsArchived"> | Date | string
    dataCommons?: StringWithAggregatesFilter<"dataRecordsArchived"> | string
    entityType?: StringNullableWithAggregatesFilter<"dataRecordsArchived"> | string | null
    latestBatchDisplayID?: IntWithAggregatesFilter<"dataRecordsArchived"> | number
    latestBatchID?: StringWithAggregatesFilter<"dataRecordsArchived"> | string
    lineNumber?: IntWithAggregatesFilter<"dataRecordsArchived"> | number
    nodeID?: StringWithAggregatesFilter<"dataRecordsArchived"> | string
    nodeType?: StringWithAggregatesFilter<"dataRecordsArchived"> | string
    orginalFileName?: StringWithAggregatesFilter<"dataRecordsArchived"> | string
    props?: JsonWithAggregatesFilter<"dataRecordsArchived">
    qcResultID?: StringNullableWithAggregatesFilter<"dataRecordsArchived"> | string | null
    rawData?: JsonWithAggregatesFilter<"dataRecordsArchived">
    status?: StringWithAggregatesFilter<"dataRecordsArchived"> | string
    studyID?: StringNullableWithAggregatesFilter<"dataRecordsArchived"> | string | null
    submissionID?: StringWithAggregatesFilter<"dataRecordsArchived"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"dataRecordsArchived"> | Date | string
    uploadedDate?: DateTimeWithAggregatesFilter<"dataRecordsArchived"> | Date | string
    validatedAt?: DateTimeNullableWithAggregatesFilter<"dataRecordsArchived"> | Date | string | null
  }

  export type fileMD5WhereInput = {
    AND?: fileMD5WhereInput | fileMD5WhereInput[]
    OR?: fileMD5WhereInput[]
    NOT?: fileMD5WhereInput | fileMD5WhereInput[]
    id?: StringFilter<"fileMD5"> | string
    LastModified?: DateTimeFilter<"fileMD5"> | Date | string
    createdAt?: DateTimeFilter<"fileMD5"> | Date | string
    fileName?: StringFilter<"fileMD5"> | string
    md5?: StringFilter<"fileMD5"> | string
    submissionID?: StringFilter<"fileMD5"> | string
    updatedAt?: DateTimeFilter<"fileMD5"> | Date | string
  }

  export type fileMD5OrderByWithRelationInput = {
    id?: SortOrder
    LastModified?: SortOrder
    createdAt?: SortOrder
    fileName?: SortOrder
    md5?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
  }

  export type fileMD5WhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: fileMD5WhereInput | fileMD5WhereInput[]
    OR?: fileMD5WhereInput[]
    NOT?: fileMD5WhereInput | fileMD5WhereInput[]
    LastModified?: DateTimeFilter<"fileMD5"> | Date | string
    createdAt?: DateTimeFilter<"fileMD5"> | Date | string
    fileName?: StringFilter<"fileMD5"> | string
    md5?: StringFilter<"fileMD5"> | string
    submissionID?: StringFilter<"fileMD5"> | string
    updatedAt?: DateTimeFilter<"fileMD5"> | Date | string
  }, "id">

  export type fileMD5OrderByWithAggregationInput = {
    id?: SortOrder
    LastModified?: SortOrder
    createdAt?: SortOrder
    fileName?: SortOrder
    md5?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    _count?: fileMD5CountOrderByAggregateInput
    _max?: fileMD5MaxOrderByAggregateInput
    _min?: fileMD5MinOrderByAggregateInput
  }

  export type fileMD5ScalarWhereWithAggregatesInput = {
    AND?: fileMD5ScalarWhereWithAggregatesInput | fileMD5ScalarWhereWithAggregatesInput[]
    OR?: fileMD5ScalarWhereWithAggregatesInput[]
    NOT?: fileMD5ScalarWhereWithAggregatesInput | fileMD5ScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"fileMD5"> | string
    LastModified?: DateTimeWithAggregatesFilter<"fileMD5"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"fileMD5"> | Date | string
    fileName?: StringWithAggregatesFilter<"fileMD5"> | string
    md5?: StringWithAggregatesFilter<"fileMD5"> | string
    submissionID?: StringWithAggregatesFilter<"fileMD5"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"fileMD5"> | Date | string
  }

  export type institutionsWhereInput = {
    AND?: institutionsWhereInput | institutionsWhereInput[]
    OR?: institutionsWhereInput[]
    NOT?: institutionsWhereInput | institutionsWhereInput[]
    id?: StringFilter<"institutions"> | string
    createdAt?: DateTimeNullableFilter<"institutions"> | Date | string | null
    name?: StringFilter<"institutions"> | string
    status?: StringFilter<"institutions"> | string
    submitterCount?: IntNullableFilter<"institutions"> | number | null
    updatedAt?: DateTimeNullableFilter<"institutions"> | Date | string | null
  }

  export type institutionsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    submitterCount?: SortOrder
    updatedAt?: SortOrder
  }

  export type institutionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: institutionsWhereInput | institutionsWhereInput[]
    OR?: institutionsWhereInput[]
    NOT?: institutionsWhereInput | institutionsWhereInput[]
    createdAt?: DateTimeNullableFilter<"institutions"> | Date | string | null
    name?: StringFilter<"institutions"> | string
    status?: StringFilter<"institutions"> | string
    submitterCount?: IntNullableFilter<"institutions"> | number | null
    updatedAt?: DateTimeNullableFilter<"institutions"> | Date | string | null
  }, "id">

  export type institutionsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    submitterCount?: SortOrder
    updatedAt?: SortOrder
    _count?: institutionsCountOrderByAggregateInput
    _avg?: institutionsAvgOrderByAggregateInput
    _max?: institutionsMaxOrderByAggregateInput
    _min?: institutionsMinOrderByAggregateInput
    _sum?: institutionsSumOrderByAggregateInput
  }

  export type institutionsScalarWhereWithAggregatesInput = {
    AND?: institutionsScalarWhereWithAggregatesInput | institutionsScalarWhereWithAggregatesInput[]
    OR?: institutionsScalarWhereWithAggregatesInput[]
    NOT?: institutionsScalarWhereWithAggregatesInput | institutionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"institutions"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"institutions"> | Date | string | null
    name?: StringWithAggregatesFilter<"institutions"> | string
    status?: StringWithAggregatesFilter<"institutions"> | string
    submitterCount?: IntNullableWithAggregatesFilter<"institutions"> | number | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"institutions"> | Date | string | null
  }

  export type logsWhereInput = {
    AND?: logsWhereInput | logsWhereInput[]
    OR?: logsWhereInput[]
    NOT?: logsWhereInput | logsWhereInput[]
    id?: StringFilter<"logs"> | string
    action?: StringNullableFilter<"logs"> | string | null
    applicationID?: StringNullableFilter<"logs"> | string | null
    eventDetail?: XOR<LogsEventDetailNullableCompositeFilter, LogsEventDetailObjectEqualityInput> | null
    eventType?: StringFilter<"logs"> | string
    localtime?: DateTimeFilter<"logs"> | Date | string
    newProfile?: JsonNullableFilter<"logs">
    newState?: StringNullableFilter<"logs"> | string | null
    prevProfile?: JsonNullableFilter<"logs">
    prevState?: StringNullableFilter<"logs"> | string | null
    submissionID?: StringNullableFilter<"logs"> | string | null
    timestamp?: FloatFilter<"logs"> | number
    userEmail?: StringFilter<"logs"> | string
    userID?: StringFilter<"logs"> | string
    userIDP?: StringNullableFilter<"logs"> | string | null
    userName?: StringNullableFilter<"logs"> | string | null
  }

  export type logsOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    applicationID?: SortOrder
    eventDetail?: LogsEventDetailOrderByInput
    eventType?: SortOrder
    localtime?: SortOrder
    newProfile?: SortOrder
    newState?: SortOrder
    prevProfile?: SortOrder
    prevState?: SortOrder
    submissionID?: SortOrder
    timestamp?: SortOrder
    userEmail?: SortOrder
    userID?: SortOrder
    userIDP?: SortOrder
    userName?: SortOrder
  }

  export type logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: logsWhereInput | logsWhereInput[]
    OR?: logsWhereInput[]
    NOT?: logsWhereInput | logsWhereInput[]
    action?: StringNullableFilter<"logs"> | string | null
    applicationID?: StringNullableFilter<"logs"> | string | null
    eventDetail?: XOR<LogsEventDetailNullableCompositeFilter, LogsEventDetailObjectEqualityInput> | null
    eventType?: StringFilter<"logs"> | string
    localtime?: DateTimeFilter<"logs"> | Date | string
    newProfile?: JsonNullableFilter<"logs">
    newState?: StringNullableFilter<"logs"> | string | null
    prevProfile?: JsonNullableFilter<"logs">
    prevState?: StringNullableFilter<"logs"> | string | null
    submissionID?: StringNullableFilter<"logs"> | string | null
    timestamp?: FloatFilter<"logs"> | number
    userEmail?: StringFilter<"logs"> | string
    userID?: StringFilter<"logs"> | string
    userIDP?: StringNullableFilter<"logs"> | string | null
    userName?: StringNullableFilter<"logs"> | string | null
  }, "id">

  export type logsOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    applicationID?: SortOrder
    eventType?: SortOrder
    localtime?: SortOrder
    newProfile?: SortOrder
    newState?: SortOrder
    prevProfile?: SortOrder
    prevState?: SortOrder
    submissionID?: SortOrder
    timestamp?: SortOrder
    userEmail?: SortOrder
    userID?: SortOrder
    userIDP?: SortOrder
    userName?: SortOrder
    _count?: logsCountOrderByAggregateInput
    _avg?: logsAvgOrderByAggregateInput
    _max?: logsMaxOrderByAggregateInput
    _min?: logsMinOrderByAggregateInput
    _sum?: logsSumOrderByAggregateInput
  }

  export type logsScalarWhereWithAggregatesInput = {
    AND?: logsScalarWhereWithAggregatesInput | logsScalarWhereWithAggregatesInput[]
    OR?: logsScalarWhereWithAggregatesInput[]
    NOT?: logsScalarWhereWithAggregatesInput | logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"logs"> | string
    action?: StringNullableWithAggregatesFilter<"logs"> | string | null
    applicationID?: StringNullableWithAggregatesFilter<"logs"> | string | null
    eventType?: StringWithAggregatesFilter<"logs"> | string
    localtime?: DateTimeWithAggregatesFilter<"logs"> | Date | string
    newProfile?: JsonNullableWithAggregatesFilter<"logs">
    newState?: StringNullableWithAggregatesFilter<"logs"> | string | null
    prevProfile?: JsonNullableWithAggregatesFilter<"logs">
    prevState?: StringNullableWithAggregatesFilter<"logs"> | string | null
    submissionID?: StringNullableWithAggregatesFilter<"logs"> | string | null
    timestamp?: FloatWithAggregatesFilter<"logs"> | number
    userEmail?: StringWithAggregatesFilter<"logs"> | string
    userID?: StringWithAggregatesFilter<"logs"> | string
    userIDP?: StringNullableWithAggregatesFilter<"logs"> | string | null
    userName?: StringNullableWithAggregatesFilter<"logs"> | string | null
  }

  export type organizationWhereInput = {
    AND?: organizationWhereInput | organizationWhereInput[]
    OR?: organizationWhereInput[]
    NOT?: organizationWhereInput | organizationWhereInput[]
    id?: StringFilter<"organization"> | string
    abbreviation?: StringNullableFilter<"organization"> | string | null
    bucketName?: StringNullableFilter<"organization"> | string | null
    conciergeEmail?: StringNullableFilter<"organization"> | string | null
    conciergeID?: StringNullableFilter<"organization"> | string | null
    conciergeName?: StringNullableFilter<"organization"> | string | null
    createdAt?: DateTimeFilter<"organization"> | Date | string
    description?: StringNullableFilter<"organization"> | string | null
    name?: StringFilter<"organization"> | string
    rootPath?: StringNullableFilter<"organization"> | string | null
    status?: StringFilter<"organization"> | string
    studies?: StudyByIDCompositeListFilter | StudyByIDObjectEqualityInput[]
    updateAt?: DateTimeFilter<"organization"> | Date | string
    updatedAt?: DateTimeNullableFilter<"organization"> | Date | string | null
  }

  export type organizationOrderByWithRelationInput = {
    id?: SortOrder
    abbreviation?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeID?: SortOrder
    conciergeName?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    name?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studies?: StudyByIDOrderByCompositeAggregateInput
    updateAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: organizationWhereInput | organizationWhereInput[]
    OR?: organizationWhereInput[]
    NOT?: organizationWhereInput | organizationWhereInput[]
    abbreviation?: StringNullableFilter<"organization"> | string | null
    bucketName?: StringNullableFilter<"organization"> | string | null
    conciergeEmail?: StringNullableFilter<"organization"> | string | null
    conciergeID?: StringNullableFilter<"organization"> | string | null
    conciergeName?: StringNullableFilter<"organization"> | string | null
    createdAt?: DateTimeFilter<"organization"> | Date | string
    description?: StringNullableFilter<"organization"> | string | null
    name?: StringFilter<"organization"> | string
    rootPath?: StringNullableFilter<"organization"> | string | null
    status?: StringFilter<"organization"> | string
    studies?: StudyByIDCompositeListFilter | StudyByIDObjectEqualityInput[]
    updateAt?: DateTimeFilter<"organization"> | Date | string
    updatedAt?: DateTimeNullableFilter<"organization"> | Date | string | null
  }, "id">

  export type organizationOrderByWithAggregationInput = {
    id?: SortOrder
    abbreviation?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeID?: SortOrder
    conciergeName?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    name?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    updateAt?: SortOrder
    updatedAt?: SortOrder
    _count?: organizationCountOrderByAggregateInput
    _max?: organizationMaxOrderByAggregateInput
    _min?: organizationMinOrderByAggregateInput
  }

  export type organizationScalarWhereWithAggregatesInput = {
    AND?: organizationScalarWhereWithAggregatesInput | organizationScalarWhereWithAggregatesInput[]
    OR?: organizationScalarWhereWithAggregatesInput[]
    NOT?: organizationScalarWhereWithAggregatesInput | organizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"organization"> | string
    abbreviation?: StringNullableWithAggregatesFilter<"organization"> | string | null
    bucketName?: StringNullableWithAggregatesFilter<"organization"> | string | null
    conciergeEmail?: StringNullableWithAggregatesFilter<"organization"> | string | null
    conciergeID?: StringNullableWithAggregatesFilter<"organization"> | string | null
    conciergeName?: StringNullableWithAggregatesFilter<"organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"organization"> | Date | string
    description?: StringNullableWithAggregatesFilter<"organization"> | string | null
    name?: StringWithAggregatesFilter<"organization"> | string
    rootPath?: StringNullableWithAggregatesFilter<"organization"> | string | null
    status?: StringWithAggregatesFilter<"organization"> | string
    updateAt?: DateTimeWithAggregatesFilter<"organization"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"organization"> | Date | string | null
  }

  export type qcResultsWhereInput = {
    AND?: qcResultsWhereInput | qcResultsWhereInput[]
    OR?: qcResultsWhereInput[]
    NOT?: qcResultsWhereInput | qcResultsWhereInput[]
    id?: StringFilter<"qcResults"> | string
    batchIDs?: StringNullableListFilter<"qcResults">
    dataRecordID?: StringFilter<"qcResults"> | string
    displayID?: IntFilter<"qcResults"> | number
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchID?: StringFilter<"qcResults"> | string
    origin?: StringNullableFilter<"qcResults"> | string | null
    severity?: StringFilter<"qcResults"> | string
    submissionID?: StringFilter<"qcResults"> | string
    submittedID?: StringFilter<"qcResults"> | string
    type?: StringFilter<"qcResults"> | string
    uploadedDate?: DateTimeFilter<"qcResults"> | Date | string
    validatedDate?: DateTimeFilter<"qcResults"> | Date | string
    validationType?: StringFilter<"qcResults"> | string
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
  }

  export type qcResultsOrderByWithRelationInput = {
    id?: SortOrder
    batchIDs?: SortOrder
    dataRecordID?: SortOrder
    displayID?: SortOrder
    errors?: ErrorOrderByCompositeAggregateInput
    latestBatchID?: SortOrder
    origin?: SortOrder
    severity?: SortOrder
    submissionID?: SortOrder
    submittedID?: SortOrder
    type?: SortOrder
    uploadedDate?: SortOrder
    validatedDate?: SortOrder
    validationType?: SortOrder
    warnings?: ErrorOrderByCompositeAggregateInput
  }

  export type qcResultsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: qcResultsWhereInput | qcResultsWhereInput[]
    OR?: qcResultsWhereInput[]
    NOT?: qcResultsWhereInput | qcResultsWhereInput[]
    batchIDs?: StringNullableListFilter<"qcResults">
    dataRecordID?: StringFilter<"qcResults"> | string
    displayID?: IntFilter<"qcResults"> | number
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchID?: StringFilter<"qcResults"> | string
    origin?: StringNullableFilter<"qcResults"> | string | null
    severity?: StringFilter<"qcResults"> | string
    submissionID?: StringFilter<"qcResults"> | string
    submittedID?: StringFilter<"qcResults"> | string
    type?: StringFilter<"qcResults"> | string
    uploadedDate?: DateTimeFilter<"qcResults"> | Date | string
    validatedDate?: DateTimeFilter<"qcResults"> | Date | string
    validationType?: StringFilter<"qcResults"> | string
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
  }, "id">

  export type qcResultsOrderByWithAggregationInput = {
    id?: SortOrder
    batchIDs?: SortOrder
    dataRecordID?: SortOrder
    displayID?: SortOrder
    latestBatchID?: SortOrder
    origin?: SortOrder
    severity?: SortOrder
    submissionID?: SortOrder
    submittedID?: SortOrder
    type?: SortOrder
    uploadedDate?: SortOrder
    validatedDate?: SortOrder
    validationType?: SortOrder
    _count?: qcResultsCountOrderByAggregateInput
    _avg?: qcResultsAvgOrderByAggregateInput
    _max?: qcResultsMaxOrderByAggregateInput
    _min?: qcResultsMinOrderByAggregateInput
    _sum?: qcResultsSumOrderByAggregateInput
  }

  export type qcResultsScalarWhereWithAggregatesInput = {
    AND?: qcResultsScalarWhereWithAggregatesInput | qcResultsScalarWhereWithAggregatesInput[]
    OR?: qcResultsScalarWhereWithAggregatesInput[]
    NOT?: qcResultsScalarWhereWithAggregatesInput | qcResultsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"qcResults"> | string
    batchIDs?: StringNullableListFilter<"qcResults">
    dataRecordID?: StringWithAggregatesFilter<"qcResults"> | string
    displayID?: IntWithAggregatesFilter<"qcResults"> | number
    latestBatchID?: StringWithAggregatesFilter<"qcResults"> | string
    origin?: StringNullableWithAggregatesFilter<"qcResults"> | string | null
    severity?: StringWithAggregatesFilter<"qcResults"> | string
    submissionID?: StringWithAggregatesFilter<"qcResults"> | string
    submittedID?: StringWithAggregatesFilter<"qcResults"> | string
    type?: StringWithAggregatesFilter<"qcResults"> | string
    uploadedDate?: DateTimeWithAggregatesFilter<"qcResults"> | Date | string
    validatedDate?: DateTimeWithAggregatesFilter<"qcResults"> | Date | string
    validationType?: StringWithAggregatesFilter<"qcResults"> | string
  }

  export type releaseWhereInput = {
    AND?: releaseWhereInput | releaseWhereInput[]
    OR?: releaseWhereInput[]
    NOT?: releaseWhereInput | releaseWhereInput[]
    id?: StringFilter<"release"> | string
    CRDC_ID?: StringNullableFilter<"release"> | string | null
    createdAt?: DateTimeFilter<"release"> | Date | string
    dataCommons?: StringFilter<"release"> | string
    entityType?: StringNullableFilter<"release"> | string | null
    nodeID?: StringFilter<"release"> | string
    nodeType?: StringFilter<"release"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"release">
    status?: StringFilter<"release"> | string
    studyID?: StringNullableFilter<"release"> | string | null
    submissionID?: StringFilter<"release"> | string
    updatedAt?: DateTimeNullableFilter<"release"> | Date | string | null
  }

  export type releaseOrderByWithRelationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    parents?: ParentOrderByCompositeAggregateInput
    props?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
  }

  export type releaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: releaseWhereInput | releaseWhereInput[]
    OR?: releaseWhereInput[]
    NOT?: releaseWhereInput | releaseWhereInput[]
    CRDC_ID?: StringNullableFilter<"release"> | string | null
    createdAt?: DateTimeFilter<"release"> | Date | string
    dataCommons?: StringFilter<"release"> | string
    entityType?: StringNullableFilter<"release"> | string | null
    nodeID?: StringFilter<"release"> | string
    nodeType?: StringFilter<"release"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"release">
    status?: StringFilter<"release"> | string
    studyID?: StringNullableFilter<"release"> | string | null
    submissionID?: StringFilter<"release"> | string
    updatedAt?: DateTimeNullableFilter<"release"> | Date | string | null
  }, "id">

  export type releaseOrderByWithAggregationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    props?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    _count?: releaseCountOrderByAggregateInput
    _max?: releaseMaxOrderByAggregateInput
    _min?: releaseMinOrderByAggregateInput
  }

  export type releaseScalarWhereWithAggregatesInput = {
    AND?: releaseScalarWhereWithAggregatesInput | releaseScalarWhereWithAggregatesInput[]
    OR?: releaseScalarWhereWithAggregatesInput[]
    NOT?: releaseScalarWhereWithAggregatesInput | releaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"release"> | string
    CRDC_ID?: StringNullableWithAggregatesFilter<"release"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"release"> | Date | string
    dataCommons?: StringWithAggregatesFilter<"release"> | string
    entityType?: StringNullableWithAggregatesFilter<"release"> | string | null
    nodeID?: StringWithAggregatesFilter<"release"> | string
    nodeType?: StringWithAggregatesFilter<"release"> | string
    props?: JsonWithAggregatesFilter<"release">
    status?: StringWithAggregatesFilter<"release"> | string
    studyID?: StringNullableWithAggregatesFilter<"release"> | string | null
    submissionID?: StringWithAggregatesFilter<"release"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"release"> | Date | string | null
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    id?: StringFilter<"sessions"> | string
    expires?: DateTimeFilter<"sessions"> | Date | string
    lastModified?: DateTimeFilter<"sessions"> | Date | string
    session?: StringFilter<"sessions"> | string
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    expires?: SortOrder
    lastModified?: SortOrder
    session?: SortOrder
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    expires?: DateTimeFilter<"sessions"> | Date | string
    lastModified?: DateTimeFilter<"sessions"> | Date | string
    session?: StringFilter<"sessions"> | string
  }, "id">

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    expires?: SortOrder
    lastModified?: SortOrder
    session?: SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"sessions"> | string
    expires?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    lastModified?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    session?: StringWithAggregatesFilter<"sessions"> | string
  }

  export type submissionsWhereInput = {
    AND?: submissionsWhereInput | submissionsWhereInput[]
    OR?: submissionsWhereInput[]
    NOT?: submissionsWhereInput | submissionsWhereInput[]
    id?: StringFilter<"submissions"> | string
    ORCID?: StringNullableFilter<"submissions"> | string | null
    accessedAt?: DateTimeFilter<"submissions"> | Date | string
    archived?: BoolNullableFilter<"submissions"> | boolean | null
    bucketName?: StringFilter<"submissions"> | string
    collaborators?: CollaboratorCompositeListFilter | CollaboratorObjectEqualityInput[]
    collborators?: StringNullableFilter<"submissions"> | string | null
    conciergeEmail?: StringNullableFilter<"submissions"> | string | null
    conciergeName?: StringNullableFilter<"submissions"> | string | null
    controlledAccess?: BoolNullableFilter<"submissions"> | boolean | null
    createdAt?: DateTimeFilter<"submissions"> | Date | string
    crossSubmissionStatus?: StringNullableFilter<"submissions"> | string | null
    dataCommons?: StringFilter<"submissions"> | string
    dataCommonsDisplayName?: StringNullableFilter<"submissions"> | string | null
    dataFileSize?: XOR<DataFileSizeCompositeFilter, DataFileSizeObjectEqualityInput>
    dataType?: StringFilter<"submissions"> | string
    dbGaPID?: StringNullableFilter<"submissions"> | string | null
    deletingData?: BoolNullableFilter<"submissions"> | boolean | null
    fileValidationStatus?: StringNullableFilter<"submissions"> | string | null
    finalInactiveReminder?: BoolNullableFilter<"submissions"> | boolean | null
    history?: HistoryCompositeListFilter | HistoryObjectEqualityInput[]
    inactiveReminder?: BoolNullableFilter<"submissions"> | boolean | null
    inactiveReminder_30?: BoolNullableFilter<"submissions"> | boolean | null
    inactiveReminder_60?: BoolNullableFilter<"submissions"> | boolean | null
    inactiveReminder_7?: BoolNullableFilter<"submissions"> | boolean | null
    intention?: StringFilter<"submissions"> | string
    metadataValidationStatus?: StringNullableFilter<"submissions"> | string | null
    modelVersion?: StringFilter<"submissions"> | string
    name?: StringFilter<"submissions"> | string
    nodeCount?: IntNullableFilter<"submissions"> | number | null
    organization?: XOR<OrgInfoCompositeFilter, OrgInfoObjectEqualityInput>
    reviewComment?: StringNullableFilter<"submissions"> | string | null
    rootPath?: StringFilter<"submissions"> | string
    status?: StringFilter<"submissions"> | string
    studyAbbreviation?: StringNullableFilter<"submissions"> | string | null
    studyID?: StringFilter<"submissions"> | string
    submitterID?: StringFilter<"submissions"> | string
    submitterName?: StringFilter<"submissions"> | string
    updatedAt?: DateTimeFilter<"submissions"> | Date | string
    validationEnded?: DateTimeNullableFilter<"submissions"> | Date | string | null
    validationScope?: StringNullableFilter<"submissions"> | string | null
    validationStarted?: DateTimeNullableFilter<"submissions"> | Date | string | null
    validationType?: StringNullableListFilter<"submissions">
  }

  export type submissionsOrderByWithRelationInput = {
    id?: SortOrder
    ORCID?: SortOrder
    accessedAt?: SortOrder
    archived?: SortOrder
    bucketName?: SortOrder
    collaborators?: CollaboratorOrderByCompositeAggregateInput
    collborators?: SortOrder
    conciergeEmail?: SortOrder
    conciergeName?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    crossSubmissionStatus?: SortOrder
    dataCommons?: SortOrder
    dataCommonsDisplayName?: SortOrder
    dataFileSize?: DataFileSizeOrderByInput
    dataType?: SortOrder
    dbGaPID?: SortOrder
    deletingData?: SortOrder
    fileValidationStatus?: SortOrder
    finalInactiveReminder?: SortOrder
    history?: HistoryOrderByCompositeAggregateInput
    inactiveReminder?: SortOrder
    inactiveReminder_30?: SortOrder
    inactiveReminder_60?: SortOrder
    inactiveReminder_7?: SortOrder
    intention?: SortOrder
    metadataValidationStatus?: SortOrder
    modelVersion?: SortOrder
    name?: SortOrder
    nodeCount?: SortOrder
    organization?: OrgInfoOrderByInput
    reviewComment?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    updatedAt?: SortOrder
    validationEnded?: SortOrder
    validationScope?: SortOrder
    validationStarted?: SortOrder
    validationType?: SortOrder
  }

  export type submissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: submissionsWhereInput | submissionsWhereInput[]
    OR?: submissionsWhereInput[]
    NOT?: submissionsWhereInput | submissionsWhereInput[]
    ORCID?: StringNullableFilter<"submissions"> | string | null
    accessedAt?: DateTimeFilter<"submissions"> | Date | string
    archived?: BoolNullableFilter<"submissions"> | boolean | null
    bucketName?: StringFilter<"submissions"> | string
    collaborators?: CollaboratorCompositeListFilter | CollaboratorObjectEqualityInput[]
    collborators?: StringNullableFilter<"submissions"> | string | null
    conciergeEmail?: StringNullableFilter<"submissions"> | string | null
    conciergeName?: StringNullableFilter<"submissions"> | string | null
    controlledAccess?: BoolNullableFilter<"submissions"> | boolean | null
    createdAt?: DateTimeFilter<"submissions"> | Date | string
    crossSubmissionStatus?: StringNullableFilter<"submissions"> | string | null
    dataCommons?: StringFilter<"submissions"> | string
    dataCommonsDisplayName?: StringNullableFilter<"submissions"> | string | null
    dataFileSize?: XOR<DataFileSizeCompositeFilter, DataFileSizeObjectEqualityInput>
    dataType?: StringFilter<"submissions"> | string
    dbGaPID?: StringNullableFilter<"submissions"> | string | null
    deletingData?: BoolNullableFilter<"submissions"> | boolean | null
    fileValidationStatus?: StringNullableFilter<"submissions"> | string | null
    finalInactiveReminder?: BoolNullableFilter<"submissions"> | boolean | null
    history?: HistoryCompositeListFilter | HistoryObjectEqualityInput[]
    inactiveReminder?: BoolNullableFilter<"submissions"> | boolean | null
    inactiveReminder_30?: BoolNullableFilter<"submissions"> | boolean | null
    inactiveReminder_60?: BoolNullableFilter<"submissions"> | boolean | null
    inactiveReminder_7?: BoolNullableFilter<"submissions"> | boolean | null
    intention?: StringFilter<"submissions"> | string
    metadataValidationStatus?: StringNullableFilter<"submissions"> | string | null
    modelVersion?: StringFilter<"submissions"> | string
    name?: StringFilter<"submissions"> | string
    nodeCount?: IntNullableFilter<"submissions"> | number | null
    organization?: XOR<OrgInfoCompositeFilter, OrgInfoObjectEqualityInput>
    reviewComment?: StringNullableFilter<"submissions"> | string | null
    rootPath?: StringFilter<"submissions"> | string
    status?: StringFilter<"submissions"> | string
    studyAbbreviation?: StringNullableFilter<"submissions"> | string | null
    studyID?: StringFilter<"submissions"> | string
    submitterID?: StringFilter<"submissions"> | string
    submitterName?: StringFilter<"submissions"> | string
    updatedAt?: DateTimeFilter<"submissions"> | Date | string
    validationEnded?: DateTimeNullableFilter<"submissions"> | Date | string | null
    validationScope?: StringNullableFilter<"submissions"> | string | null
    validationStarted?: DateTimeNullableFilter<"submissions"> | Date | string | null
    validationType?: StringNullableListFilter<"submissions">
  }, "id">

  export type submissionsOrderByWithAggregationInput = {
    id?: SortOrder
    ORCID?: SortOrder
    accessedAt?: SortOrder
    archived?: SortOrder
    bucketName?: SortOrder
    collborators?: SortOrder
    conciergeEmail?: SortOrder
    conciergeName?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    crossSubmissionStatus?: SortOrder
    dataCommons?: SortOrder
    dataCommonsDisplayName?: SortOrder
    dataType?: SortOrder
    dbGaPID?: SortOrder
    deletingData?: SortOrder
    fileValidationStatus?: SortOrder
    finalInactiveReminder?: SortOrder
    inactiveReminder?: SortOrder
    inactiveReminder_30?: SortOrder
    inactiveReminder_60?: SortOrder
    inactiveReminder_7?: SortOrder
    intention?: SortOrder
    metadataValidationStatus?: SortOrder
    modelVersion?: SortOrder
    name?: SortOrder
    nodeCount?: SortOrder
    reviewComment?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    updatedAt?: SortOrder
    validationEnded?: SortOrder
    validationScope?: SortOrder
    validationStarted?: SortOrder
    validationType?: SortOrder
    _count?: submissionsCountOrderByAggregateInput
    _avg?: submissionsAvgOrderByAggregateInput
    _max?: submissionsMaxOrderByAggregateInput
    _min?: submissionsMinOrderByAggregateInput
    _sum?: submissionsSumOrderByAggregateInput
  }

  export type submissionsScalarWhereWithAggregatesInput = {
    AND?: submissionsScalarWhereWithAggregatesInput | submissionsScalarWhereWithAggregatesInput[]
    OR?: submissionsScalarWhereWithAggregatesInput[]
    NOT?: submissionsScalarWhereWithAggregatesInput | submissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"submissions"> | string
    ORCID?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    accessedAt?: DateTimeWithAggregatesFilter<"submissions"> | Date | string
    archived?: BoolNullableWithAggregatesFilter<"submissions"> | boolean | null
    bucketName?: StringWithAggregatesFilter<"submissions"> | string
    collborators?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    conciergeEmail?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    conciergeName?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    controlledAccess?: BoolNullableWithAggregatesFilter<"submissions"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"submissions"> | Date | string
    crossSubmissionStatus?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    dataCommons?: StringWithAggregatesFilter<"submissions"> | string
    dataCommonsDisplayName?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    dataType?: StringWithAggregatesFilter<"submissions"> | string
    dbGaPID?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    deletingData?: BoolNullableWithAggregatesFilter<"submissions"> | boolean | null
    fileValidationStatus?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    finalInactiveReminder?: BoolNullableWithAggregatesFilter<"submissions"> | boolean | null
    inactiveReminder?: BoolNullableWithAggregatesFilter<"submissions"> | boolean | null
    inactiveReminder_30?: BoolNullableWithAggregatesFilter<"submissions"> | boolean | null
    inactiveReminder_60?: BoolNullableWithAggregatesFilter<"submissions"> | boolean | null
    inactiveReminder_7?: BoolNullableWithAggregatesFilter<"submissions"> | boolean | null
    intention?: StringWithAggregatesFilter<"submissions"> | string
    metadataValidationStatus?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    modelVersion?: StringWithAggregatesFilter<"submissions"> | string
    name?: StringWithAggregatesFilter<"submissions"> | string
    nodeCount?: IntNullableWithAggregatesFilter<"submissions"> | number | null
    reviewComment?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    rootPath?: StringWithAggregatesFilter<"submissions"> | string
    status?: StringWithAggregatesFilter<"submissions"> | string
    studyAbbreviation?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    studyID?: StringWithAggregatesFilter<"submissions"> | string
    submitterID?: StringWithAggregatesFilter<"submissions"> | string
    submitterName?: StringWithAggregatesFilter<"submissions"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"submissions"> | Date | string
    validationEnded?: DateTimeNullableWithAggregatesFilter<"submissions"> | Date | string | null
    validationScope?: StringNullableWithAggregatesFilter<"submissions"> | string | null
    validationStarted?: DateTimeNullableWithAggregatesFilter<"submissions"> | Date | string | null
    validationType?: StringNullableListFilter<"submissions">
  }

  export type synonymsWhereInput = {
    AND?: synonymsWhereInput | synonymsWhereInput[]
    OR?: synonymsWhereInput[]
    NOT?: synonymsWhereInput | synonymsWhereInput[]
    id?: JsonFilter<"synonyms">
    equivalent_term?: StringFilter<"synonyms"> | string
    synonym_term?: StringFilter<"synonyms"> | string
  }

  export type synonymsOrderByWithRelationInput = {
    id?: SortOrder
    equivalent_term?: SortOrder
    synonym_term?: SortOrder
  }

  export type synonymsWhereUniqueInput = Prisma.AtLeast<{
    id?: InputJsonValue
    AND?: synonymsWhereInput | synonymsWhereInput[]
    OR?: synonymsWhereInput[]
    NOT?: synonymsWhereInput | synonymsWhereInput[]
    equivalent_term?: StringFilter<"synonyms"> | string
    synonym_term?: StringFilter<"synonyms"> | string
  }, "id">

  export type synonymsOrderByWithAggregationInput = {
    id?: SortOrder
    equivalent_term?: SortOrder
    synonym_term?: SortOrder
    _count?: synonymsCountOrderByAggregateInput
    _max?: synonymsMaxOrderByAggregateInput
    _min?: synonymsMinOrderByAggregateInput
  }

  export type synonymsScalarWhereWithAggregatesInput = {
    AND?: synonymsScalarWhereWithAggregatesInput | synonymsScalarWhereWithAggregatesInput[]
    OR?: synonymsScalarWhereWithAggregatesInput[]
    NOT?: synonymsScalarWhereWithAggregatesInput | synonymsScalarWhereWithAggregatesInput[]
    id?: JsonWithAggregatesFilter<"synonyms">
    equivalent_term?: StringWithAggregatesFilter<"synonyms"> | string
    synonym_term?: StringWithAggregatesFilter<"synonyms"> | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    IDP?: StringFilter<"users"> | string
    createdAt?: DateTimeFilter<"users"> | Date | string
    dataCommons?: StringNullableListFilter<"users">
    email?: StringFilter<"users"> | string
    firstName?: StringFilter<"users"> | string
    institution?: XOR<InstitutionNullableCompositeFilter, InstitutionObjectEqualityInput> | null
    lastName?: StringFilter<"users"> | string
    notifications?: StringNullableListFilter<"users">
    organization?: XOR<OrgInfoNullableCompositeFilter, OrgInfoObjectEqualityInput> | null
    permissions?: StringNullableListFilter<"users">
    role?: StringFilter<"users"> | string
    status?: StringNullableFilter<"users"> | string | null
    studies?: StudyByIDCompositeListFilter | StudyByIDObjectEqualityInput[]
    tokens?: StringNullableListFilter<"users">
    updateAt?: DateTimeFilter<"users"> | Date | string
    userStatus?: StringFilter<"users"> | string
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    IDP?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    institution?: InstitutionOrderByInput
    lastName?: SortOrder
    notifications?: SortOrder
    organization?: OrgInfoOrderByInput
    permissions?: SortOrder
    role?: SortOrder
    status?: SortOrder
    studies?: StudyByIDOrderByCompositeAggregateInput
    tokens?: SortOrder
    updateAt?: SortOrder
    userStatus?: SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    IDP?: StringFilter<"users"> | string
    createdAt?: DateTimeFilter<"users"> | Date | string
    dataCommons?: StringNullableListFilter<"users">
    email?: StringFilter<"users"> | string
    firstName?: StringFilter<"users"> | string
    institution?: XOR<InstitutionNullableCompositeFilter, InstitutionObjectEqualityInput> | null
    lastName?: StringFilter<"users"> | string
    notifications?: StringNullableListFilter<"users">
    organization?: XOR<OrgInfoNullableCompositeFilter, OrgInfoObjectEqualityInput> | null
    permissions?: StringNullableListFilter<"users">
    role?: StringFilter<"users"> | string
    status?: StringNullableFilter<"users"> | string | null
    studies?: StudyByIDCompositeListFilter | StudyByIDObjectEqualityInput[]
    tokens?: StringNullableListFilter<"users">
    updateAt?: DateTimeFilter<"users"> | Date | string
    userStatus?: StringFilter<"users"> | string
  }, "id">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    IDP?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    notifications?: SortOrder
    permissions?: SortOrder
    role?: SortOrder
    status?: SortOrder
    tokens?: SortOrder
    updateAt?: SortOrder
    userStatus?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    IDP?: StringWithAggregatesFilter<"users"> | string
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    dataCommons?: StringNullableListFilter<"users">
    email?: StringWithAggregatesFilter<"users"> | string
    firstName?: StringWithAggregatesFilter<"users"> | string
    lastName?: StringWithAggregatesFilter<"users"> | string
    notifications?: StringNullableListFilter<"users">
    permissions?: StringNullableListFilter<"users">
    role?: StringWithAggregatesFilter<"users"> | string
    status?: StringNullableWithAggregatesFilter<"users"> | string | null
    tokens?: StringNullableListFilter<"users">
    updateAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    userStatus?: StringWithAggregatesFilter<"users"> | string
  }

  export type validationWhereInput = {
    AND?: validationWhereInput | validationWhereInput[]
    OR?: validationWhereInput[]
    NOT?: validationWhereInput | validationWhereInput[]
    id?: StringFilter<"validation"> | string
    ended?: DateTimeNullableFilter<"validation"> | Date | string | null
    scope?: StringNullableFilter<"validation"> | string | null
    started?: DateTimeFilter<"validation"> | Date | string
    status?: StringNullableFilter<"validation"> | string | null
    submissionID?: StringFilter<"validation"> | string
    type?: StringNullableListFilter<"validation">
  }

  export type validationOrderByWithRelationInput = {
    id?: SortOrder
    ended?: SortOrder
    scope?: SortOrder
    started?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    type?: SortOrder
  }

  export type validationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: validationWhereInput | validationWhereInput[]
    OR?: validationWhereInput[]
    NOT?: validationWhereInput | validationWhereInput[]
    ended?: DateTimeNullableFilter<"validation"> | Date | string | null
    scope?: StringNullableFilter<"validation"> | string | null
    started?: DateTimeFilter<"validation"> | Date | string
    status?: StringNullableFilter<"validation"> | string | null
    submissionID?: StringFilter<"validation"> | string
    type?: StringNullableListFilter<"validation">
  }, "id">

  export type validationOrderByWithAggregationInput = {
    id?: SortOrder
    ended?: SortOrder
    scope?: SortOrder
    started?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    type?: SortOrder
    _count?: validationCountOrderByAggregateInput
    _max?: validationMaxOrderByAggregateInput
    _min?: validationMinOrderByAggregateInput
  }

  export type validationScalarWhereWithAggregatesInput = {
    AND?: validationScalarWhereWithAggregatesInput | validationScalarWhereWithAggregatesInput[]
    OR?: validationScalarWhereWithAggregatesInput[]
    NOT?: validationScalarWhereWithAggregatesInput | validationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"validation"> | string
    ended?: DateTimeNullableWithAggregatesFilter<"validation"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"validation"> | string | null
    started?: DateTimeWithAggregatesFilter<"validation"> | Date | string
    status?: StringNullableWithAggregatesFilter<"validation"> | string | null
    submissionID?: StringWithAggregatesFilter<"validation"> | string
    type?: StringNullableListFilter<"validation">
  }

  export type CDECreateInput = {
    id: string
    CDECode: string
    CDEFullName: string
    CDEVersion?: string | null
    PermissibleValues?: CDECreatePermissibleValuesInput | string[]
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CDEUncheckedCreateInput = {
    id: string
    CDECode: string
    CDEFullName: string
    CDEVersion?: string | null
    PermissibleValues?: CDECreatePermissibleValuesInput | string[]
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CDEUpdateInput = {
    CDECode?: StringFieldUpdateOperationsInput | string
    CDEFullName?: StringFieldUpdateOperationsInput | string
    CDEVersion?: NullableStringFieldUpdateOperationsInput | string | null
    PermissibleValues?: CDEUpdatePermissibleValuesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CDEUncheckedUpdateInput = {
    CDECode?: StringFieldUpdateOperationsInput | string
    CDEFullName?: StringFieldUpdateOperationsInput | string
    CDEVersion?: NullableStringFieldUpdateOperationsInput | string | null
    PermissibleValues?: CDEUpdatePermissibleValuesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CDECreateManyInput = {
    id: string
    CDECode: string
    CDEFullName: string
    CDEVersion?: string | null
    PermissibleValues?: CDECreatePermissibleValuesInput | string[]
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type CDEUpdateManyMutationInput = {
    CDECode?: StringFieldUpdateOperationsInput | string
    CDEFullName?: StringFieldUpdateOperationsInput | string
    CDEVersion?: NullableStringFieldUpdateOperationsInput | string | null
    PermissibleValues?: CDEUpdatePermissibleValuesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CDEUncheckedUpdateManyInput = {
    CDECode?: StringFieldUpdateOperationsInput | string
    CDEFullName?: StringFieldUpdateOperationsInput | string
    CDEVersion?: NullableStringFieldUpdateOperationsInput | string | null
    PermissibleValues?: CDEUpdatePermissibleValuesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type applicationsCreateInput = {
    id: string
    ORCID?: string | null
    PI?: string | null
    applicant: XOR<ApplicantCreateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: boolean | null
    createdAt: Date | string
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    openAccess?: boolean | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: string | null
    programDescription?: string | null
    programName: string
    questionnaireData: string
    reviewComment?: string | null
    status: string
    studyAbbreviation: string
    studyName: string
    submittedDate?: Date | string | null
    updatedAt: Date | string
    version: string
    wholeProgram?: boolean | null
  }

  export type applicationsUncheckedCreateInput = {
    id: string
    ORCID?: string | null
    PI?: string | null
    applicant: XOR<ApplicantCreateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: boolean | null
    createdAt: Date | string
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    openAccess?: boolean | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: string | null
    programDescription?: string | null
    programName: string
    questionnaireData: string
    reviewComment?: string | null
    status: string
    studyAbbreviation: string
    studyName: string
    submittedDate?: Date | string | null
    updatedAt: Date | string
    version: string
    wholeProgram?: boolean | null
  }

  export type applicationsUpdateInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    applicant?: XOR<ApplicantUpdateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    programDescription?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: StringFieldUpdateOperationsInput | string
    questionnaireData?: StringFieldUpdateOperationsInput | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    submittedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    wholeProgram?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type applicationsUncheckedUpdateInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    applicant?: XOR<ApplicantUpdateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    programDescription?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: StringFieldUpdateOperationsInput | string
    questionnaireData?: StringFieldUpdateOperationsInput | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    submittedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    wholeProgram?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type applicationsCreateManyInput = {
    id: string
    ORCID?: string | null
    PI?: string | null
    applicant: XOR<ApplicantCreateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: boolean | null
    createdAt: Date | string
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    openAccess?: boolean | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: string | null
    programDescription?: string | null
    programName: string
    questionnaireData: string
    reviewComment?: string | null
    status: string
    studyAbbreviation: string
    studyName: string
    submittedDate?: Date | string | null
    updatedAt: Date | string
    version: string
    wholeProgram?: boolean | null
  }

  export type applicationsUpdateManyMutationInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    applicant?: XOR<ApplicantUpdateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    programDescription?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: StringFieldUpdateOperationsInput | string
    questionnaireData?: StringFieldUpdateOperationsInput | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    submittedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    wholeProgram?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type applicationsUncheckedUpdateManyInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    applicant?: XOR<ApplicantUpdateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    programDescription?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: StringFieldUpdateOperationsInput | string
    questionnaireData?: StringFieldUpdateOperationsInput | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    submittedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
    wholeProgram?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type approvedStudiesCreateInput = {
    id: string
    ORCID?: string | null
    PI?: string | null
    controlledAccess: boolean
    createdAt: Date | string
    dbGaPID?: string | null
    openAccess?: boolean | null
    originalOrg?: string | null
    primaryContactID?: string | null
    programName?: string | null
    studyAbbreviation: string
    studyName: string
    updatedAt: Date | string
    useProgramPC?: boolean | null
  }

  export type approvedStudiesUncheckedCreateInput = {
    id: string
    ORCID?: string | null
    PI?: string | null
    controlledAccess: boolean
    createdAt: Date | string
    dbGaPID?: string | null
    openAccess?: boolean | null
    originalOrg?: string | null
    primaryContactID?: string | null
    programName?: string | null
    studyAbbreviation: string
    studyName: string
    updatedAt: Date | string
    useProgramPC?: boolean | null
  }

  export type approvedStudiesUpdateInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalOrg?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactID?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: NullableStringFieldUpdateOperationsInput | string | null
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    useProgramPC?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type approvedStudiesUncheckedUpdateInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalOrg?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactID?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: NullableStringFieldUpdateOperationsInput | string | null
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    useProgramPC?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type approvedStudiesCreateManyInput = {
    id: string
    ORCID?: string | null
    PI?: string | null
    controlledAccess: boolean
    createdAt: Date | string
    dbGaPID?: string | null
    openAccess?: boolean | null
    originalOrg?: string | null
    primaryContactID?: string | null
    programName?: string | null
    studyAbbreviation: string
    studyName: string
    updatedAt: Date | string
    useProgramPC?: boolean | null
  }

  export type approvedStudiesUpdateManyMutationInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalOrg?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactID?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: NullableStringFieldUpdateOperationsInput | string | null
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    useProgramPC?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type approvedStudiesUncheckedUpdateManyInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalOrg?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactID?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: NullableStringFieldUpdateOperationsInput | string | null
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    useProgramPC?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type batchCreateInput = {
    id: string
    bucketName: string
    createdAt: Date | string
    displayID: number
    errors?: batchCreateerrorsInput | string[]
    fileCount: number
    filePrefix: string
    files?: XOR<BatchFilesListCreateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status: string
    submissionID: string
    submitterID?: string | null
    submitterName?: string | null
    type: string
    updatedAt: Date | string
    zipFileName?: string | null
  }

  export type batchUncheckedCreateInput = {
    id: string
    bucketName: string
    createdAt: Date | string
    displayID: number
    errors?: batchCreateerrorsInput | string[]
    fileCount: number
    filePrefix: string
    files?: XOR<BatchFilesListCreateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status: string
    submissionID: string
    submitterID?: string | null
    submitterName?: string | null
    type: string
    updatedAt: Date | string
    zipFileName?: string | null
  }

  export type batchUpdateInput = {
    bucketName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: batchUpdateerrorsInput | string[]
    fileCount?: IntFieldUpdateOperationsInput | number
    filePrefix?: StringFieldUpdateOperationsInput | string
    files?: XOR<BatchFilesListUpdateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submitterID?: NullableStringFieldUpdateOperationsInput | string | null
    submitterName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zipFileName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type batchUncheckedUpdateInput = {
    bucketName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: batchUpdateerrorsInput | string[]
    fileCount?: IntFieldUpdateOperationsInput | number
    filePrefix?: StringFieldUpdateOperationsInput | string
    files?: XOR<BatchFilesListUpdateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submitterID?: NullableStringFieldUpdateOperationsInput | string | null
    submitterName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zipFileName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type batchCreateManyInput = {
    id: string
    bucketName: string
    createdAt: Date | string
    displayID: number
    errors?: batchCreateerrorsInput | string[]
    fileCount: number
    filePrefix: string
    files?: XOR<BatchFilesListCreateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status: string
    submissionID: string
    submitterID?: string | null
    submitterName?: string | null
    type: string
    updatedAt: Date | string
    zipFileName?: string | null
  }

  export type batchUpdateManyMutationInput = {
    bucketName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: batchUpdateerrorsInput | string[]
    fileCount?: IntFieldUpdateOperationsInput | number
    filePrefix?: StringFieldUpdateOperationsInput | string
    files?: XOR<BatchFilesListUpdateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submitterID?: NullableStringFieldUpdateOperationsInput | string | null
    submitterName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zipFileName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type batchUncheckedUpdateManyInput = {
    bucketName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: batchUpdateerrorsInput | string[]
    fileCount?: IntFieldUpdateOperationsInput | number
    filePrefix?: StringFieldUpdateOperationsInput | string
    files?: XOR<BatchFilesListUpdateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submitterID?: NullableStringFieldUpdateOperationsInput | string | null
    submitterName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zipFileName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type configurationCreateInput = {
    id: string
    COMPLETED_RETENTION_DAYS?: number | null
    DASHBOARD_SESSION_TIMEOUT?: number | null
    Defaults?: XOR<PBACDefaultsListCreateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: string | null
    INACTIVE_APPLICATION_DAYS?: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: number | null
    INACTIVE_USER_DAYS?: number | null
    OFFICIAL_EMAIL?: string | null
    PRESIGN_EXPIRATION?: number | null
    PROD_URL?: string | null
    REMIND_APPLICATION_DAYS?: number | null
    REVIEW_COMMITTEE_EMAIL?: configurationCreateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: number | null
    SCHEDULED_JOBS?: string | null
    SUBMISSION_BUCKET?: string | null
    SUBMISSION_HELPDESK?: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: string | null
    SUBMISSION_SYSTEM_PORTAL?: string | null
    TECH_SUPPORT_EMAIL?: string | null
    age?: number | null
    bucketName?: string | null
    current?: string | null
    current_version?: string | null
    dashboardID?: string | null
    dataCommons?: string | null
    days?: number | null
    interval?: number | null
    key?: configurationCreatekeyInput | string[]
    keys?: InputJsonValue | null
    new?: string | null
    prefix?: string | null
    tag?: XOR<ConfigurationTagNullableCreateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: number | null
    type: string
    version?: string | null
  }

  export type configurationUncheckedCreateInput = {
    id: string
    COMPLETED_RETENTION_DAYS?: number | null
    DASHBOARD_SESSION_TIMEOUT?: number | null
    Defaults?: XOR<PBACDefaultsListCreateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: string | null
    INACTIVE_APPLICATION_DAYS?: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: number | null
    INACTIVE_USER_DAYS?: number | null
    OFFICIAL_EMAIL?: string | null
    PRESIGN_EXPIRATION?: number | null
    PROD_URL?: string | null
    REMIND_APPLICATION_DAYS?: number | null
    REVIEW_COMMITTEE_EMAIL?: configurationCreateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: number | null
    SCHEDULED_JOBS?: string | null
    SUBMISSION_BUCKET?: string | null
    SUBMISSION_HELPDESK?: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: string | null
    SUBMISSION_SYSTEM_PORTAL?: string | null
    TECH_SUPPORT_EMAIL?: string | null
    age?: number | null
    bucketName?: string | null
    current?: string | null
    current_version?: string | null
    dashboardID?: string | null
    dataCommons?: string | null
    days?: number | null
    interval?: number | null
    key?: configurationCreatekeyInput | string[]
    keys?: InputJsonValue | null
    new?: string | null
    prefix?: string | null
    tag?: XOR<ConfigurationTagNullableCreateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: number | null
    type: string
    version?: string | null
  }

  export type configurationUpdateInput = {
    COMPLETED_RETENTION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    DASHBOARD_SESSION_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    Defaults?: XOR<PBACDefaultsListUpdateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: NullableStringFieldUpdateOperationsInput | string | null
    INACTIVE_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_USER_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    OFFICIAL_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PRESIGN_EXPIRATION?: NullableIntFieldUpdateOperationsInput | number | null
    PROD_URL?: NullableStringFieldUpdateOperationsInput | string | null
    REMIND_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    REVIEW_COMMITTEE_EMAIL?: configurationUpdateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    SCHEDULED_JOBS?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_BUCKET?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_HELPDESK?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_SYSTEM_PORTAL?: NullableStringFieldUpdateOperationsInput | string | null
    TECH_SUPPORT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    current?: NullableStringFieldUpdateOperationsInput | string | null
    current_version?: NullableStringFieldUpdateOperationsInput | string | null
    dashboardID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: NullableStringFieldUpdateOperationsInput | string | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    key?: configurationUpdatekeyInput | string[]
    keys?: InputJsonValue | InputJsonValue | null
    new?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: XOR<ConfigurationTagNullableUpdateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type configurationUncheckedUpdateInput = {
    COMPLETED_RETENTION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    DASHBOARD_SESSION_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    Defaults?: XOR<PBACDefaultsListUpdateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: NullableStringFieldUpdateOperationsInput | string | null
    INACTIVE_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_USER_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    OFFICIAL_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PRESIGN_EXPIRATION?: NullableIntFieldUpdateOperationsInput | number | null
    PROD_URL?: NullableStringFieldUpdateOperationsInput | string | null
    REMIND_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    REVIEW_COMMITTEE_EMAIL?: configurationUpdateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    SCHEDULED_JOBS?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_BUCKET?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_HELPDESK?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_SYSTEM_PORTAL?: NullableStringFieldUpdateOperationsInput | string | null
    TECH_SUPPORT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    current?: NullableStringFieldUpdateOperationsInput | string | null
    current_version?: NullableStringFieldUpdateOperationsInput | string | null
    dashboardID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: NullableStringFieldUpdateOperationsInput | string | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    key?: configurationUpdatekeyInput | string[]
    keys?: InputJsonValue | InputJsonValue | null
    new?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: XOR<ConfigurationTagNullableUpdateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type configurationCreateManyInput = {
    id: string
    COMPLETED_RETENTION_DAYS?: number | null
    DASHBOARD_SESSION_TIMEOUT?: number | null
    Defaults?: XOR<PBACDefaultsListCreateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: string | null
    INACTIVE_APPLICATION_DAYS?: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: number | null
    INACTIVE_USER_DAYS?: number | null
    OFFICIAL_EMAIL?: string | null
    PRESIGN_EXPIRATION?: number | null
    PROD_URL?: string | null
    REMIND_APPLICATION_DAYS?: number | null
    REVIEW_COMMITTEE_EMAIL?: configurationCreateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: number | null
    SCHEDULED_JOBS?: string | null
    SUBMISSION_BUCKET?: string | null
    SUBMISSION_HELPDESK?: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: string | null
    SUBMISSION_SYSTEM_PORTAL?: string | null
    TECH_SUPPORT_EMAIL?: string | null
    age?: number | null
    bucketName?: string | null
    current?: string | null
    current_version?: string | null
    dashboardID?: string | null
    dataCommons?: string | null
    days?: number | null
    interval?: number | null
    key?: configurationCreatekeyInput | string[]
    keys?: InputJsonValue | null
    new?: string | null
    prefix?: string | null
    tag?: XOR<ConfigurationTagNullableCreateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: number | null
    type: string
    version?: string | null
  }

  export type configurationUpdateManyMutationInput = {
    COMPLETED_RETENTION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    DASHBOARD_SESSION_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    Defaults?: XOR<PBACDefaultsListUpdateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: NullableStringFieldUpdateOperationsInput | string | null
    INACTIVE_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_USER_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    OFFICIAL_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PRESIGN_EXPIRATION?: NullableIntFieldUpdateOperationsInput | number | null
    PROD_URL?: NullableStringFieldUpdateOperationsInput | string | null
    REMIND_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    REVIEW_COMMITTEE_EMAIL?: configurationUpdateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    SCHEDULED_JOBS?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_BUCKET?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_HELPDESK?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_SYSTEM_PORTAL?: NullableStringFieldUpdateOperationsInput | string | null
    TECH_SUPPORT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    current?: NullableStringFieldUpdateOperationsInput | string | null
    current_version?: NullableStringFieldUpdateOperationsInput | string | null
    dashboardID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: NullableStringFieldUpdateOperationsInput | string | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    key?: configurationUpdatekeyInput | string[]
    keys?: InputJsonValue | InputJsonValue | null
    new?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: XOR<ConfigurationTagNullableUpdateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type configurationUncheckedUpdateManyInput = {
    COMPLETED_RETENTION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    DASHBOARD_SESSION_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    Defaults?: XOR<PBACDefaultsListUpdateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: NullableStringFieldUpdateOperationsInput | string | null
    INACTIVE_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_USER_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    OFFICIAL_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PRESIGN_EXPIRATION?: NullableIntFieldUpdateOperationsInput | number | null
    PROD_URL?: NullableStringFieldUpdateOperationsInput | string | null
    REMIND_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    REVIEW_COMMITTEE_EMAIL?: configurationUpdateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    SCHEDULED_JOBS?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_BUCKET?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_HELPDESK?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_SYSTEM_PORTAL?: NullableStringFieldUpdateOperationsInput | string | null
    TECH_SUPPORT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    current?: NullableStringFieldUpdateOperationsInput | string | null
    current_version?: NullableStringFieldUpdateOperationsInput | string | null
    dashboardID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: NullableStringFieldUpdateOperationsInput | string | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    key?: configurationUpdatekeyInput | string[]
    keys?: InputJsonValue | InputJsonValue | null
    new?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: XOR<ConfigurationTagNullableUpdateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dataRecordsCreateInput = {
    id: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsCreatebatchIDsInput | string[]
    createdAt: Date | string
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID: string
    submissionID: string
    updatedAt: Date | string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsUncheckedCreateInput = {
    id: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsCreatebatchIDsInput | string[]
    createdAt: Date | string
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID: string
    submissionID: string
    updatedAt: Date | string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsUpdatebatchIDsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsUncheckedUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsUpdatebatchIDsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsCreateManyInput = {
    id: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsCreatebatchIDsInput | string[]
    createdAt: Date | string
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID: string
    submissionID: string
    updatedAt: Date | string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsUpdateManyMutationInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsUpdatebatchIDsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsUncheckedUpdateManyInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsUpdatebatchIDsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsArchivedCreateInput = {
    id: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsArchivedCreatebatchIDsInput | string[]
    createdAt: Date | string
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID?: string | null
    submissionID: string
    updatedAt: Date | string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsArchivedUncheckedCreateInput = {
    id: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsArchivedCreatebatchIDsInput | string[]
    createdAt: Date | string
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID?: string | null
    submissionID: string
    updatedAt: Date | string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsArchivedUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsArchivedUpdatebatchIDsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsArchivedUncheckedUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsArchivedUpdatebatchIDsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsArchivedCreateManyInput = {
    id: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsArchivedCreatebatchIDsInput | string[]
    createdAt: Date | string
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID?: string | null
    submissionID: string
    updatedAt: Date | string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsArchivedUpdateManyMutationInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsArchivedUpdatebatchIDsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type dataRecordsArchivedUncheckedUpdateManyInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: dataRecordsArchivedUpdatebatchIDsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type fileMD5CreateInput = {
    id: string
    LastModified: Date | string
    createdAt: Date | string
    fileName: string
    md5: string
    submissionID: string
    updatedAt: Date | string
  }

  export type fileMD5UncheckedCreateInput = {
    id: string
    LastModified: Date | string
    createdAt: Date | string
    fileName: string
    md5: string
    submissionID: string
    updatedAt: Date | string
  }

  export type fileMD5UpdateInput = {
    LastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    md5?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fileMD5UncheckedUpdateInput = {
    LastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    md5?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fileMD5CreateManyInput = {
    id: string
    LastModified: Date | string
    createdAt: Date | string
    fileName: string
    md5: string
    submissionID: string
    updatedAt: Date | string
  }

  export type fileMD5UpdateManyMutationInput = {
    LastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    md5?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fileMD5UncheckedUpdateManyInput = {
    LastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    md5?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type institutionsCreateInput = {
    id: string
    createdAt?: Date | string | null
    name: string
    status: string
    submitterCount?: number | null
    updatedAt?: Date | string | null
  }

  export type institutionsUncheckedCreateInput = {
    id: string
    createdAt?: Date | string | null
    name: string
    status: string
    submitterCount?: number | null
    updatedAt?: Date | string | null
  }

  export type institutionsUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submitterCount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type institutionsUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submitterCount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type institutionsCreateManyInput = {
    id: string
    createdAt?: Date | string | null
    name: string
    status: string
    submitterCount?: number | null
    updatedAt?: Date | string | null
  }

  export type institutionsUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submitterCount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type institutionsUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submitterCount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type logsCreateInput = {
    id: string
    action?: string | null
    applicationID?: string | null
    eventDetail?: XOR<LogsEventDetailNullableCreateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType: string
    localtime: Date | string
    newProfile?: InputJsonValue | null
    newState?: string | null
    prevProfile?: InputJsonValue | null
    prevState?: string | null
    submissionID?: string | null
    timestamp: number
    userEmail: string
    userID: string
    userIDP?: string | null
    userName?: string | null
  }

  export type logsUncheckedCreateInput = {
    id: string
    action?: string | null
    applicationID?: string | null
    eventDetail?: XOR<LogsEventDetailNullableCreateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType: string
    localtime: Date | string
    newProfile?: InputJsonValue | null
    newState?: string | null
    prevProfile?: InputJsonValue | null
    prevState?: string | null
    submissionID?: string | null
    timestamp: number
    userEmail: string
    userID: string
    userIDP?: string | null
    userName?: string | null
  }

  export type logsUpdateInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    applicationID?: NullableStringFieldUpdateOperationsInput | string | null
    eventDetail?: XOR<LogsEventDetailNullableUpdateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType?: StringFieldUpdateOperationsInput | string
    localtime?: DateTimeFieldUpdateOperationsInput | Date | string
    newProfile?: InputJsonValue | InputJsonValue | null
    newState?: NullableStringFieldUpdateOperationsInput | string | null
    prevProfile?: InputJsonValue | InputJsonValue | null
    prevState?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: FloatFieldUpdateOperationsInput | number
    userEmail?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    userIDP?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logsUncheckedUpdateInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    applicationID?: NullableStringFieldUpdateOperationsInput | string | null
    eventDetail?: XOR<LogsEventDetailNullableUpdateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType?: StringFieldUpdateOperationsInput | string
    localtime?: DateTimeFieldUpdateOperationsInput | Date | string
    newProfile?: InputJsonValue | InputJsonValue | null
    newState?: NullableStringFieldUpdateOperationsInput | string | null
    prevProfile?: InputJsonValue | InputJsonValue | null
    prevState?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: FloatFieldUpdateOperationsInput | number
    userEmail?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    userIDP?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logsCreateManyInput = {
    id: string
    action?: string | null
    applicationID?: string | null
    eventDetail?: XOR<LogsEventDetailNullableCreateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType: string
    localtime: Date | string
    newProfile?: InputJsonValue | null
    newState?: string | null
    prevProfile?: InputJsonValue | null
    prevState?: string | null
    submissionID?: string | null
    timestamp: number
    userEmail: string
    userID: string
    userIDP?: string | null
    userName?: string | null
  }

  export type logsUpdateManyMutationInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    applicationID?: NullableStringFieldUpdateOperationsInput | string | null
    eventDetail?: XOR<LogsEventDetailNullableUpdateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType?: StringFieldUpdateOperationsInput | string
    localtime?: DateTimeFieldUpdateOperationsInput | Date | string
    newProfile?: InputJsonValue | InputJsonValue | null
    newState?: NullableStringFieldUpdateOperationsInput | string | null
    prevProfile?: InputJsonValue | InputJsonValue | null
    prevState?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: FloatFieldUpdateOperationsInput | number
    userEmail?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    userIDP?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logsUncheckedUpdateManyInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    applicationID?: NullableStringFieldUpdateOperationsInput | string | null
    eventDetail?: XOR<LogsEventDetailNullableUpdateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType?: StringFieldUpdateOperationsInput | string
    localtime?: DateTimeFieldUpdateOperationsInput | Date | string
    newProfile?: InputJsonValue | InputJsonValue | null
    newState?: NullableStringFieldUpdateOperationsInput | string | null
    prevProfile?: InputJsonValue | InputJsonValue | null
    prevState?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: FloatFieldUpdateOperationsInput | number
    userEmail?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    userIDP?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organizationCreateInput = {
    id: string
    abbreviation?: string | null
    bucketName?: string | null
    conciergeEmail?: string | null
    conciergeID?: string | null
    conciergeName?: string | null
    createdAt: Date | string
    description?: string | null
    name: string
    rootPath?: string | null
    status: string
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    updateAt: Date | string
    updatedAt?: Date | string | null
  }

  export type organizationUncheckedCreateInput = {
    id: string
    abbreviation?: string | null
    bucketName?: string | null
    conciergeEmail?: string | null
    conciergeID?: string | null
    conciergeName?: string | null
    createdAt: Date | string
    description?: string | null
    name: string
    rootPath?: string | null
    status: string
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    updateAt: Date | string
    updatedAt?: Date | string | null
  }

  export type organizationUpdateInput = {
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeID?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rootPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type organizationUncheckedUpdateInput = {
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeID?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rootPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type organizationCreateManyInput = {
    id: string
    abbreviation?: string | null
    bucketName?: string | null
    conciergeEmail?: string | null
    conciergeID?: string | null
    conciergeName?: string | null
    createdAt: Date | string
    description?: string | null
    name: string
    rootPath?: string | null
    status: string
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    updateAt: Date | string
    updatedAt?: Date | string | null
  }

  export type organizationUpdateManyMutationInput = {
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeID?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rootPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type organizationUncheckedUpdateManyInput = {
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeID?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rootPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type qcResultsCreateInput = {
    id: string
    batchIDs?: qcResultsCreatebatchIDsInput | string[]
    dataRecordID: string
    displayID: number
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID: string
    origin?: string | null
    severity: string
    submissionID: string
    submittedID: string
    type: string
    uploadedDate: Date | string
    validatedDate: Date | string
    validationType: string
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type qcResultsUncheckedCreateInput = {
    id: string
    batchIDs?: qcResultsCreatebatchIDsInput | string[]
    dataRecordID: string
    displayID: number
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID: string
    origin?: string | null
    severity: string
    submissionID: string
    submittedID: string
    type: string
    uploadedDate: Date | string
    validatedDate: Date | string
    validationType: string
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type qcResultsUpdateInput = {
    batchIDs?: qcResultsUpdatebatchIDsInput | string[]
    dataRecordID?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submittedID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validationType?: StringFieldUpdateOperationsInput | string
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type qcResultsUncheckedUpdateInput = {
    batchIDs?: qcResultsUpdatebatchIDsInput | string[]
    dataRecordID?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submittedID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validationType?: StringFieldUpdateOperationsInput | string
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type qcResultsCreateManyInput = {
    id: string
    batchIDs?: qcResultsCreatebatchIDsInput | string[]
    dataRecordID: string
    displayID: number
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID: string
    origin?: string | null
    severity: string
    submissionID: string
    submittedID: string
    type: string
    uploadedDate: Date | string
    validatedDate: Date | string
    validationType: string
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type qcResultsUpdateManyMutationInput = {
    batchIDs?: qcResultsUpdatebatchIDsInput | string[]
    dataRecordID?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submittedID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validationType?: StringFieldUpdateOperationsInput | string
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type qcResultsUncheckedUpdateManyInput = {
    batchIDs?: qcResultsUpdatebatchIDsInput | string[]
    dataRecordID?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submittedID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validationType?: StringFieldUpdateOperationsInput | string
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type releaseCreateInput = {
    id: string
    CRDC_ID?: string | null
    createdAt: Date | string
    dataCommons: string
    entityType?: string | null
    nodeID: string
    nodeType: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    status: string
    studyID?: string | null
    submissionID: string
    updatedAt?: Date | string | null
  }

  export type releaseUncheckedCreateInput = {
    id: string
    CRDC_ID?: string | null
    createdAt: Date | string
    dataCommons: string
    entityType?: string | null
    nodeID: string
    nodeType: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    status: string
    studyID?: string | null
    submissionID: string
    updatedAt?: Date | string | null
  }

  export type releaseUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type releaseUncheckedUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type releaseCreateManyInput = {
    id: string
    CRDC_ID?: string | null
    createdAt: Date | string
    dataCommons: string
    entityType?: string | null
    nodeID: string
    nodeType: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    status: string
    studyID?: string | null
    submissionID: string
    updatedAt?: Date | string | null
  }

  export type releaseUpdateManyMutationInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type releaseUncheckedUpdateManyInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsCreateInput = {
    id: string
    expires: Date | string
    lastModified: Date | string
    session: string
  }

  export type sessionsUncheckedCreateInput = {
    id: string
    expires: Date | string
    lastModified: Date | string
    session: string
  }

  export type sessionsUpdateInput = {
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsUncheckedUpdateInput = {
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsCreateManyInput = {
    id: string
    expires: Date | string
    lastModified: Date | string
    session: string
  }

  export type sessionsUpdateManyMutationInput = {
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsUncheckedUpdateManyInput = {
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    lastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StringFieldUpdateOperationsInput | string
  }

  export type submissionsCreateInput = {
    id: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    collborators?: string | null
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    createdAt: Date | string
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    updatedAt: Date | string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: submissionsCreatevalidationTypeInput | string[]
  }

  export type submissionsUncheckedCreateInput = {
    id: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    collborators?: string | null
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    createdAt: Date | string
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    updatedAt: Date | string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: submissionsCreatevalidationTypeInput | string[]
  }

  export type submissionsUpdateInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    collborators?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: submissionsUpdatevalidationTypeInput | string[]
  }

  export type submissionsUncheckedUpdateInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    collborators?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: submissionsUpdatevalidationTypeInput | string[]
  }

  export type submissionsCreateManyInput = {
    id: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    collborators?: string | null
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    createdAt: Date | string
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    updatedAt: Date | string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: submissionsCreatevalidationTypeInput | string[]
  }

  export type submissionsUpdateManyMutationInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    collborators?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: submissionsUpdatevalidationTypeInput | string[]
  }

  export type submissionsUncheckedUpdateManyInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    collborators?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: submissionsUpdatevalidationTypeInput | string[]
  }

  export type synonymsCreateInput = {
    id: InputJsonValue
    equivalent_term: string
    synonym_term: string
  }

  export type synonymsUncheckedCreateInput = {
    id: InputJsonValue
    equivalent_term: string
    synonym_term: string
  }

  export type synonymsUpdateInput = {
    equivalent_term?: StringFieldUpdateOperationsInput | string
    synonym_term?: StringFieldUpdateOperationsInput | string
  }

  export type synonymsUncheckedUpdateInput = {
    equivalent_term?: StringFieldUpdateOperationsInput | string
    synonym_term?: StringFieldUpdateOperationsInput | string
  }

  export type synonymsCreateManyInput = {
    id: InputJsonValue
    equivalent_term: string
    synonym_term: string
  }

  export type synonymsUpdateManyMutationInput = {
    equivalent_term?: StringFieldUpdateOperationsInput | string
    synonym_term?: StringFieldUpdateOperationsInput | string
  }

  export type synonymsUncheckedUpdateManyInput = {
    equivalent_term?: StringFieldUpdateOperationsInput | string
    synonym_term?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateInput = {
    id: string
    IDP: string
    createdAt: Date | string
    dataCommons?: usersCreatedataCommonsInput | string[]
    email: string
    firstName: string
    institution?: XOR<InstitutionNullableCreateEnvelopeInput, InstitutionCreateInput> | null
    lastName: string
    notifications?: usersCreatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableCreateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: usersCreatepermissionsInput | string[]
    role: string
    status?: string | null
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: usersCreatetokensInput | string[]
    updateAt: Date | string
    userStatus: string
  }

  export type usersUncheckedCreateInput = {
    id: string
    IDP: string
    createdAt: Date | string
    dataCommons?: usersCreatedataCommonsInput | string[]
    email: string
    firstName: string
    institution?: XOR<InstitutionNullableCreateEnvelopeInput, InstitutionCreateInput> | null
    lastName: string
    notifications?: usersCreatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableCreateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: usersCreatepermissionsInput | string[]
    role: string
    status?: string | null
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: usersCreatetokensInput | string[]
    updateAt: Date | string
    userStatus: string
  }

  export type usersUpdateInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: usersUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionNullableUpdateEnvelopeInput, InstitutionCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: usersUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: usersUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: usersUpdatetokensInput | string[]
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: usersUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionNullableUpdateEnvelopeInput, InstitutionCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: usersUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: usersUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: usersUpdatetokensInput | string[]
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateManyInput = {
    id: string
    IDP: string
    createdAt: Date | string
    dataCommons?: usersCreatedataCommonsInput | string[]
    email: string
    firstName: string
    institution?: XOR<InstitutionNullableCreateEnvelopeInput, InstitutionCreateInput> | null
    lastName: string
    notifications?: usersCreatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableCreateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: usersCreatepermissionsInput | string[]
    role: string
    status?: string | null
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: usersCreatetokensInput | string[]
    updateAt: Date | string
    userStatus: string
  }

  export type usersUpdateManyMutationInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: usersUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionNullableUpdateEnvelopeInput, InstitutionCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: usersUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: usersUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: usersUpdatetokensInput | string[]
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateManyInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCommons?: usersUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionNullableUpdateEnvelopeInput, InstitutionCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: usersUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: usersUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: usersUpdatetokensInput | string[]
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userStatus?: StringFieldUpdateOperationsInput | string
  }

  export type validationCreateInput = {
    id: string
    ended?: Date | string | null
    scope?: string | null
    started: Date | string
    status?: string | null
    submissionID: string
    type?: validationCreatetypeInput | string[]
  }

  export type validationUncheckedCreateInput = {
    id: string
    ended?: Date | string | null
    scope?: string | null
    started: Date | string
    status?: string | null
    submissionID: string
    type?: validationCreatetypeInput | string[]
  }

  export type validationUpdateInput = {
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    type?: validationUpdatetypeInput | string[]
  }

  export type validationUncheckedUpdateInput = {
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    type?: validationUpdatetypeInput | string[]
  }

  export type validationCreateManyInput = {
    id: string
    ended?: Date | string | null
    scope?: string | null
    started: Date | string
    status?: string | null
    submissionID: string
    type?: validationCreatetypeInput | string[]
  }

  export type validationUpdateManyMutationInput = {
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    type?: validationUpdatetypeInput | string[]
  }

  export type validationUncheckedUpdateManyInput = {
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    type?: validationUpdatetypeInput | string[]
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CDECountOrderByAggregateInput = {
    id?: SortOrder
    CDECode?: SortOrder
    CDEFullName?: SortOrder
    CDEVersion?: SortOrder
    PermissibleValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CDEMaxOrderByAggregateInput = {
    id?: SortOrder
    CDECode?: SortOrder
    CDEFullName?: SortOrder
    CDEVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CDEMinOrderByAggregateInput = {
    id?: SortOrder
    CDECode?: SortOrder
    CDEFullName?: SortOrder
    CDEVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ApplicantCompositeFilter = {
    equals?: ApplicantObjectEqualityInput
    is?: ApplicantWhereInput
    isNot?: ApplicantWhereInput
  }

  export type ApplicantObjectEqualityInput = {
    applicantEmail: string
    applicantID: string
    applicantName: string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type HistoryCompositeListFilter = {
    equals?: HistoryObjectEqualityInput[]
    every?: HistoryWhereInput
    some?: HistoryWhereInput
    none?: HistoryWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type HistoryObjectEqualityInput = {
    dateTime: Date | string
    reviewComment?: string | null
    status: string
    userID: string
    userName?: string | null
  }

  export type OrgInfoCompositeFilter = {
    equals?: OrgInfoObjectEqualityInput
    is?: OrgInfoWhereInput
    isNot?: OrgInfoWhereInput
  }

  export type OrgInfoObjectEqualityInput = {
    id: string
    name: string
    status?: string | null
    createdAt?: Date | string | null
    updateAt?: Date | string | null
    orgID?: string | null
    orgName?: string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type ApplicantOrderByInput = {
    applicantEmail?: SortOrder
    applicantID?: SortOrder
    applicantName?: SortOrder
  }

  export type HistoryOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type OrgInfoOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    orgID?: SortOrder
    orgName?: SortOrder
  }

  export type applicationsCountOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    inactiveReminder?: SortOrder
    openAccess?: SortOrder
    programAbbreviation?: SortOrder
    programDescription?: SortOrder
    programName?: SortOrder
    questionnaireData?: SortOrder
    reviewComment?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    submittedDate?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    wholeProgram?: SortOrder
  }

  export type applicationsMaxOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    inactiveReminder?: SortOrder
    openAccess?: SortOrder
    programAbbreviation?: SortOrder
    programDescription?: SortOrder
    programName?: SortOrder
    questionnaireData?: SortOrder
    reviewComment?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    submittedDate?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    wholeProgram?: SortOrder
  }

  export type applicationsMinOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    inactiveReminder?: SortOrder
    openAccess?: SortOrder
    programAbbreviation?: SortOrder
    programDescription?: SortOrder
    programName?: SortOrder
    questionnaireData?: SortOrder
    reviewComment?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    submittedDate?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    wholeProgram?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type approvedStudiesCountOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    dbGaPID?: SortOrder
    openAccess?: SortOrder
    originalOrg?: SortOrder
    primaryContactID?: SortOrder
    programName?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    updatedAt?: SortOrder
    useProgramPC?: SortOrder
  }

  export type approvedStudiesMaxOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    dbGaPID?: SortOrder
    openAccess?: SortOrder
    originalOrg?: SortOrder
    primaryContactID?: SortOrder
    programName?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    updatedAt?: SortOrder
    useProgramPC?: SortOrder
  }

  export type approvedStudiesMinOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    dbGaPID?: SortOrder
    openAccess?: SortOrder
    originalOrg?: SortOrder
    primaryContactID?: SortOrder
    programName?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    updatedAt?: SortOrder
    useProgramPC?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BatchFilesCompositeListFilter = {
    equals?: BatchFilesObjectEqualityInput[]
    every?: BatchFilesWhereInput
    some?: BatchFilesWhereInput
    none?: BatchFilesWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type BatchFilesObjectEqualityInput = {
    createdAt: Date | string
    errors?: string[]
    fileID?: string | null
    fileName: string
    filePrefix: string
    nodeType?: string | null
    signedURL?: string | null
    size?: number | null
    status: string
    updatedAt: Date | string
  }

  export type BatchFilesOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type batchCountOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    createdAt?: SortOrder
    displayID?: SortOrder
    errors?: SortOrder
    fileCount?: SortOrder
    filePrefix?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    zipFileName?: SortOrder
  }

  export type batchAvgOrderByAggregateInput = {
    displayID?: SortOrder
    fileCount?: SortOrder
  }

  export type batchMaxOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    createdAt?: SortOrder
    displayID?: SortOrder
    fileCount?: SortOrder
    filePrefix?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    zipFileName?: SortOrder
  }

  export type batchMinOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    createdAt?: SortOrder
    displayID?: SortOrder
    fileCount?: SortOrder
    filePrefix?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    zipFileName?: SortOrder
  }

  export type batchSumOrderByAggregateInput = {
    displayID?: SortOrder
    fileCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type PBACDefaultsCompositeListFilter = {
    equals?: PBACDefaultsObjectEqualityInput[]
    every?: PBACDefaultsWhereInput
    some?: PBACDefaultsWhereInput
    none?: PBACDefaultsWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type PBACDefaultsObjectEqualityInput = {
    notifications?: NotificationObjectEqualityInput[]
    permissions?: PermissionObjectEqualityInput[]
    role: string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type ConfigurationTagNullableCompositeFilter = {
    equals?: ConfigurationTagObjectEqualityInput | null
    is?: ConfigurationTagWhereInput | null
    isNot?: ConfigurationTagWhereInput | null
    isSet?: boolean
  }

  export type ConfigurationTagObjectEqualityInput = {
    Key: string
    Value: string
  }

  export type PBACDefaultsOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ConfigurationTagOrderByInput = {
    Key?: SortOrder
    Value?: SortOrder
  }

  export type configurationCountOrderByAggregateInput = {
    id?: SortOrder
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    EMAIL_URL?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    OFFICIAL_EMAIL?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    PROD_URL?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    REVIEW_COMMITTEE_EMAIL?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    SCHEDULED_JOBS?: SortOrder
    SUBMISSION_BUCKET?: SortOrder
    SUBMISSION_HELPDESK?: SortOrder
    SUBMISSION_REQUEST_CONTACT_EMAIL?: SortOrder
    SUBMISSION_SYSTEM_PORTAL?: SortOrder
    TECH_SUPPORT_EMAIL?: SortOrder
    age?: SortOrder
    bucketName?: SortOrder
    current?: SortOrder
    current_version?: SortOrder
    dashboardID?: SortOrder
    dataCommons?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    key?: SortOrder
    keys?: SortOrder
    new?: SortOrder
    prefix?: SortOrder
    timeout?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type configurationAvgOrderByAggregateInput = {
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    age?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    timeout?: SortOrder
  }

  export type configurationMaxOrderByAggregateInput = {
    id?: SortOrder
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    EMAIL_URL?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    OFFICIAL_EMAIL?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    PROD_URL?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    SCHEDULED_JOBS?: SortOrder
    SUBMISSION_BUCKET?: SortOrder
    SUBMISSION_HELPDESK?: SortOrder
    SUBMISSION_REQUEST_CONTACT_EMAIL?: SortOrder
    SUBMISSION_SYSTEM_PORTAL?: SortOrder
    TECH_SUPPORT_EMAIL?: SortOrder
    age?: SortOrder
    bucketName?: SortOrder
    current?: SortOrder
    current_version?: SortOrder
    dashboardID?: SortOrder
    dataCommons?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    new?: SortOrder
    prefix?: SortOrder
    timeout?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type configurationMinOrderByAggregateInput = {
    id?: SortOrder
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    EMAIL_URL?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    OFFICIAL_EMAIL?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    PROD_URL?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    SCHEDULED_JOBS?: SortOrder
    SUBMISSION_BUCKET?: SortOrder
    SUBMISSION_HELPDESK?: SortOrder
    SUBMISSION_REQUEST_CONTACT_EMAIL?: SortOrder
    SUBMISSION_SYSTEM_PORTAL?: SortOrder
    TECH_SUPPORT_EMAIL?: SortOrder
    age?: SortOrder
    bucketName?: SortOrder
    current?: SortOrder
    current_version?: SortOrder
    dashboardID?: SortOrder
    dataCommons?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    new?: SortOrder
    prefix?: SortOrder
    timeout?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type configurationSumOrderByAggregateInput = {
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    age?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    timeout?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type AdditionalErrorCompositeListFilter = {
    equals?: AdditionalErrorObjectEqualityInput[]
    every?: AdditionalErrorWhereInput
    some?: AdditionalErrorWhereInput
    none?: AdditionalErrorWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type AdditionalErrorObjectEqualityInput = {
    conflictingSubmissions?: string[]
    description: string
    title: string
  }

  export type ErrorCompositeListFilter = {
    equals?: ErrorObjectEqualityInput[]
    every?: ErrorWhereInput
    some?: ErrorWhereInput
    none?: ErrorWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ErrorObjectEqualityInput = {
    title: string
    description: string
    code?: string | null
    offendingProperty?: string | null
    offendingValue?: string | null
    severity?: string | null
  }

  export type ParentCompositeListFilter = {
    equals?: ParentObjectEqualityInput[]
    every?: ParentWhereInput
    some?: ParentWhereInput
    none?: ParentWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ParentObjectEqualityInput = {
    parentIDPropName: string
    parentIDValue: string
    parentType: string
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type S3FileInfoNullableCompositeFilter = {
    equals?: S3FileInfoObjectEqualityInput | null
    is?: S3FileInfoWhereInput | null
    isNot?: S3FileInfoWhereInput | null
    isSet?: boolean
  }

  export type S3FileInfoObjectEqualityInput = {
    createdAt?: Date | string | null
    errors?: ErrorObjectEqualityInput[]
    fileName: string
    md5?: string | null
    size?: string | null
    status: string
    updatedAt?: Date | string | null
    warnings?: ErrorObjectEqualityInput[]
  }

  export type AdditionalErrorOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ErrorOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ParentOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type S3FileInfoOrderByInput = {
    createdAt?: SortOrder
    errors?: ErrorOrderByCompositeAggregateInput
    fileName?: SortOrder
    md5?: SortOrder
    size?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    warnings?: ErrorOrderByCompositeAggregateInput
  }

  export type dataRecordsCountOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    batchIDs?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
  }

  export type dataRecordsAvgOrderByAggregateInput = {
    latestBatchDisplayID?: SortOrder
    lineNumber?: SortOrder
  }

  export type dataRecordsMaxOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    qcResultID?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
  }

  export type dataRecordsMinOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    qcResultID?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
  }

  export type dataRecordsSumOrderByAggregateInput = {
    latestBatchDisplayID?: SortOrder
    lineNumber?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type dataRecordsArchivedCountOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    batchIDs?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
  }

  export type dataRecordsArchivedAvgOrderByAggregateInput = {
    latestBatchDisplayID?: SortOrder
    lineNumber?: SortOrder
  }

  export type dataRecordsArchivedMaxOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    qcResultID?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
  }

  export type dataRecordsArchivedMinOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    qcResultID?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
  }

  export type dataRecordsArchivedSumOrderByAggregateInput = {
    latestBatchDisplayID?: SortOrder
    lineNumber?: SortOrder
  }

  export type fileMD5CountOrderByAggregateInput = {
    id?: SortOrder
    LastModified?: SortOrder
    createdAt?: SortOrder
    fileName?: SortOrder
    md5?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
  }

  export type fileMD5MaxOrderByAggregateInput = {
    id?: SortOrder
    LastModified?: SortOrder
    createdAt?: SortOrder
    fileName?: SortOrder
    md5?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
  }

  export type fileMD5MinOrderByAggregateInput = {
    id?: SortOrder
    LastModified?: SortOrder
    createdAt?: SortOrder
    fileName?: SortOrder
    md5?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
  }

  export type institutionsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    submitterCount?: SortOrder
    updatedAt?: SortOrder
  }

  export type institutionsAvgOrderByAggregateInput = {
    submitterCount?: SortOrder
  }

  export type institutionsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    submitterCount?: SortOrder
    updatedAt?: SortOrder
  }

  export type institutionsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    status?: SortOrder
    submitterCount?: SortOrder
    updatedAt?: SortOrder
  }

  export type institutionsSumOrderByAggregateInput = {
    submitterCount?: SortOrder
  }

  export type LogsEventDetailNullableCompositeFilter = {
    equals?: LogsEventDetailObjectEqualityInput | null
    is?: LogsEventDetailWhereInput | null
    isNot?: LogsEventDetailWhereInput | null
    isSet?: boolean
  }

  export type LogsEventDetailObjectEqualityInput = {
    nodeIDs?: string[]
    nodeType: string
    submissionID: string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type LogsEventDetailOrderByInput = {
    nodeIDs?: SortOrder
    nodeType?: SortOrder
    submissionID?: SortOrder
  }

  export type logsCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    applicationID?: SortOrder
    eventType?: SortOrder
    localtime?: SortOrder
    newProfile?: SortOrder
    newState?: SortOrder
    prevProfile?: SortOrder
    prevState?: SortOrder
    submissionID?: SortOrder
    timestamp?: SortOrder
    userEmail?: SortOrder
    userID?: SortOrder
    userIDP?: SortOrder
    userName?: SortOrder
  }

  export type logsAvgOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type logsMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    applicationID?: SortOrder
    eventType?: SortOrder
    localtime?: SortOrder
    newState?: SortOrder
    prevState?: SortOrder
    submissionID?: SortOrder
    timestamp?: SortOrder
    userEmail?: SortOrder
    userID?: SortOrder
    userIDP?: SortOrder
    userName?: SortOrder
  }

  export type logsMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    applicationID?: SortOrder
    eventType?: SortOrder
    localtime?: SortOrder
    newState?: SortOrder
    prevState?: SortOrder
    submissionID?: SortOrder
    timestamp?: SortOrder
    userEmail?: SortOrder
    userID?: SortOrder
    userIDP?: SortOrder
    userName?: SortOrder
  }

  export type logsSumOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StudyByIDCompositeListFilter = {
    equals?: StudyByIDObjectEqualityInput[]
    every?: StudyByIDWhereInput
    some?: StudyByIDWhereInput
    none?: StudyByIDWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type StudyByIDObjectEqualityInput = {
    id: string
  }

  export type StudyByIDOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type organizationCountOrderByAggregateInput = {
    id?: SortOrder
    abbreviation?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeID?: SortOrder
    conciergeName?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    name?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    updateAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationMaxOrderByAggregateInput = {
    id?: SortOrder
    abbreviation?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeID?: SortOrder
    conciergeName?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    name?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    updateAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationMinOrderByAggregateInput = {
    id?: SortOrder
    abbreviation?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeID?: SortOrder
    conciergeName?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    name?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    updateAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type qcResultsCountOrderByAggregateInput = {
    id?: SortOrder
    batchIDs?: SortOrder
    dataRecordID?: SortOrder
    displayID?: SortOrder
    latestBatchID?: SortOrder
    origin?: SortOrder
    severity?: SortOrder
    submissionID?: SortOrder
    submittedID?: SortOrder
    type?: SortOrder
    uploadedDate?: SortOrder
    validatedDate?: SortOrder
    validationType?: SortOrder
  }

  export type qcResultsAvgOrderByAggregateInput = {
    displayID?: SortOrder
  }

  export type qcResultsMaxOrderByAggregateInput = {
    id?: SortOrder
    dataRecordID?: SortOrder
    displayID?: SortOrder
    latestBatchID?: SortOrder
    origin?: SortOrder
    severity?: SortOrder
    submissionID?: SortOrder
    submittedID?: SortOrder
    type?: SortOrder
    uploadedDate?: SortOrder
    validatedDate?: SortOrder
    validationType?: SortOrder
  }

  export type qcResultsMinOrderByAggregateInput = {
    id?: SortOrder
    dataRecordID?: SortOrder
    displayID?: SortOrder
    latestBatchID?: SortOrder
    origin?: SortOrder
    severity?: SortOrder
    submissionID?: SortOrder
    submittedID?: SortOrder
    type?: SortOrder
    uploadedDate?: SortOrder
    validatedDate?: SortOrder
    validationType?: SortOrder
  }

  export type qcResultsSumOrderByAggregateInput = {
    displayID?: SortOrder
  }

  export type releaseCountOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    props?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
  }

  export type releaseMaxOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
  }

  export type releaseMinOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    updatedAt?: SortOrder
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    expires?: SortOrder
    lastModified?: SortOrder
    session?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    expires?: SortOrder
    lastModified?: SortOrder
    session?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    expires?: SortOrder
    lastModified?: SortOrder
    session?: SortOrder
  }

  export type CollaboratorCompositeListFilter = {
    equals?: CollaboratorObjectEqualityInput[]
    every?: CollaboratorWhereInput
    some?: CollaboratorWhereInput
    none?: CollaboratorWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type CollaboratorObjectEqualityInput = {
    Organization?: OrgInfoObjectEqualityInput | null
    collaboratorID: string
    collaboratorName?: string | null
    permission: InputJsonValue
  }

  export type DataFileSizeCompositeFilter = {
    equals?: DataFileSizeObjectEqualityInput
    is?: DataFileSizeWhereInput
    isNot?: DataFileSizeWhereInput
  }

  export type DataFileSizeObjectEqualityInput = {
    formatted: string
    size: number
  }

  export type CollaboratorOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type DataFileSizeOrderByInput = {
    formatted?: SortOrder
    size?: SortOrder
  }

  export type submissionsCountOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    accessedAt?: SortOrder
    archived?: SortOrder
    bucketName?: SortOrder
    collborators?: SortOrder
    conciergeEmail?: SortOrder
    conciergeName?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    crossSubmissionStatus?: SortOrder
    dataCommons?: SortOrder
    dataCommonsDisplayName?: SortOrder
    dataType?: SortOrder
    dbGaPID?: SortOrder
    deletingData?: SortOrder
    fileValidationStatus?: SortOrder
    finalInactiveReminder?: SortOrder
    inactiveReminder?: SortOrder
    inactiveReminder_30?: SortOrder
    inactiveReminder_60?: SortOrder
    inactiveReminder_7?: SortOrder
    intention?: SortOrder
    metadataValidationStatus?: SortOrder
    modelVersion?: SortOrder
    name?: SortOrder
    nodeCount?: SortOrder
    reviewComment?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    updatedAt?: SortOrder
    validationEnded?: SortOrder
    validationScope?: SortOrder
    validationStarted?: SortOrder
    validationType?: SortOrder
  }

  export type submissionsAvgOrderByAggregateInput = {
    nodeCount?: SortOrder
  }

  export type submissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    accessedAt?: SortOrder
    archived?: SortOrder
    bucketName?: SortOrder
    collborators?: SortOrder
    conciergeEmail?: SortOrder
    conciergeName?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    crossSubmissionStatus?: SortOrder
    dataCommons?: SortOrder
    dataCommonsDisplayName?: SortOrder
    dataType?: SortOrder
    dbGaPID?: SortOrder
    deletingData?: SortOrder
    fileValidationStatus?: SortOrder
    finalInactiveReminder?: SortOrder
    inactiveReminder?: SortOrder
    inactiveReminder_30?: SortOrder
    inactiveReminder_60?: SortOrder
    inactiveReminder_7?: SortOrder
    intention?: SortOrder
    metadataValidationStatus?: SortOrder
    modelVersion?: SortOrder
    name?: SortOrder
    nodeCount?: SortOrder
    reviewComment?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    updatedAt?: SortOrder
    validationEnded?: SortOrder
    validationScope?: SortOrder
    validationStarted?: SortOrder
  }

  export type submissionsMinOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    accessedAt?: SortOrder
    archived?: SortOrder
    bucketName?: SortOrder
    collborators?: SortOrder
    conciergeEmail?: SortOrder
    conciergeName?: SortOrder
    controlledAccess?: SortOrder
    createdAt?: SortOrder
    crossSubmissionStatus?: SortOrder
    dataCommons?: SortOrder
    dataCommonsDisplayName?: SortOrder
    dataType?: SortOrder
    dbGaPID?: SortOrder
    deletingData?: SortOrder
    fileValidationStatus?: SortOrder
    finalInactiveReminder?: SortOrder
    inactiveReminder?: SortOrder
    inactiveReminder_30?: SortOrder
    inactiveReminder_60?: SortOrder
    inactiveReminder_7?: SortOrder
    intention?: SortOrder
    metadataValidationStatus?: SortOrder
    modelVersion?: SortOrder
    name?: SortOrder
    nodeCount?: SortOrder
    reviewComment?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    updatedAt?: SortOrder
    validationEnded?: SortOrder
    validationScope?: SortOrder
    validationStarted?: SortOrder
  }

  export type submissionsSumOrderByAggregateInput = {
    nodeCount?: SortOrder
  }

  export type synonymsCountOrderByAggregateInput = {
    id?: SortOrder
    equivalent_term?: SortOrder
    synonym_term?: SortOrder
  }

  export type synonymsMaxOrderByAggregateInput = {
    equivalent_term?: SortOrder
    synonym_term?: SortOrder
  }

  export type synonymsMinOrderByAggregateInput = {
    equivalent_term?: SortOrder
    synonym_term?: SortOrder
  }

  export type InstitutionNullableCompositeFilter = {
    equals?: InstitutionObjectEqualityInput | null
    is?: InstitutionWhereInput | null
    isNot?: InstitutionWhereInput | null
    isSet?: boolean
  }

  export type InstitutionObjectEqualityInput = {
    id: string
    name: string
    status: string
  }

  export type OrgInfoNullableCompositeFilter = {
    equals?: OrgInfoObjectEqualityInput | null
    is?: OrgInfoWhereInput | null
    isNot?: OrgInfoWhereInput | null
    isSet?: boolean
  }

  export type InstitutionOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    IDP?: SortOrder
    createdAt?: SortOrder
    dataCommons?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    notifications?: SortOrder
    permissions?: SortOrder
    role?: SortOrder
    status?: SortOrder
    tokens?: SortOrder
    updateAt?: SortOrder
    userStatus?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    IDP?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    updateAt?: SortOrder
    userStatus?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    IDP?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    updateAt?: SortOrder
    userStatus?: SortOrder
  }

  export type validationCountOrderByAggregateInput = {
    id?: SortOrder
    ended?: SortOrder
    scope?: SortOrder
    started?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    type?: SortOrder
  }

  export type validationMaxOrderByAggregateInput = {
    id?: SortOrder
    ended?: SortOrder
    scope?: SortOrder
    started?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
  }

  export type validationMinOrderByAggregateInput = {
    id?: SortOrder
    ended?: SortOrder
    scope?: SortOrder
    started?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
  }

  export type CDECreatePermissibleValuesInput = {
    set: string[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type CDEUpdatePermissibleValuesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ApplicantCreateEnvelopeInput = {
    set?: ApplicantCreateInput
  }

  export type ApplicantCreateInput = {
    applicantEmail: string
    applicantID: string
    applicantName: string
  }

  export type HistoryListCreateEnvelopeInput = {
    set?: HistoryCreateInput | HistoryCreateInput[]
  }

  export type HistoryCreateInput = {
    dateTime: Date | string
    reviewComment?: string | null
    status: string
    userID: string
    userName?: string | null
  }

  export type OrgInfoCreateEnvelopeInput = {
    set?: OrgInfoCreateInput
  }

  export type OrgInfoCreateInput = {
    id: string
    name: string
    status?: string | null
    createdAt?: Date | string | null
    updateAt?: Date | string | null
    orgID?: string | null
    orgName?: string | null
  }

  export type ApplicantUpdateEnvelopeInput = {
    set?: ApplicantCreateInput
    update?: ApplicantUpdateInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type HistoryListUpdateEnvelopeInput = {
    set?: HistoryCreateInput | HistoryCreateInput[]
    push?: HistoryCreateInput | HistoryCreateInput[]
    updateMany?: HistoryUpdateManyInput
    deleteMany?: HistoryDeleteManyInput
  }

  export type OrgInfoUpdateEnvelopeInput = {
    set?: OrgInfoCreateInput
    update?: OrgInfoUpdateInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type batchCreateerrorsInput = {
    set: string[]
  }

  export type BatchFilesListCreateEnvelopeInput = {
    set?: BatchFilesCreateInput | BatchFilesCreateInput[]
  }

  export type BatchFilesCreateInput = {
    createdAt: Date | string
    errors?: BatchFilesCreateerrorsInput | string[]
    fileID?: string | null
    fileName: string
    filePrefix: string
    nodeType?: string | null
    signedURL?: string | null
    size?: number | null
    status: string
    updatedAt: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type batchUpdateerrorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BatchFilesListUpdateEnvelopeInput = {
    set?: BatchFilesCreateInput | BatchFilesCreateInput[]
    push?: BatchFilesCreateInput | BatchFilesCreateInput[]
    updateMany?: BatchFilesUpdateManyInput
    deleteMany?: BatchFilesDeleteManyInput
  }

  export type PBACDefaultsListCreateEnvelopeInput = {
    set?: PBACDefaultsCreateInput | PBACDefaultsCreateInput[]
  }

  export type PBACDefaultsCreateInput = {
    notifications?: NotificationCreateInput | NotificationCreateInput[]
    permissions?: PermissionCreateInput | PermissionCreateInput[]
    role: string
  }

  export type configurationCreateREVIEW_COMMITTEE_EMAILInput = {
    set: string[]
  }

  export type configurationCreatekeyInput = {
    set: string[]
  }

  export type ConfigurationTagNullableCreateEnvelopeInput = {
    set?: ConfigurationTagCreateInput | null
  }

  export type ConfigurationTagCreateInput = {
    Key: string
    Value: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type PBACDefaultsListUpdateEnvelopeInput = {
    set?: PBACDefaultsCreateInput | PBACDefaultsCreateInput[]
    push?: PBACDefaultsCreateInput | PBACDefaultsCreateInput[]
    updateMany?: PBACDefaultsUpdateManyInput
    deleteMany?: PBACDefaultsDeleteManyInput
  }

  export type configurationUpdateREVIEW_COMMITTEE_EMAILInput = {
    set?: string[]
    push?: string | string[]
  }

  export type configurationUpdatekeyInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ConfigurationTagNullableUpdateEnvelopeInput = {
    set?: ConfigurationTagCreateInput | null
    upsert?: ConfigurationTagUpsertInput
    unset?: boolean
  }

  export type AdditionalErrorListCreateEnvelopeInput = {
    set?: AdditionalErrorCreateInput | AdditionalErrorCreateInput[]
  }

  export type AdditionalErrorCreateInput = {
    conflictingSubmissions?: AdditionalErrorCreateconflictingSubmissionsInput | string[]
    description: string
    title: string
  }

  export type dataRecordsCreatebatchIDsInput = {
    set: string[]
  }

  export type ErrorListCreateEnvelopeInput = {
    set?: ErrorCreateInput | ErrorCreateInput[]
  }

  export type ErrorCreateInput = {
    title: string
    description: string
    code?: string | null
    offendingProperty?: string | null
    offendingValue?: string | null
    severity?: string | null
  }

  export type ParentListCreateEnvelopeInput = {
    set?: ParentCreateInput | ParentCreateInput[]
  }

  export type ParentCreateInput = {
    parentIDPropName: string
    parentIDValue: string
    parentType: string
  }

  export type S3FileInfoNullableCreateEnvelopeInput = {
    set?: S3FileInfoCreateInput | null
  }

  export type S3FileInfoCreateInput = {
    createdAt?: Date | string | null
    errors?: ErrorCreateInput | ErrorCreateInput[]
    fileName: string
    md5?: string | null
    size?: string | null
    status: string
    updatedAt?: Date | string | null
    warnings?: ErrorCreateInput | ErrorCreateInput[]
  }

  export type AdditionalErrorListUpdateEnvelopeInput = {
    set?: AdditionalErrorCreateInput | AdditionalErrorCreateInput[]
    push?: AdditionalErrorCreateInput | AdditionalErrorCreateInput[]
    updateMany?: AdditionalErrorUpdateManyInput
    deleteMany?: AdditionalErrorDeleteManyInput
  }

  export type dataRecordsUpdatebatchIDsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ErrorListUpdateEnvelopeInput = {
    set?: ErrorCreateInput | ErrorCreateInput[]
    push?: ErrorCreateInput | ErrorCreateInput[]
    updateMany?: ErrorUpdateManyInput
    deleteMany?: ErrorDeleteManyInput
  }

  export type ParentListUpdateEnvelopeInput = {
    set?: ParentCreateInput | ParentCreateInput[]
    push?: ParentCreateInput | ParentCreateInput[]
    updateMany?: ParentUpdateManyInput
    deleteMany?: ParentDeleteManyInput
  }

  export type S3FileInfoNullableUpdateEnvelopeInput = {
    set?: S3FileInfoCreateInput | null
    upsert?: S3FileInfoUpsertInput
    unset?: boolean
  }

  export type dataRecordsArchivedCreatebatchIDsInput = {
    set: string[]
  }

  export type dataRecordsArchivedUpdatebatchIDsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LogsEventDetailNullableCreateEnvelopeInput = {
    set?: LogsEventDetailCreateInput | null
  }

  export type LogsEventDetailCreateInput = {
    nodeIDs?: LogsEventDetailCreatenodeIDsInput | string[]
    nodeType: string
    submissionID: string
  }

  export type LogsEventDetailNullableUpdateEnvelopeInput = {
    set?: LogsEventDetailCreateInput | null
    upsert?: LogsEventDetailUpsertInput
    unset?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudyByIDListCreateEnvelopeInput = {
    set?: StudyByIDCreateInput | StudyByIDCreateInput[]
  }

  export type StudyByIDCreateInput = {
    id: string
  }

  export type StudyByIDListUpdateEnvelopeInput = {
    set?: StudyByIDCreateInput | StudyByIDCreateInput[]
    push?: StudyByIDCreateInput | StudyByIDCreateInput[]
    updateMany?: StudyByIDUpdateManyInput
    deleteMany?: StudyByIDDeleteManyInput
  }

  export type qcResultsCreatebatchIDsInput = {
    set: string[]
  }

  export type qcResultsUpdatebatchIDsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CollaboratorListCreateEnvelopeInput = {
    set?: CollaboratorCreateInput | CollaboratorCreateInput[]
  }

  export type CollaboratorCreateInput = {
    Organization?: OrgInfoCreateInput | null
    collaboratorID: string
    collaboratorName?: string | null
    permission: InputJsonValue
  }

  export type DataFileSizeCreateEnvelopeInput = {
    set?: DataFileSizeCreateInput
  }

  export type DataFileSizeCreateInput = {
    formatted: string
    size: number
  }

  export type submissionsCreatevalidationTypeInput = {
    set: string[]
  }

  export type CollaboratorListUpdateEnvelopeInput = {
    set?: CollaboratorCreateInput | CollaboratorCreateInput[]
    push?: CollaboratorCreateInput | CollaboratorCreateInput[]
    updateMany?: CollaboratorUpdateManyInput
    deleteMany?: CollaboratorDeleteManyInput
  }

  export type DataFileSizeUpdateEnvelopeInput = {
    set?: DataFileSizeCreateInput
    update?: DataFileSizeUpdateInput
  }

  export type submissionsUpdatevalidationTypeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersCreatedataCommonsInput = {
    set: string[]
  }

  export type InstitutionNullableCreateEnvelopeInput = {
    set?: InstitutionCreateInput | null
  }

  export type InstitutionCreateInput = {
    id: string
    name: string
    status: string
  }

  export type usersCreatenotificationsInput = {
    set: string[]
  }

  export type OrgInfoNullableCreateEnvelopeInput = {
    set?: OrgInfoCreateInput | null
  }

  export type usersCreatepermissionsInput = {
    set: string[]
  }

  export type usersCreatetokensInput = {
    set: string[]
  }

  export type usersUpdatedataCommonsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstitutionNullableUpdateEnvelopeInput = {
    set?: InstitutionCreateInput | null
    upsert?: InstitutionUpsertInput
    unset?: boolean
  }

  export type usersUpdatenotificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrgInfoNullableUpdateEnvelopeInput = {
    set?: OrgInfoCreateInput | null
    upsert?: OrgInfoUpsertInput
    unset?: boolean
  }

  export type usersUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUpdatetokensInput = {
    set?: string[]
    push?: string | string[]
  }

  export type validationCreatetypeInput = {
    set: string[]
  }

  export type validationUpdatetypeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ApplicantWhereInput = {
    AND?: ApplicantWhereInput | ApplicantWhereInput[]
    OR?: ApplicantWhereInput[]
    NOT?: ApplicantWhereInput | ApplicantWhereInput[]
    applicantEmail?: StringFilter<"Applicant"> | string
    applicantID?: StringFilter<"Applicant"> | string
    applicantName?: StringFilter<"Applicant"> | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type HistoryWhereInput = {
    AND?: HistoryWhereInput | HistoryWhereInput[]
    OR?: HistoryWhereInput[]
    NOT?: HistoryWhereInput | HistoryWhereInput[]
    dateTime?: DateTimeFilter<"History"> | Date | string
    reviewComment?: StringNullableFilter<"History"> | string | null
    status?: StringFilter<"History"> | string
    userID?: StringFilter<"History"> | string
    userName?: StringNullableFilter<"History"> | string | null
  }

  export type OrgInfoWhereInput = {
    AND?: OrgInfoWhereInput | OrgInfoWhereInput[]
    OR?: OrgInfoWhereInput[]
    NOT?: OrgInfoWhereInput | OrgInfoWhereInput[]
    id?: StringFilter<"OrgInfo"> | string
    name?: StringFilter<"OrgInfo"> | string
    status?: StringNullableFilter<"OrgInfo"> | string | null
    createdAt?: DateTimeNullableFilter<"OrgInfo"> | Date | string | null
    updateAt?: DateTimeNullableFilter<"OrgInfo"> | Date | string | null
    orgID?: StringNullableFilter<"OrgInfo"> | string | null
    orgName?: StringNullableFilter<"OrgInfo"> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BatchFilesWhereInput = {
    AND?: BatchFilesWhereInput | BatchFilesWhereInput[]
    OR?: BatchFilesWhereInput[]
    NOT?: BatchFilesWhereInput | BatchFilesWhereInput[]
    createdAt?: DateTimeFilter<"BatchFiles"> | Date | string
    errors?: StringNullableListFilter<"BatchFiles">
    fileID?: StringNullableFilter<"BatchFiles"> | string | null
    fileName?: StringFilter<"BatchFiles"> | string
    filePrefix?: StringFilter<"BatchFiles"> | string
    nodeType?: StringNullableFilter<"BatchFiles"> | string | null
    signedURL?: StringNullableFilter<"BatchFiles"> | string | null
    size?: IntNullableFilter<"BatchFiles"> | number | null
    status?: StringFilter<"BatchFiles"> | string
    updatedAt?: DateTimeFilter<"BatchFiles"> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PBACDefaultsWhereInput = {
    AND?: PBACDefaultsWhereInput | PBACDefaultsWhereInput[]
    OR?: PBACDefaultsWhereInput[]
    NOT?: PBACDefaultsWhereInput | PBACDefaultsWhereInput[]
    notifications?: NotificationCompositeListFilter | NotificationObjectEqualityInput[]
    permissions?: PermissionCompositeListFilter | PermissionObjectEqualityInput[]
    role?: StringFilter<"PBACDefaults"> | string
  }

  export type NotificationObjectEqualityInput = {
    id: string
    checked: boolean
    disabled: boolean
    group: string
    name: string
    order: number
  }

  export type PermissionObjectEqualityInput = {
    id: string
    checked: boolean
    disabled: boolean
    group: string
    inherited?: string[]
    name: string
    order: number
  }

  export type ConfigurationTagWhereInput = {
    AND?: ConfigurationTagWhereInput | ConfigurationTagWhereInput[]
    OR?: ConfigurationTagWhereInput[]
    NOT?: ConfigurationTagWhereInput | ConfigurationTagWhereInput[]
    Key?: StringFilter<"ConfigurationTag"> | string
    Value?: StringFilter<"ConfigurationTag"> | string
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type AdditionalErrorWhereInput = {
    AND?: AdditionalErrorWhereInput | AdditionalErrorWhereInput[]
    OR?: AdditionalErrorWhereInput[]
    NOT?: AdditionalErrorWhereInput | AdditionalErrorWhereInput[]
    conflictingSubmissions?: StringNullableListFilter<"AdditionalError">
    description?: StringFilter<"AdditionalError"> | string
    title?: StringFilter<"AdditionalError"> | string
  }

  export type ErrorWhereInput = {
    AND?: ErrorWhereInput | ErrorWhereInput[]
    OR?: ErrorWhereInput[]
    NOT?: ErrorWhereInput | ErrorWhereInput[]
    title?: StringFilter<"Error"> | string
    description?: StringFilter<"Error"> | string
    code?: StringNullableFilter<"Error"> | string | null
    offendingProperty?: StringNullableFilter<"Error"> | string | null
    offendingValue?: StringNullableFilter<"Error"> | string | null
    severity?: StringNullableFilter<"Error"> | string | null
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    parentIDPropName?: StringFilter<"Parent"> | string
    parentIDValue?: StringFilter<"Parent"> | string
    parentType?: StringFilter<"Parent"> | string
  }

  export type S3FileInfoWhereInput = {
    AND?: S3FileInfoWhereInput | S3FileInfoWhereInput[]
    OR?: S3FileInfoWhereInput[]
    NOT?: S3FileInfoWhereInput | S3FileInfoWhereInput[]
    createdAt?: DateTimeNullableFilter<"S3FileInfo"> | Date | string | null
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    fileName?: StringFilter<"S3FileInfo"> | string
    md5?: StringNullableFilter<"S3FileInfo"> | string | null
    size?: StringNullableFilter<"S3FileInfo"> | string | null
    status?: StringFilter<"S3FileInfo"> | string
    updatedAt?: DateTimeNullableFilter<"S3FileInfo"> | Date | string | null
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type LogsEventDetailWhereInput = {
    AND?: LogsEventDetailWhereInput | LogsEventDetailWhereInput[]
    OR?: LogsEventDetailWhereInput[]
    NOT?: LogsEventDetailWhereInput | LogsEventDetailWhereInput[]
    nodeIDs?: StringNullableListFilter<"LogsEventDetail">
    nodeType?: StringFilter<"LogsEventDetail"> | string
    submissionID?: StringFilter<"LogsEventDetail"> | string
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StudyByIDWhereInput = {
    AND?: StudyByIDWhereInput | StudyByIDWhereInput[]
    OR?: StudyByIDWhereInput[]
    NOT?: StudyByIDWhereInput | StudyByIDWhereInput[]
    id?: StringFilter<"StudyByID"> | string
  }

  export type CollaboratorWhereInput = {
    AND?: CollaboratorWhereInput | CollaboratorWhereInput[]
    OR?: CollaboratorWhereInput[]
    NOT?: CollaboratorWhereInput | CollaboratorWhereInput[]
    Organization?: XOR<OrgInfoNullableCompositeFilter, OrgInfoObjectEqualityInput> | null
    collaboratorID?: StringFilter<"Collaborator"> | string
    collaboratorName?: StringNullableFilter<"Collaborator"> | string | null
    permission?: JsonFilter<"Collaborator">
  }

  export type DataFileSizeWhereInput = {
    AND?: DataFileSizeWhereInput | DataFileSizeWhereInput[]
    OR?: DataFileSizeWhereInput[]
    NOT?: DataFileSizeWhereInput | DataFileSizeWhereInput[]
    formatted?: StringFilter<"DataFileSize"> | string
    size?: IntFilter<"DataFileSize"> | number
  }

  export type InstitutionWhereInput = {
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    id?: StringFilter<"Institution"> | string
    name?: StringFilter<"Institution"> | string
    status?: StringFilter<"Institution"> | string
  }

  export type ApplicantUpdateInput = {
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantID?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
  }

  export type HistoryUpdateManyInput = {
    where: HistoryWhereInput
    data: HistoryUpdateInput
  }

  export type HistoryDeleteManyInput = {
    where: HistoryWhereInput
  }

  export type OrgInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orgID?: NullableStringFieldUpdateOperationsInput | string | null
    orgName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatchFilesCreateerrorsInput = {
    set: string[]
  }

  export type BatchFilesUpdateManyInput = {
    where: BatchFilesWhereInput
    data: BatchFilesUpdateInput
  }

  export type BatchFilesDeleteManyInput = {
    where: BatchFilesWhereInput
  }

  export type NotificationCreateInput = {
    id: string
    checked: boolean
    disabled: boolean
    group: string
    name: string
    order: number
  }

  export type PermissionCreateInput = {
    id: string
    checked: boolean
    disabled: boolean
    group: string
    inherited?: PermissionCreateinheritedInput | string[]
    name: string
    order: number
  }

  export type PBACDefaultsUpdateManyInput = {
    where: PBACDefaultsWhereInput
    data: PBACDefaultsUpdateInput
  }

  export type PBACDefaultsDeleteManyInput = {
    where: PBACDefaultsWhereInput
  }

  export type ConfigurationTagUpsertInput = {
    set: ConfigurationTagCreateInput | null
    update: ConfigurationTagUpdateInput
  }

  export type AdditionalErrorCreateconflictingSubmissionsInput = {
    set: string[]
  }

  export type AdditionalErrorUpdateManyInput = {
    where: AdditionalErrorWhereInput
    data: AdditionalErrorUpdateInput
  }

  export type AdditionalErrorDeleteManyInput = {
    where: AdditionalErrorWhereInput
  }

  export type ErrorUpdateManyInput = {
    where: ErrorWhereInput
    data: ErrorUpdateInput
  }

  export type ErrorDeleteManyInput = {
    where: ErrorWhereInput
  }

  export type ParentUpdateManyInput = {
    where: ParentWhereInput
    data: ParentUpdateInput
  }

  export type ParentDeleteManyInput = {
    where: ParentWhereInput
  }

  export type S3FileInfoUpsertInput = {
    set: S3FileInfoCreateInput | null
    update: S3FileInfoUpdateInput
  }

  export type LogsEventDetailCreatenodeIDsInput = {
    set: string[]
  }

  export type LogsEventDetailUpsertInput = {
    set: LogsEventDetailCreateInput | null
    update: LogsEventDetailUpdateInput
  }

  export type StudyByIDUpdateManyInput = {
    where: StudyByIDWhereInput
    data: StudyByIDUpdateInput
  }

  export type StudyByIDDeleteManyInput = {
    where: StudyByIDWhereInput
  }

  export type CollaboratorUpdateManyInput = {
    where: CollaboratorWhereInput
    data: CollaboratorUpdateInput
  }

  export type CollaboratorDeleteManyInput = {
    where: CollaboratorWhereInput
  }

  export type DataFileSizeUpdateInput = {
    formatted?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
  }

  export type InstitutionUpsertInput = {
    set: InstitutionCreateInput | null
    update: InstitutionUpdateInput
  }

  export type OrgInfoUpsertInput = {
    set: OrgInfoCreateInput | null
    update: OrgInfoUpdateInput
  }

  export type NotificationCompositeListFilter = {
    equals?: NotificationObjectEqualityInput[]
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type PermissionCompositeListFilter = {
    equals?: PermissionObjectEqualityInput[]
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type HistoryUpdateInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatchFilesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: BatchFilesUpdateerrorsInput | string[]
    fileID?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePrefix?: StringFieldUpdateOperationsInput | string
    nodeType?: NullableStringFieldUpdateOperationsInput | string | null
    signedURL?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateinheritedInput = {
    set: string[]
  }

  export type PBACDefaultsUpdateInput = {
    notifications?: XOR<NotificationListUpdateEnvelopeInput, NotificationCreateInput> | NotificationCreateInput[]
    permissions?: XOR<PermissionListUpdateEnvelopeInput, PermissionCreateInput> | PermissionCreateInput[]
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ConfigurationTagUpdateInput = {
    Key?: StringFieldUpdateOperationsInput | string
    Value?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalErrorUpdateInput = {
    conflictingSubmissions?: AdditionalErrorUpdateconflictingSubmissionsInput | string[]
    description?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ErrorUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    offendingProperty?: NullableStringFieldUpdateOperationsInput | string | null
    offendingValue?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParentUpdateInput = {
    parentIDPropName?: StringFieldUpdateOperationsInput | string
    parentIDValue?: StringFieldUpdateOperationsInput | string
    parentType?: StringFieldUpdateOperationsInput | string
  }

  export type S3FileInfoUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    fileName?: StringFieldUpdateOperationsInput | string
    md5?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type LogsEventDetailUpdateInput = {
    nodeIDs?: LogsEventDetailUpdatenodeIDsInput | string[]
    nodeType?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
  }

  export type StudyByIDUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CollaboratorUpdateInput = {
    Organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    collaboratorID?: StringFieldUpdateOperationsInput | string
    collaboratorName?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: InputJsonValue | InputJsonValue
  }

  export type InstitutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    checked?: BoolFilter<"Notification"> | boolean
    disabled?: BoolFilter<"Notification"> | boolean
    group?: StringFilter<"Notification"> | string
    name?: StringFilter<"Notification"> | string
    order?: IntFilter<"Notification"> | number
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    checked?: BoolFilter<"Permission"> | boolean
    disabled?: BoolFilter<"Permission"> | boolean
    group?: StringFilter<"Permission"> | string
    inherited?: StringNullableListFilter<"Permission">
    name?: StringFilter<"Permission"> | string
    order?: IntFilter<"Permission"> | number
  }

  export type BatchFilesUpdateerrorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NotificationListUpdateEnvelopeInput = {
    set?: NotificationCreateInput | NotificationCreateInput[]
    push?: NotificationCreateInput | NotificationCreateInput[]
    updateMany?: NotificationUpdateManyInput
    deleteMany?: NotificationDeleteManyInput
  }

  export type PermissionListUpdateEnvelopeInput = {
    set?: PermissionCreateInput | PermissionCreateInput[]
    push?: PermissionCreateInput | PermissionCreateInput[]
    updateMany?: PermissionUpdateManyInput
    deleteMany?: PermissionDeleteManyInput
  }

  export type AdditionalErrorUpdateconflictingSubmissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LogsEventDetailUpdatenodeIDsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NotificationUpdateManyInput = {
    where: NotificationWhereInput
    data: NotificationUpdateInput
  }

  export type NotificationDeleteManyInput = {
    where: NotificationWhereInput
  }

  export type PermissionUpdateManyInput = {
    where: PermissionWhereInput
    data: PermissionUpdateInput
  }

  export type PermissionDeleteManyInput = {
    where: PermissionWhereInput
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    group?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    group?: StringFieldUpdateOperationsInput | string
    inherited?: PermissionUpdateinheritedInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionUpdateinheritedInput = {
    set?: string[]
    push?: string | string[]
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}