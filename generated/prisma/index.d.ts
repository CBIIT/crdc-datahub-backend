
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model OrgInfo
 * 
 */
export type OrgInfo = $Result.DefaultSelection<Prisma.$OrgInfoPayload>
/**
 * Model Applicant
 * 
 */
export type Applicant = $Result.DefaultSelection<Prisma.$ApplicantPayload>
/**
 * Model BatchFiles
 * 
 */
export type BatchFiles = $Result.DefaultSelection<Prisma.$BatchFilesPayload>
/**
 * Model PBACDefaults
 * 
 */
export type PBACDefaults = $Result.DefaultSelection<Prisma.$PBACDefaultsPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model ConfigurationTag
 * 
 */
export type ConfigurationTag = $Result.DefaultSelection<Prisma.$ConfigurationTagPayload>
/**
 * Model AdditionalError
 * 
 */
export type AdditionalError = $Result.DefaultSelection<Prisma.$AdditionalErrorPayload>
/**
 * Model S3FileInfo
 * 
 */
export type S3FileInfo = $Result.DefaultSelection<Prisma.$S3FileInfoPayload>
/**
 * Model LogsEventDetail
 * 
 */
export type LogsEventDetail = $Result.DefaultSelection<Prisma.$LogsEventDetailPayload>
/**
 * Model InstitutionInfo
 * 
 */
export type InstitutionInfo = $Result.DefaultSelection<Prisma.$InstitutionInfoPayload>
/**
 * Model Collaborator
 * 
 */
export type Collaborator = $Result.DefaultSelection<Prisma.$CollaboratorPayload>
/**
 * Model DataFileSize
 * 
 */
export type DataFileSize = $Result.DefaultSelection<Prisma.$DataFileSizePayload>
/**
 * Model StudyByID
 * 
 */
export type StudyByID = $Result.DefaultSelection<Prisma.$StudyByIDPayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model History
 * 
 */
export type History = $Result.DefaultSelection<Prisma.$HistoryPayload>
/**
 * Model Error
 * 
 */
export type Error = $Result.DefaultSelection<Prisma.$ErrorPayload>
/**
 * Model CDE
 * 
 */
export type CDE = $Result.DefaultSelection<Prisma.$CDEPayload>
/**
 * Model Application
 * 
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>
/**
 * Model ApprovedStudy
 * 
 */
export type ApprovedStudy = $Result.DefaultSelection<Prisma.$ApprovedStudyPayload>
/**
 * Model Batch
 * 
 */
export type Batch = $Result.DefaultSelection<Prisma.$BatchPayload>
/**
 * Model Configuration
 * 
 */
export type Configuration = $Result.DefaultSelection<Prisma.$ConfigurationPayload>
/**
 * Model DataRecord
 * 
 */
export type DataRecord = $Result.DefaultSelection<Prisma.$DataRecordPayload>
/**
 * Model DataRecordsArchived
 * 
 */
export type DataRecordsArchived = $Result.DefaultSelection<Prisma.$DataRecordsArchivedPayload>
/**
 * Model FileMD5
 * 
 */
export type FileMD5 = $Result.DefaultSelection<Prisma.$FileMD5Payload>
/**
 * Model Institution
 * 
 */
export type Institution = $Result.DefaultSelection<Prisma.$InstitutionPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model QcResult
 * 
 */
export type QcResult = $Result.DefaultSelection<Prisma.$QcResultPayload>
/**
 * Model Release
 * 
 */
export type Release = $Result.DefaultSelection<Prisma.$ReleasePayload>
/**
 * Model Submission
 * 
 */
export type Submission = $Result.DefaultSelection<Prisma.$SubmissionPayload>
/**
 * Model Synonym
 * 
 */
export type Synonym = $Result.DefaultSelection<Prisma.$SynonymPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Validation
 * 
 */
export type Validation = $Result.DefaultSelection<Prisma.$ValidationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CDES
 * const cDES = await prisma.cDE.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CDES
   * const cDES = await prisma.cDE.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.cDE`: Exposes CRUD operations for the **CDE** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CDES
    * const cDES = await prisma.cDE.findMany()
    * ```
    */
  get cDE(): Prisma.CDEDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.ApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.approvedStudy`: Exposes CRUD operations for the **ApprovedStudy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovedStudies
    * const approvedStudies = await prisma.approvedStudy.findMany()
    * ```
    */
  get approvedStudy(): Prisma.ApprovedStudyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batch`: Exposes CRUD operations for the **Batch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batches
    * const batches = await prisma.batch.findMany()
    * ```
    */
  get batch(): Prisma.BatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configuration`: Exposes CRUD operations for the **Configuration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configurations
    * const configurations = await prisma.configuration.findMany()
    * ```
    */
  get configuration(): Prisma.ConfigurationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataRecord`: Exposes CRUD operations for the **DataRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataRecords
    * const dataRecords = await prisma.dataRecord.findMany()
    * ```
    */
  get dataRecord(): Prisma.DataRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataRecordsArchived`: Exposes CRUD operations for the **DataRecordsArchived** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataRecordsArchiveds
    * const dataRecordsArchiveds = await prisma.dataRecordsArchived.findMany()
    * ```
    */
  get dataRecordsArchived(): Prisma.DataRecordsArchivedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileMD5`: Exposes CRUD operations for the **FileMD5** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileMD5s
    * const fileMD5s = await prisma.fileMD5.findMany()
    * ```
    */
  get fileMD5(): Prisma.FileMD5Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institution`: Exposes CRUD operations for the **Institution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutions
    * const institutions = await prisma.institution.findMany()
    * ```
    */
  get institution(): Prisma.InstitutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qcResult`: Exposes CRUD operations for the **QcResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QcResults
    * const qcResults = await prisma.qcResult.findMany()
    * ```
    */
  get qcResult(): Prisma.QcResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.release`: Exposes CRUD operations for the **Release** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Releases
    * const releases = await prisma.release.findMany()
    * ```
    */
  get release(): Prisma.ReleaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.submission`: Exposes CRUD operations for the **Submission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Submissions
    * const submissions = await prisma.submission.findMany()
    * ```
    */
  get submission(): Prisma.SubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.synonym`: Exposes CRUD operations for the **Synonym** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Synonyms
    * const synonyms = await prisma.synonym.findMany()
    * ```
    */
  get synonym(): Prisma.SynonymDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.validation`: Exposes CRUD operations for the **Validation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Validations
    * const validations = await prisma.validation.findMany()
    * ```
    */
  get validation(): Prisma.ValidationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CDE: 'CDE',
    Application: 'Application',
    ApprovedStudy: 'ApprovedStudy',
    Batch: 'Batch',
    Configuration: 'Configuration',
    DataRecord: 'DataRecord',
    DataRecordsArchived: 'DataRecordsArchived',
    FileMD5: 'FileMD5',
    Institution: 'Institution',
    Log: 'Log',
    Program: 'Program',
    QcResult: 'QcResult',
    Release: 'Release',
    Submission: 'Submission',
    Synonym: 'Synonym',
    User: 'User',
    Validation: 'Validation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "cDE" | "application" | "approvedStudy" | "batch" | "configuration" | "dataRecord" | "dataRecordsArchived" | "fileMD5" | "institution" | "log" | "program" | "qcResult" | "release" | "submission" | "synonym" | "user" | "validation"
      txIsolationLevel: never
    }
    model: {
      CDE: {
        payload: Prisma.$CDEPayload<ExtArgs>
        fields: Prisma.CDEFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CDEFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CDEFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          findFirst: {
            args: Prisma.CDEFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CDEFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          findMany: {
            args: Prisma.CDEFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>[]
          }
          create: {
            args: Prisma.CDECreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          createMany: {
            args: Prisma.CDECreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CDEDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          update: {
            args: Prisma.CDEUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          deleteMany: {
            args: Prisma.CDEDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CDEUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CDEUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CDEPayload>
          }
          aggregate: {
            args: Prisma.CDEAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCDE>
          }
          groupBy: {
            args: Prisma.CDEGroupByArgs<ExtArgs>
            result: $Utils.Optional<CDEGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CDEFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CDEAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CDECountArgs<ExtArgs>
            result: $Utils.Optional<CDECountAggregateOutputType> | number
          }
        }
      }
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>
        fields: Prisma.ApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ApplicationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ApplicationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      ApprovedStudy: {
        payload: Prisma.$ApprovedStudyPayload<ExtArgs>
        fields: Prisma.ApprovedStudyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovedStudyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovedStudyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovedStudyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovedStudyPayload>
          }
          findFirst: {
            args: Prisma.ApprovedStudyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovedStudyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovedStudyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovedStudyPayload>
          }
          findMany: {
            args: Prisma.ApprovedStudyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovedStudyPayload>[]
          }
          create: {
            args: Prisma.ApprovedStudyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovedStudyPayload>
          }
          createMany: {
            args: Prisma.ApprovedStudyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ApprovedStudyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovedStudyPayload>
          }
          update: {
            args: Prisma.ApprovedStudyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovedStudyPayload>
          }
          deleteMany: {
            args: Prisma.ApprovedStudyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovedStudyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovedStudyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovedStudyPayload>
          }
          aggregate: {
            args: Prisma.ApprovedStudyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovedStudy>
          }
          groupBy: {
            args: Prisma.ApprovedStudyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovedStudyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ApprovedStudyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ApprovedStudyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ApprovedStudyCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovedStudyCountAggregateOutputType> | number
          }
        }
      }
      Batch: {
        payload: Prisma.$BatchPayload<ExtArgs>
        fields: Prisma.BatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findFirst: {
            args: Prisma.BatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findMany: {
            args: Prisma.BatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          create: {
            args: Prisma.BatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          createMany: {
            args: Prisma.BatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          update: {
            args: Prisma.BatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          deleteMany: {
            args: Prisma.BatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          aggregate: {
            args: Prisma.BatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatch>
          }
          groupBy: {
            args: Prisma.BatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BatchFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BatchAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BatchCountArgs<ExtArgs>
            result: $Utils.Optional<BatchCountAggregateOutputType> | number
          }
        }
      }
      Configuration: {
        payload: Prisma.$ConfigurationPayload<ExtArgs>
        fields: Prisma.ConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findFirst: {
            args: Prisma.ConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findMany: {
            args: Prisma.ConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>[]
          }
          create: {
            args: Prisma.ConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          createMany: {
            args: Prisma.ConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          update: {
            args: Prisma.ConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.ConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          aggregate: {
            args: Prisma.ConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguration>
          }
          groupBy: {
            args: Prisma.ConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ConfigurationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ConfigurationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationCountAggregateOutputType> | number
          }
        }
      }
      DataRecord: {
        payload: Prisma.$DataRecordPayload<ExtArgs>
        fields: Prisma.DataRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordPayload>
          }
          findFirst: {
            args: Prisma.DataRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordPayload>
          }
          findMany: {
            args: Prisma.DataRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordPayload>[]
          }
          create: {
            args: Prisma.DataRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordPayload>
          }
          createMany: {
            args: Prisma.DataRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DataRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordPayload>
          }
          update: {
            args: Prisma.DataRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordPayload>
          }
          deleteMany: {
            args: Prisma.DataRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordPayload>
          }
          aggregate: {
            args: Prisma.DataRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataRecord>
          }
          groupBy: {
            args: Prisma.DataRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataRecordGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DataRecordFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DataRecordAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DataRecordCountArgs<ExtArgs>
            result: $Utils.Optional<DataRecordCountAggregateOutputType> | number
          }
        }
      }
      DataRecordsArchived: {
        payload: Prisma.$DataRecordsArchivedPayload<ExtArgs>
        fields: Prisma.DataRecordsArchivedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataRecordsArchivedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordsArchivedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataRecordsArchivedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordsArchivedPayload>
          }
          findFirst: {
            args: Prisma.DataRecordsArchivedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordsArchivedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataRecordsArchivedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordsArchivedPayload>
          }
          findMany: {
            args: Prisma.DataRecordsArchivedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordsArchivedPayload>[]
          }
          create: {
            args: Prisma.DataRecordsArchivedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordsArchivedPayload>
          }
          createMany: {
            args: Prisma.DataRecordsArchivedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DataRecordsArchivedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordsArchivedPayload>
          }
          update: {
            args: Prisma.DataRecordsArchivedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordsArchivedPayload>
          }
          deleteMany: {
            args: Prisma.DataRecordsArchivedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataRecordsArchivedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataRecordsArchivedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRecordsArchivedPayload>
          }
          aggregate: {
            args: Prisma.DataRecordsArchivedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataRecordsArchived>
          }
          groupBy: {
            args: Prisma.DataRecordsArchivedGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataRecordsArchivedGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DataRecordsArchivedFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DataRecordsArchivedAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DataRecordsArchivedCountArgs<ExtArgs>
            result: $Utils.Optional<DataRecordsArchivedCountAggregateOutputType> | number
          }
        }
      }
      FileMD5: {
        payload: Prisma.$FileMD5Payload<ExtArgs>
        fields: Prisma.FileMD5FieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileMD5FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMD5Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileMD5FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMD5Payload>
          }
          findFirst: {
            args: Prisma.FileMD5FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMD5Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileMD5FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMD5Payload>
          }
          findMany: {
            args: Prisma.FileMD5FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMD5Payload>[]
          }
          create: {
            args: Prisma.FileMD5CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMD5Payload>
          }
          createMany: {
            args: Prisma.FileMD5CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FileMD5DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMD5Payload>
          }
          update: {
            args: Prisma.FileMD5UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMD5Payload>
          }
          deleteMany: {
            args: Prisma.FileMD5DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileMD5UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileMD5UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMD5Payload>
          }
          aggregate: {
            args: Prisma.FileMD5AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileMD5>
          }
          groupBy: {
            args: Prisma.FileMD5GroupByArgs<ExtArgs>
            result: $Utils.Optional<FileMD5GroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FileMD5FindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FileMD5AggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FileMD5CountArgs<ExtArgs>
            result: $Utils.Optional<FileMD5CountAggregateOutputType> | number
          }
        }
      }
      Institution: {
        payload: Prisma.$InstitutionPayload<ExtArgs>
        fields: Prisma.InstitutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstitutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstitutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findFirst: {
            args: Prisma.InstitutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstitutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findMany: {
            args: Prisma.InstitutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          create: {
            args: Prisma.InstitutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          createMany: {
            args: Prisma.InstitutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InstitutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          update: {
            args: Prisma.InstitutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          deleteMany: {
            args: Prisma.InstitutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstitutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstitutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          aggregate: {
            args: Prisma.InstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitution>
          }
          groupBy: {
            args: Prisma.InstitutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InstitutionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InstitutionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InstitutionCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LogFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LogAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProgramFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProgramAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      QcResult: {
        payload: Prisma.$QcResultPayload<ExtArgs>
        fields: Prisma.QcResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QcResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QcResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultPayload>
          }
          findFirst: {
            args: Prisma.QcResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QcResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultPayload>
          }
          findMany: {
            args: Prisma.QcResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultPayload>[]
          }
          create: {
            args: Prisma.QcResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultPayload>
          }
          createMany: {
            args: Prisma.QcResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QcResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultPayload>
          }
          update: {
            args: Prisma.QcResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultPayload>
          }
          deleteMany: {
            args: Prisma.QcResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QcResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QcResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QcResultPayload>
          }
          aggregate: {
            args: Prisma.QcResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQcResult>
          }
          groupBy: {
            args: Prisma.QcResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<QcResultGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.QcResultFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.QcResultAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.QcResultCountArgs<ExtArgs>
            result: $Utils.Optional<QcResultCountAggregateOutputType> | number
          }
        }
      }
      Release: {
        payload: Prisma.$ReleasePayload<ExtArgs>
        fields: Prisma.ReleaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReleaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReleaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          findFirst: {
            args: Prisma.ReleaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReleaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          findMany: {
            args: Prisma.ReleaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>[]
          }
          create: {
            args: Prisma.ReleaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          createMany: {
            args: Prisma.ReleaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReleaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          update: {
            args: Prisma.ReleaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          deleteMany: {
            args: Prisma.ReleaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReleaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReleaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          aggregate: {
            args: Prisma.ReleaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelease>
          }
          groupBy: {
            args: Prisma.ReleaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReleaseGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ReleaseFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ReleaseAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ReleaseCountArgs<ExtArgs>
            result: $Utils.Optional<ReleaseCountAggregateOutputType> | number
          }
        }
      }
      Submission: {
        payload: Prisma.$SubmissionPayload<ExtArgs>
        fields: Prisma.SubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          findFirst: {
            args: Prisma.SubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          findMany: {
            args: Prisma.SubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[]
          }
          create: {
            args: Prisma.SubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          createMany: {
            args: Prisma.SubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          update: {
            args: Prisma.SubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          deleteMany: {
            args: Prisma.SubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          aggregate: {
            args: Prisma.SubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubmission>
          }
          groupBy: {
            args: Prisma.SubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubmissionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SubmissionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SubmissionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<SubmissionCountAggregateOutputType> | number
          }
        }
      }
      Synonym: {
        payload: Prisma.$SynonymPayload<ExtArgs>
        fields: Prisma.SynonymFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SynonymFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SynonymPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SynonymFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SynonymPayload>
          }
          findFirst: {
            args: Prisma.SynonymFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SynonymPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SynonymFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SynonymPayload>
          }
          findMany: {
            args: Prisma.SynonymFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SynonymPayload>[]
          }
          create: {
            args: Prisma.SynonymCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SynonymPayload>
          }
          createMany: {
            args: Prisma.SynonymCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SynonymDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SynonymPayload>
          }
          update: {
            args: Prisma.SynonymUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SynonymPayload>
          }
          deleteMany: {
            args: Prisma.SynonymDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SynonymUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SynonymUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SynonymPayload>
          }
          aggregate: {
            args: Prisma.SynonymAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSynonym>
          }
          groupBy: {
            args: Prisma.SynonymGroupByArgs<ExtArgs>
            result: $Utils.Optional<SynonymGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SynonymFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SynonymAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SynonymCountArgs<ExtArgs>
            result: $Utils.Optional<SynonymCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Validation: {
        payload: Prisma.$ValidationPayload<ExtArgs>
        fields: Prisma.ValidationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ValidationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ValidationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          findFirst: {
            args: Prisma.ValidationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ValidationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          findMany: {
            args: Prisma.ValidationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>[]
          }
          create: {
            args: Prisma.ValidationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          createMany: {
            args: Prisma.ValidationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ValidationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          update: {
            args: Prisma.ValidationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          deleteMany: {
            args: Prisma.ValidationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ValidationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ValidationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPayload>
          }
          aggregate: {
            args: Prisma.ValidationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateValidation>
          }
          groupBy: {
            args: Prisma.ValidationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ValidationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ValidationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ValidationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ValidationCountArgs<ExtArgs>
            result: $Utils.Optional<ValidationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    cDE?: CDEOmit
    application?: ApplicationOmit
    approvedStudy?: ApprovedStudyOmit
    batch?: BatchOmit
    configuration?: ConfigurationOmit
    dataRecord?: DataRecordOmit
    dataRecordsArchived?: DataRecordsArchivedOmit
    fileMD5?: FileMD5Omit
    institution?: InstitutionOmit
    log?: LogOmit
    program?: ProgramOmit
    qcResult?: QcResultOmit
    release?: ReleaseOmit
    submission?: SubmissionOmit
    synonym?: SynonymOmit
    user?: UserOmit
    validation?: ValidationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SubmissionCountOutputType
   */

  export type SubmissionCountOutputType = {
    batches: number
    dataRecords: number
    qcResults: number
    validations: number
  }

  export type SubmissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | SubmissionCountOutputTypeCountBatchesArgs
    dataRecords?: boolean | SubmissionCountOutputTypeCountDataRecordsArgs
    qcResults?: boolean | SubmissionCountOutputTypeCountQcResultsArgs
    validations?: boolean | SubmissionCountOutputTypeCountValidationsArgs
  }

  // Custom InputTypes
  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionCountOutputType
     */
    select?: SubmissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeCountDataRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRecordWhereInput
  }

  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeCountQcResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcResultWhereInput
  }

  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeCountValidationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValidationWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    programs: number
    approvedStudies: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programs?: boolean | UserCountOutputTypeCountProgramsArgs
    approvedStudies?: boolean | UserCountOutputTypeCountApprovedStudiesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovedStudyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model OrgInfo
   */





  export type OrgInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updateAt?: boolean
    orgID?: boolean
    orgName?: boolean
  }, ExtArgs["result"]["orgInfo"]>



  export type OrgInfoSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updateAt?: boolean
    orgID?: boolean
    orgName?: boolean
  }

  export type OrgInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "createdAt" | "updateAt" | "orgID" | "orgName", ExtArgs["result"]["orgInfo"]>

  export type $OrgInfoPayload = {
    name: "OrgInfo"
    objects: {}
    scalars: {
      id: string
      name: string
      status: string | null
      createdAt: Date | null
      updateAt: Date | null
      orgID: string | null
      orgName: string | null
    }
    composites: {}
  }

  type OrgInfoGetPayload<S extends boolean | null | undefined | OrgInfoDefaultArgs> = $Result.GetResult<Prisma.$OrgInfoPayload, S>





  /**
   * Fields of the OrgInfo model
   */
  interface OrgInfoFieldRefs {
    readonly id: FieldRef<"OrgInfo", 'String'>
    readonly name: FieldRef<"OrgInfo", 'String'>
    readonly status: FieldRef<"OrgInfo", 'String'>
    readonly createdAt: FieldRef<"OrgInfo", 'DateTime'>
    readonly updateAt: FieldRef<"OrgInfo", 'DateTime'>
    readonly orgID: FieldRef<"OrgInfo", 'String'>
    readonly orgName: FieldRef<"OrgInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrgInfo without action
   */
  export type OrgInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgInfo
     */
    select?: OrgInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgInfo
     */
    omit?: OrgInfoOmit<ExtArgs> | null
  }


  /**
   * Model Applicant
   */





  export type ApplicantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    applicantEmail?: boolean
    applicantID?: boolean
    applicantName?: boolean
  }, ExtArgs["result"]["applicant"]>



  export type ApplicantSelectScalar = {
    applicantEmail?: boolean
    applicantID?: boolean
    applicantName?: boolean
  }

  export type ApplicantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"applicantEmail" | "applicantID" | "applicantName", ExtArgs["result"]["applicant"]>

  export type $ApplicantPayload = {
    name: "Applicant"
    objects: {}
    scalars: {
      applicantEmail: string
      applicantID: string
      applicantName: string
    }
    composites: {}
  }

  type ApplicantGetPayload<S extends boolean | null | undefined | ApplicantDefaultArgs> = $Result.GetResult<Prisma.$ApplicantPayload, S>





  /**
   * Fields of the Applicant model
   */
  interface ApplicantFieldRefs {
    readonly applicantEmail: FieldRef<"Applicant", 'String'>
    readonly applicantID: FieldRef<"Applicant", 'String'>
    readonly applicantName: FieldRef<"Applicant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Applicant without action
   */
  export type ApplicantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Applicant
     */
    select?: ApplicantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Applicant
     */
    omit?: ApplicantOmit<ExtArgs> | null
  }


  /**
   * Model BatchFiles
   */





  export type BatchFilesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    errors?: boolean
    fileID?: boolean
    fileName?: boolean
    filePrefix?: boolean
    nodeType?: boolean
    signedURL?: boolean
    size?: boolean
    status?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchFiles"]>



  export type BatchFilesSelectScalar = {
    createdAt?: boolean
    errors?: boolean
    fileID?: boolean
    fileName?: boolean
    filePrefix?: boolean
    nodeType?: boolean
    signedURL?: boolean
    size?: boolean
    status?: boolean
    updatedAt?: boolean
  }

  export type BatchFilesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "errors" | "fileID" | "fileName" | "filePrefix" | "nodeType" | "signedURL" | "size" | "status" | "updatedAt", ExtArgs["result"]["batchFiles"]>

  export type $BatchFilesPayload = {
    name: "BatchFiles"
    objects: {}
    scalars: {
      createdAt: Date
      errors: string[]
      fileID: string | null
      fileName: string
      filePrefix: string
      nodeType: string | null
      signedURL: string | null
      size: number | null
      status: string
      updatedAt: Date
    }
    composites: {}
  }

  type BatchFilesGetPayload<S extends boolean | null | undefined | BatchFilesDefaultArgs> = $Result.GetResult<Prisma.$BatchFilesPayload, S>





  /**
   * Fields of the BatchFiles model
   */
  interface BatchFilesFieldRefs {
    readonly createdAt: FieldRef<"BatchFiles", 'DateTime'>
    readonly errors: FieldRef<"BatchFiles", 'String[]'>
    readonly fileID: FieldRef<"BatchFiles", 'String'>
    readonly fileName: FieldRef<"BatchFiles", 'String'>
    readonly filePrefix: FieldRef<"BatchFiles", 'String'>
    readonly nodeType: FieldRef<"BatchFiles", 'String'>
    readonly signedURL: FieldRef<"BatchFiles", 'String'>
    readonly size: FieldRef<"BatchFiles", 'Int'>
    readonly status: FieldRef<"BatchFiles", 'String'>
    readonly updatedAt: FieldRef<"BatchFiles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BatchFiles without action
   */
  export type BatchFilesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchFiles
     */
    select?: BatchFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchFiles
     */
    omit?: BatchFilesOmit<ExtArgs> | null
  }


  /**
   * Model PBACDefaults
   */





  export type PBACDefaultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    notifications?: boolean | NotificationDefaultArgs<ExtArgs>
    permissions?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean
  }, ExtArgs["result"]["pBACDefaults"]>



  export type PBACDefaultsSelectScalar = {
    role?: boolean
  }

  export type PBACDefaultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"notifications" | "permissions" | "role", ExtArgs["result"]["pBACDefaults"]>
  export type PBACDefaultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PBACDefaultsPayload = {
    name: "PBACDefaults"
    objects: {}
    scalars: {
      role: string
    }
    composites: {
      notifications: Prisma.$NotificationPayload[]
      permissions: Prisma.$PermissionPayload[]
    }
  }

  type PBACDefaultsGetPayload<S extends boolean | null | undefined | PBACDefaultsDefaultArgs> = $Result.GetResult<Prisma.$PBACDefaultsPayload, S>





  /**
   * Fields of the PBACDefaults model
   */
  interface PBACDefaultsFieldRefs {
    readonly role: FieldRef<"PBACDefaults", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PBACDefaults without action
   */
  export type PBACDefaultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PBACDefaults
     */
    select?: PBACDefaultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PBACDefaults
     */
    omit?: PBACDefaultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PBACDefaultsInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */





  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checked?: boolean
    disabled?: boolean
    group?: boolean
    name?: boolean
    order?: boolean
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    checked?: boolean
    disabled?: boolean
    group?: boolean
    name?: boolean
    order?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "checked" | "disabled" | "group" | "name" | "order", ExtArgs["result"]["notification"]>

  export type $NotificationPayload = {
    name: "Notification"
    objects: {}
    scalars: {
      id: string
      checked: boolean
      disabled: boolean
      group: string
      name: string
      order: number
    }
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>





  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly checked: FieldRef<"Notification", 'Boolean'>
    readonly disabled: FieldRef<"Notification", 'Boolean'>
    readonly group: FieldRef<"Notification", 'String'>
    readonly name: FieldRef<"Notification", 'String'>
    readonly order: FieldRef<"Notification", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Model Permission
   */





  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checked?: boolean
    disabled?: boolean
    group?: boolean
    inherited?: boolean
    name?: boolean
    order?: boolean
  }, ExtArgs["result"]["permission"]>



  export type PermissionSelectScalar = {
    id?: boolean
    checked?: boolean
    disabled?: boolean
    group?: boolean
    inherited?: boolean
    name?: boolean
    order?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "checked" | "disabled" | "group" | "inherited" | "name" | "order", ExtArgs["result"]["permission"]>

  export type $PermissionPayload = {
    name: "Permission"
    objects: {}
    scalars: {
      id: string
      checked: boolean
      disabled: boolean
      group: string
      inherited: string[]
      name: string
      order: number
    }
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>





  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly checked: FieldRef<"Permission", 'Boolean'>
    readonly disabled: FieldRef<"Permission", 'Boolean'>
    readonly group: FieldRef<"Permission", 'String'>
    readonly inherited: FieldRef<"Permission", 'String[]'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly order: FieldRef<"Permission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
  }


  /**
   * Model ConfigurationTag
   */





  export type ConfigurationTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Key?: boolean
    Value?: boolean
  }, ExtArgs["result"]["configurationTag"]>



  export type ConfigurationTagSelectScalar = {
    Key?: boolean
    Value?: boolean
  }

  export type ConfigurationTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Key" | "Value", ExtArgs["result"]["configurationTag"]>

  export type $ConfigurationTagPayload = {
    name: "ConfigurationTag"
    objects: {}
    scalars: {
      Key: string
      Value: string
    }
    composites: {}
  }

  type ConfigurationTagGetPayload<S extends boolean | null | undefined | ConfigurationTagDefaultArgs> = $Result.GetResult<Prisma.$ConfigurationTagPayload, S>





  /**
   * Fields of the ConfigurationTag model
   */
  interface ConfigurationTagFieldRefs {
    readonly Key: FieldRef<"ConfigurationTag", 'String'>
    readonly Value: FieldRef<"ConfigurationTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConfigurationTag without action
   */
  export type ConfigurationTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigurationTag
     */
    select?: ConfigurationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigurationTag
     */
    omit?: ConfigurationTagOmit<ExtArgs> | null
  }


  /**
   * Model AdditionalError
   */





  export type AdditionalErrorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conflictingSubmissions?: boolean
    description?: boolean
    title?: boolean
  }, ExtArgs["result"]["additionalError"]>



  export type AdditionalErrorSelectScalar = {
    conflictingSubmissions?: boolean
    description?: boolean
    title?: boolean
  }

  export type AdditionalErrorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"conflictingSubmissions" | "description" | "title", ExtArgs["result"]["additionalError"]>

  export type $AdditionalErrorPayload = {
    name: "AdditionalError"
    objects: {}
    scalars: {
      conflictingSubmissions: string[]
      description: string
      title: string
    }
    composites: {}
  }

  type AdditionalErrorGetPayload<S extends boolean | null | undefined | AdditionalErrorDefaultArgs> = $Result.GetResult<Prisma.$AdditionalErrorPayload, S>





  /**
   * Fields of the AdditionalError model
   */
  interface AdditionalErrorFieldRefs {
    readonly conflictingSubmissions: FieldRef<"AdditionalError", 'String[]'>
    readonly description: FieldRef<"AdditionalError", 'String'>
    readonly title: FieldRef<"AdditionalError", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdditionalError without action
   */
  export type AdditionalErrorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdditionalError
     */
    select?: AdditionalErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdditionalError
     */
    omit?: AdditionalErrorOmit<ExtArgs> | null
  }


  /**
   * Model S3FileInfo
   */





  export type S3FileInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    errors?: boolean | ErrorDefaultArgs<ExtArgs>
    fileName?: boolean
    md5?: boolean
    size?: boolean
    status?: boolean
    updatedAt?: boolean
    warnings?: boolean | ErrorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["s3FileInfo"]>



  export type S3FileInfoSelectScalar = {
    createdAt?: boolean
    fileName?: boolean
    md5?: boolean
    size?: boolean
    status?: boolean
    updatedAt?: boolean
  }

  export type S3FileInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "errors" | "fileName" | "md5" | "size" | "status" | "updatedAt" | "warnings", ExtArgs["result"]["s3FileInfo"]>
  export type S3FileInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $S3FileInfoPayload = {
    name: "S3FileInfo"
    objects: {}
    scalars: {
      createdAt: Date | null
      fileName: string
      md5: string | null
      size: string | null
      status: string
      updatedAt: Date | null
    }
    composites: {
      errors: Prisma.$ErrorPayload[]
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      warnings: Prisma.$ErrorPayload[]
    }
  }

  type S3FileInfoGetPayload<S extends boolean | null | undefined | S3FileInfoDefaultArgs> = $Result.GetResult<Prisma.$S3FileInfoPayload, S>





  /**
   * Fields of the S3FileInfo model
   */
  interface S3FileInfoFieldRefs {
    readonly createdAt: FieldRef<"S3FileInfo", 'DateTime'>
    readonly fileName: FieldRef<"S3FileInfo", 'String'>
    readonly md5: FieldRef<"S3FileInfo", 'String'>
    readonly size: FieldRef<"S3FileInfo", 'String'>
    readonly status: FieldRef<"S3FileInfo", 'String'>
    readonly updatedAt: FieldRef<"S3FileInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * S3FileInfo without action
   */
  export type S3FileInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3FileInfo
     */
    select?: S3FileInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3FileInfo
     */
    omit?: S3FileInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInfoInclude<ExtArgs> | null
  }


  /**
   * Model LogsEventDetail
   */





  export type LogsEventDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nodeIDs?: boolean
    nodeType?: boolean
    submissionID?: boolean
  }, ExtArgs["result"]["logsEventDetail"]>



  export type LogsEventDetailSelectScalar = {
    nodeIDs?: boolean
    nodeType?: boolean
    submissionID?: boolean
  }

  export type LogsEventDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"nodeIDs" | "nodeType" | "submissionID", ExtArgs["result"]["logsEventDetail"]>

  export type $LogsEventDetailPayload = {
    name: "LogsEventDetail"
    objects: {}
    scalars: {
      nodeIDs: string[]
      nodeType: string
      submissionID: string
    }
    composites: {}
  }

  type LogsEventDetailGetPayload<S extends boolean | null | undefined | LogsEventDetailDefaultArgs> = $Result.GetResult<Prisma.$LogsEventDetailPayload, S>





  /**
   * Fields of the LogsEventDetail model
   */
  interface LogsEventDetailFieldRefs {
    readonly nodeIDs: FieldRef<"LogsEventDetail", 'String[]'>
    readonly nodeType: FieldRef<"LogsEventDetail", 'String'>
    readonly submissionID: FieldRef<"LogsEventDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LogsEventDetail without action
   */
  export type LogsEventDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogsEventDetail
     */
    select?: LogsEventDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LogsEventDetail
     */
    omit?: LogsEventDetailOmit<ExtArgs> | null
  }


  /**
   * Model InstitutionInfo
   */





  export type InstitutionInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
  }, ExtArgs["result"]["institutionInfo"]>



  export type InstitutionInfoSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
  }

  export type InstitutionInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status", ExtArgs["result"]["institutionInfo"]>

  export type $InstitutionInfoPayload = {
    name: "InstitutionInfo"
    objects: {}
    scalars: {
      id: string
      name: string
      status: string
    }
    composites: {}
  }

  type InstitutionInfoGetPayload<S extends boolean | null | undefined | InstitutionInfoDefaultArgs> = $Result.GetResult<Prisma.$InstitutionInfoPayload, S>





  /**
   * Fields of the InstitutionInfo model
   */
  interface InstitutionInfoFieldRefs {
    readonly id: FieldRef<"InstitutionInfo", 'String'>
    readonly name: FieldRef<"InstitutionInfo", 'String'>
    readonly status: FieldRef<"InstitutionInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InstitutionInfo without action
   */
  export type InstitutionInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionInfo
     */
    select?: InstitutionInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstitutionInfo
     */
    omit?: InstitutionInfoOmit<ExtArgs> | null
  }


  /**
   * Model Collaborator
   */





  export type CollaboratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Organization?: boolean | OrgInfoDefaultArgs<ExtArgs>
    collaboratorID?: boolean
    collaboratorName?: boolean
    permission?: boolean
  }, ExtArgs["result"]["collaborator"]>



  export type CollaboratorSelectScalar = {
    collaboratorID?: boolean
    collaboratorName?: boolean
    permission?: boolean
  }

  export type CollaboratorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Organization" | "collaboratorID" | "collaboratorName" | "permission", ExtArgs["result"]["collaborator"]>
  export type CollaboratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CollaboratorPayload = {
    name: "Collaborator"
    objects: {}
    scalars: {
      collaboratorID: string
      collaboratorName: string | null
      /**
       * Multiple data types found: String: 97.4%, Array(String): 2.6% out of 38 sampled entries
       */
      permission: Prisma.JsonValue
    }
    composites: {
      Organization: Prisma.$OrgInfoPayload | null
    }
  }

  type CollaboratorGetPayload<S extends boolean | null | undefined | CollaboratorDefaultArgs> = $Result.GetResult<Prisma.$CollaboratorPayload, S>





  /**
   * Fields of the Collaborator model
   */
  interface CollaboratorFieldRefs {
    readonly collaboratorID: FieldRef<"Collaborator", 'String'>
    readonly collaboratorName: FieldRef<"Collaborator", 'String'>
    readonly permission: FieldRef<"Collaborator", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Collaborator without action
   */
  export type CollaboratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collaborator
     */
    select?: CollaboratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collaborator
     */
    omit?: CollaboratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollaboratorInclude<ExtArgs> | null
  }


  /**
   * Model DataFileSize
   */





  export type DataFileSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    formatted?: boolean
    size?: boolean
  }, ExtArgs["result"]["dataFileSize"]>



  export type DataFileSizeSelectScalar = {
    formatted?: boolean
    size?: boolean
  }

  export type DataFileSizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"formatted" | "size", ExtArgs["result"]["dataFileSize"]>

  export type $DataFileSizePayload = {
    name: "DataFileSize"
    objects: {}
    scalars: {
      formatted: string
      size: number
    }
    composites: {}
  }

  type DataFileSizeGetPayload<S extends boolean | null | undefined | DataFileSizeDefaultArgs> = $Result.GetResult<Prisma.$DataFileSizePayload, S>





  /**
   * Fields of the DataFileSize model
   */
  interface DataFileSizeFieldRefs {
    readonly formatted: FieldRef<"DataFileSize", 'String'>
    readonly size: FieldRef<"DataFileSize", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DataFileSize without action
   */
  export type DataFileSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataFileSize
     */
    select?: DataFileSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataFileSize
     */
    omit?: DataFileSizeOmit<ExtArgs> | null
  }


  /**
   * Model StudyByID
   */





  export type StudyByIDSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["studyByID"]>



  export type StudyByIDSelectScalar = {
    id?: boolean
  }

  export type StudyByIDOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["studyByID"]>

  export type $StudyByIDPayload = {
    name: "StudyByID"
    objects: {}
    scalars: {
      id: string
    }
    composites: {}
  }

  type StudyByIDGetPayload<S extends boolean | null | undefined | StudyByIDDefaultArgs> = $Result.GetResult<Prisma.$StudyByIDPayload, S>





  /**
   * Fields of the StudyByID model
   */
  interface StudyByIDFieldRefs {
    readonly id: FieldRef<"StudyByID", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudyByID without action
   */
  export type StudyByIDDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyByID
     */
    select?: StudyByIDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyByID
     */
    omit?: StudyByIDOmit<ExtArgs> | null
  }


  /**
   * Model Parent
   */





  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parentIDPropName?: boolean
    parentIDValue?: boolean
    parentType?: boolean
  }, ExtArgs["result"]["parent"]>



  export type ParentSelectScalar = {
    parentIDPropName?: boolean
    parentIDValue?: boolean
    parentType?: boolean
  }

  export type ParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"parentIDPropName" | "parentIDValue" | "parentType", ExtArgs["result"]["parent"]>

  export type $ParentPayload = {
    name: "Parent"
    objects: {}
    scalars: {
      parentIDPropName: string
      parentIDValue: string
      parentType: string
    }
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>





  /**
   * Fields of the Parent model
   */
  interface ParentFieldRefs {
    readonly parentIDPropName: FieldRef<"Parent", 'String'>
    readonly parentIDValue: FieldRef<"Parent", 'String'>
    readonly parentType: FieldRef<"Parent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
  }


  /**
   * Model History
   */





  export type HistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dateTime?: boolean
    reviewComment?: boolean
    status?: boolean
    userID?: boolean
    userName?: boolean
  }, ExtArgs["result"]["history"]>



  export type HistorySelectScalar = {
    dateTime?: boolean
    reviewComment?: boolean
    status?: boolean
    userID?: boolean
    userName?: boolean
  }

  export type HistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"dateTime" | "reviewComment" | "status" | "userID" | "userName", ExtArgs["result"]["history"]>

  export type $HistoryPayload = {
    name: "History"
    objects: {}
    scalars: {
      dateTime: Date
      reviewComment: string | null
      status: string
      userID: string
      userName: string | null
    }
    composites: {}
  }

  type HistoryGetPayload<S extends boolean | null | undefined | HistoryDefaultArgs> = $Result.GetResult<Prisma.$HistoryPayload, S>





  /**
   * Fields of the History model
   */
  interface HistoryFieldRefs {
    readonly dateTime: FieldRef<"History", 'DateTime'>
    readonly reviewComment: FieldRef<"History", 'String'>
    readonly status: FieldRef<"History", 'String'>
    readonly userID: FieldRef<"History", 'String'>
    readonly userName: FieldRef<"History", 'String'>
  }
    

  // Custom InputTypes
  /**
   * History without action
   */
  export type HistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History
     */
    select?: HistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the History
     */
    omit?: HistoryOmit<ExtArgs> | null
  }


  /**
   * Model Error
   */





  export type ErrorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    description?: boolean
    code?: boolean
    offendingProperty?: boolean
    offendingValue?: boolean
    severity?: boolean
  }, ExtArgs["result"]["error"]>



  export type ErrorSelectScalar = {
    title?: boolean
    description?: boolean
    code?: boolean
    offendingProperty?: boolean
    offendingValue?: boolean
    severity?: boolean
  }

  export type ErrorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"title" | "description" | "code" | "offendingProperty" | "offendingValue" | "severity", ExtArgs["result"]["error"]>

  export type $ErrorPayload = {
    name: "Error"
    objects: {}
    scalars: {
      title: string
      description: string
      code: string | null
      offendingProperty: string | null
      offendingValue: string | null
      severity: string | null
    }
    composites: {}
  }

  type ErrorGetPayload<S extends boolean | null | undefined | ErrorDefaultArgs> = $Result.GetResult<Prisma.$ErrorPayload, S>





  /**
   * Fields of the Error model
   */
  interface ErrorFieldRefs {
    readonly title: FieldRef<"Error", 'String'>
    readonly description: FieldRef<"Error", 'String'>
    readonly code: FieldRef<"Error", 'String'>
    readonly offendingProperty: FieldRef<"Error", 'String'>
    readonly offendingValue: FieldRef<"Error", 'String'>
    readonly severity: FieldRef<"Error", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Error without action
   */
  export type ErrorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Error
     */
    select?: ErrorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Error
     */
    omit?: ErrorOmit<ExtArgs> | null
  }


  /**
   * Model CDE
   */

  export type AggregateCDE = {
    _count: CDECountAggregateOutputType | null
    _min: CDEMinAggregateOutputType | null
    _max: CDEMaxAggregateOutputType | null
  }

  export type CDEMinAggregateOutputType = {
    id: string | null
    CDECode: string | null
    CDEFullName: string | null
    CDEVersion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CDEMaxAggregateOutputType = {
    id: string | null
    CDECode: string | null
    CDEFullName: string | null
    CDEVersion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CDECountAggregateOutputType = {
    id: number
    CDECode: number
    CDEFullName: number
    CDEVersion: number
    PermissibleValues: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CDEMinAggregateInputType = {
    id?: true
    CDECode?: true
    CDEFullName?: true
    CDEVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CDEMaxAggregateInputType = {
    id?: true
    CDECode?: true
    CDEFullName?: true
    CDEVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CDECountAggregateInputType = {
    id?: true
    CDECode?: true
    CDEFullName?: true
    CDEVersion?: true
    PermissibleValues?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CDEAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CDE to aggregate.
     */
    where?: CDEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CDES to fetch.
     */
    orderBy?: CDEOrderByWithRelationInput | CDEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CDEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CDES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CDES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CDES
    **/
    _count?: true | CDECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CDEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CDEMaxAggregateInputType
  }

  export type GetCDEAggregateType<T extends CDEAggregateArgs> = {
        [P in keyof T & keyof AggregateCDE]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCDE[P]>
      : GetScalarType<T[P], AggregateCDE[P]>
  }




  export type CDEGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CDEWhereInput
    orderBy?: CDEOrderByWithAggregationInput | CDEOrderByWithAggregationInput[]
    by: CDEScalarFieldEnum[] | CDEScalarFieldEnum
    having?: CDEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CDECountAggregateInputType | true
    _min?: CDEMinAggregateInputType
    _max?: CDEMaxAggregateInputType
  }

  export type CDEGroupByOutputType = {
    id: string
    CDECode: string
    CDEFullName: string
    CDEVersion: string | null
    PermissibleValues: string[]
    createdAt: Date
    updatedAt: Date
    _count: CDECountAggregateOutputType | null
    _min: CDEMinAggregateOutputType | null
    _max: CDEMaxAggregateOutputType | null
  }

  type GetCDEGroupByPayload<T extends CDEGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CDEGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CDEGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CDEGroupByOutputType[P]>
            : GetScalarType<T[P], CDEGroupByOutputType[P]>
        }
      >
    >


  export type CDESelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CDECode?: boolean
    CDEFullName?: boolean
    CDEVersion?: boolean
    PermissibleValues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cDE"]>



  export type CDESelectScalar = {
    id?: boolean
    CDECode?: boolean
    CDEFullName?: boolean
    CDEVersion?: boolean
    PermissibleValues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CDEOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "CDECode" | "CDEFullName" | "CDEVersion" | "PermissibleValues" | "createdAt" | "updatedAt", ExtArgs["result"]["cDE"]>

  export type $CDEPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CDE"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      CDECode: string
      CDEFullName: string
      CDEVersion: string | null
      PermissibleValues: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cDE"]>
    composites: {}
  }

  type CDEGetPayload<S extends boolean | null | undefined | CDEDefaultArgs> = $Result.GetResult<Prisma.$CDEPayload, S>

  type CDECountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CDEFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CDECountAggregateInputType | true
    }

  export interface CDEDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CDE'], meta: { name: 'CDE' } }
    /**
     * Find zero or one CDE that matches the filter.
     * @param {CDEFindUniqueArgs} args - Arguments to find a CDE
     * @example
     * // Get one CDE
     * const cDE = await prisma.cDE.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CDEFindUniqueArgs>(args: SelectSubset<T, CDEFindUniqueArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CDE that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CDEFindUniqueOrThrowArgs} args - Arguments to find a CDE
     * @example
     * // Get one CDE
     * const cDE = await prisma.cDE.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CDEFindUniqueOrThrowArgs>(args: SelectSubset<T, CDEFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CDE that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEFindFirstArgs} args - Arguments to find a CDE
     * @example
     * // Get one CDE
     * const cDE = await prisma.cDE.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CDEFindFirstArgs>(args?: SelectSubset<T, CDEFindFirstArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CDE that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEFindFirstOrThrowArgs} args - Arguments to find a CDE
     * @example
     * // Get one CDE
     * const cDE = await prisma.cDE.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CDEFindFirstOrThrowArgs>(args?: SelectSubset<T, CDEFindFirstOrThrowArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CDES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CDES
     * const cDES = await prisma.cDE.findMany()
     * 
     * // Get first 10 CDES
     * const cDES = await prisma.cDE.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cDEWithIdOnly = await prisma.cDE.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CDEFindManyArgs>(args?: SelectSubset<T, CDEFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CDE.
     * @param {CDECreateArgs} args - Arguments to create a CDE.
     * @example
     * // Create one CDE
     * const CDE = await prisma.cDE.create({
     *   data: {
     *     // ... data to create a CDE
     *   }
     * })
     * 
     */
    create<T extends CDECreateArgs>(args: SelectSubset<T, CDECreateArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CDES.
     * @param {CDECreateManyArgs} args - Arguments to create many CDES.
     * @example
     * // Create many CDES
     * const cDE = await prisma.cDE.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CDECreateManyArgs>(args?: SelectSubset<T, CDECreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CDE.
     * @param {CDEDeleteArgs} args - Arguments to delete one CDE.
     * @example
     * // Delete one CDE
     * const CDE = await prisma.cDE.delete({
     *   where: {
     *     // ... filter to delete one CDE
     *   }
     * })
     * 
     */
    delete<T extends CDEDeleteArgs>(args: SelectSubset<T, CDEDeleteArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CDE.
     * @param {CDEUpdateArgs} args - Arguments to update one CDE.
     * @example
     * // Update one CDE
     * const cDE = await prisma.cDE.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CDEUpdateArgs>(args: SelectSubset<T, CDEUpdateArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CDES.
     * @param {CDEDeleteManyArgs} args - Arguments to filter CDES to delete.
     * @example
     * // Delete a few CDES
     * const { count } = await prisma.cDE.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CDEDeleteManyArgs>(args?: SelectSubset<T, CDEDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CDES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CDES
     * const cDE = await prisma.cDE.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CDEUpdateManyArgs>(args: SelectSubset<T, CDEUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CDE.
     * @param {CDEUpsertArgs} args - Arguments to update or create a CDE.
     * @example
     * // Update or create a CDE
     * const cDE = await prisma.cDE.upsert({
     *   create: {
     *     // ... data to create a CDE
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CDE we want to update
     *   }
     * })
     */
    upsert<T extends CDEUpsertArgs>(args: SelectSubset<T, CDEUpsertArgs<ExtArgs>>): Prisma__CDEClient<$Result.GetResult<Prisma.$CDEPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CDES that matches the filter.
     * @param {CDEFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const cDE = await prisma.cDE.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CDEFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CDE.
     * @param {CDEAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const cDE = await prisma.cDE.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CDEAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CDES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDECountArgs} args - Arguments to filter CDES to count.
     * @example
     * // Count the number of CDES
     * const count = await prisma.cDE.count({
     *   where: {
     *     // ... the filter for the CDES we want to count
     *   }
     * })
    **/
    count<T extends CDECountArgs>(
      args?: Subset<T, CDECountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CDECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CDE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CDEAggregateArgs>(args: Subset<T, CDEAggregateArgs>): Prisma.PrismaPromise<GetCDEAggregateType<T>>

    /**
     * Group by CDE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CDEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CDEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CDEGroupByArgs['orderBy'] }
        : { orderBy?: CDEGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CDEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCDEGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CDE model
   */
  readonly fields: CDEFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CDE.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CDEClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CDE model
   */
  interface CDEFieldRefs {
    readonly id: FieldRef<"CDE", 'String'>
    readonly CDECode: FieldRef<"CDE", 'String'>
    readonly CDEFullName: FieldRef<"CDE", 'String'>
    readonly CDEVersion: FieldRef<"CDE", 'String'>
    readonly PermissibleValues: FieldRef<"CDE", 'String[]'>
    readonly createdAt: FieldRef<"CDE", 'DateTime'>
    readonly updatedAt: FieldRef<"CDE", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CDE findUnique
   */
  export type CDEFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter, which CDE to fetch.
     */
    where: CDEWhereUniqueInput
  }

  /**
   * CDE findUniqueOrThrow
   */
  export type CDEFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter, which CDE to fetch.
     */
    where: CDEWhereUniqueInput
  }

  /**
   * CDE findFirst
   */
  export type CDEFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter, which CDE to fetch.
     */
    where?: CDEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CDES to fetch.
     */
    orderBy?: CDEOrderByWithRelationInput | CDEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CDES.
     */
    cursor?: CDEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CDES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CDES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CDES.
     */
    distinct?: CDEScalarFieldEnum | CDEScalarFieldEnum[]
  }

  /**
   * CDE findFirstOrThrow
   */
  export type CDEFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter, which CDE to fetch.
     */
    where?: CDEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CDES to fetch.
     */
    orderBy?: CDEOrderByWithRelationInput | CDEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CDES.
     */
    cursor?: CDEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CDES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CDES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CDES.
     */
    distinct?: CDEScalarFieldEnum | CDEScalarFieldEnum[]
  }

  /**
   * CDE findMany
   */
  export type CDEFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter, which CDES to fetch.
     */
    where?: CDEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CDES to fetch.
     */
    orderBy?: CDEOrderByWithRelationInput | CDEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CDES.
     */
    cursor?: CDEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CDES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CDES.
     */
    skip?: number
    distinct?: CDEScalarFieldEnum | CDEScalarFieldEnum[]
  }

  /**
   * CDE create
   */
  export type CDECreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * The data needed to create a CDE.
     */
    data: XOR<CDECreateInput, CDEUncheckedCreateInput>
  }

  /**
   * CDE createMany
   */
  export type CDECreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CDES.
     */
    data: CDECreateManyInput | CDECreateManyInput[]
  }

  /**
   * CDE update
   */
  export type CDEUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * The data needed to update a CDE.
     */
    data: XOR<CDEUpdateInput, CDEUncheckedUpdateInput>
    /**
     * Choose, which CDE to update.
     */
    where: CDEWhereUniqueInput
  }

  /**
   * CDE updateMany
   */
  export type CDEUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CDES.
     */
    data: XOR<CDEUpdateManyMutationInput, CDEUncheckedUpdateManyInput>
    /**
     * Filter which CDES to update
     */
    where?: CDEWhereInput
    /**
     * Limit how many CDES to update.
     */
    limit?: number
  }

  /**
   * CDE upsert
   */
  export type CDEUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * The filter to search for the CDE to update in case it exists.
     */
    where: CDEWhereUniqueInput
    /**
     * In case the CDE found by the `where` argument doesn't exist, create a new CDE with this data.
     */
    create: XOR<CDECreateInput, CDEUncheckedCreateInput>
    /**
     * In case the CDE was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CDEUpdateInput, CDEUncheckedUpdateInput>
  }

  /**
   * CDE delete
   */
  export type CDEDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
    /**
     * Filter which CDE to delete.
     */
    where: CDEWhereUniqueInput
  }

  /**
   * CDE deleteMany
   */
  export type CDEDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CDES to delete
     */
    where?: CDEWhereInput
    /**
     * Limit how many CDES to delete.
     */
    limit?: number
  }

  /**
   * CDE findRaw
   */
  export type CDEFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CDE aggregateRaw
   */
  export type CDEAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CDE without action
   */
  export type CDEDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CDE
     */
    select?: CDESelect<ExtArgs> | null
    /**
     * Omit specific fields from the CDE
     */
    omit?: CDEOmit<ExtArgs> | null
  }


  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationMinAggregateOutputType = {
    id: string | null
    version: string | null
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean | null
    inactiveReminder: boolean | null
    openAccess: boolean | null
    programAbbreviation: string | null
    programDescription: string | null
    programName: string | null
    questionnaireData: string | null
    reviewComment: string | null
    status: string | null
    studyAbbreviation: string | null
    studyName: string | null
    submittedDate: Date | null
    wholeProgram: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationMaxAggregateOutputType = {
    id: string | null
    version: string | null
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean | null
    inactiveReminder: boolean | null
    openAccess: boolean | null
    programAbbreviation: string | null
    programDescription: string | null
    programName: string | null
    questionnaireData: string | null
    reviewComment: string | null
    status: string | null
    studyAbbreviation: string | null
    studyName: string | null
    submittedDate: Date | null
    wholeProgram: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApplicationCountAggregateOutputType = {
    id: number
    version: number
    ORCID: number
    PI: number
    controlledAccess: number
    inactiveReminder: number
    openAccess: number
    programAbbreviation: number
    programDescription: number
    programName: number
    questionnaireData: number
    reviewComment: number
    status: number
    studyAbbreviation: number
    studyName: number
    submittedDate: number
    wholeProgram: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApplicationMinAggregateInputType = {
    id?: true
    version?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    inactiveReminder?: true
    openAccess?: true
    programAbbreviation?: true
    programDescription?: true
    programName?: true
    questionnaireData?: true
    reviewComment?: true
    status?: true
    studyAbbreviation?: true
    studyName?: true
    submittedDate?: true
    wholeProgram?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApplicationMaxAggregateInputType = {
    id?: true
    version?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    inactiveReminder?: true
    openAccess?: true
    programAbbreviation?: true
    programDescription?: true
    programName?: true
    questionnaireData?: true
    reviewComment?: true
    status?: true
    studyAbbreviation?: true
    studyName?: true
    submittedDate?: true
    wholeProgram?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApplicationCountAggregateInputType = {
    id?: true
    version?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    inactiveReminder?: true
    openAccess?: true
    programAbbreviation?: true
    programDescription?: true
    programName?: true
    questionnaireData?: true
    reviewComment?: true
    status?: true
    studyAbbreviation?: true
    studyName?: true
    submittedDate?: true
    wholeProgram?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type ApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: ApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    id: string
    version: string
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean | null
    inactiveReminder: boolean | null
    openAccess: boolean | null
    programAbbreviation: string | null
    programDescription: string | null
    programName: string
    questionnaireData: string
    reviewComment: string | null
    status: string
    studyAbbreviation: string
    studyName: string
    submittedDate: Date | null
    wholeProgram: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    ORCID?: boolean
    PI?: boolean
    applicant?: boolean | ApplicantDefaultArgs<ExtArgs>
    controlledAccess?: boolean
    history?: boolean | HistoryDefaultArgs<ExtArgs>
    inactiveReminder?: boolean
    openAccess?: boolean
    organization?: boolean | OrgInfoDefaultArgs<ExtArgs>
    programAbbreviation?: boolean
    programDescription?: boolean
    programName?: boolean
    questionnaireData?: boolean
    reviewComment?: boolean
    status?: boolean
    studyAbbreviation?: boolean
    studyName?: boolean
    submittedDate?: boolean
    wholeProgram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["application"]>



  export type ApplicationSelectScalar = {
    id?: boolean
    version?: boolean
    ORCID?: boolean
    PI?: boolean
    controlledAccess?: boolean
    inactiveReminder?: boolean
    openAccess?: boolean
    programAbbreviation?: boolean
    programDescription?: boolean
    programName?: boolean
    questionnaireData?: boolean
    reviewComment?: boolean
    status?: boolean
    studyAbbreviation?: boolean
    studyName?: boolean
    submittedDate?: boolean
    wholeProgram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "version" | "ORCID" | "PI" | "applicant" | "controlledAccess" | "history" | "inactiveReminder" | "openAccess" | "organization" | "programAbbreviation" | "programDescription" | "programName" | "questionnaireData" | "reviewComment" | "status" | "studyAbbreviation" | "studyName" | "submittedDate" | "wholeProgram" | "createdAt" | "updatedAt", ExtArgs["result"]["application"]>
  export type ApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Application"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      version: string
      ORCID: string | null
      PI: string | null
      controlledAccess: boolean | null
      inactiveReminder: boolean | null
      openAccess: boolean | null
      programAbbreviation: string | null
      programDescription: string | null
      programName: string
      questionnaireData: string
      reviewComment: string | null
      status: string
      studyAbbreviation: string
      studyName: string
      /**
       * Multiple data types found: String: 4.8%, DateTime (Date): 95.2% out of 21 sampled entries
       */
      submittedDate: Date | null
      wholeProgram: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["application"]>
    composites: {
      applicant: Prisma.$ApplicantPayload
      history: Prisma.$HistoryPayload[]
      organization: Prisma.$OrgInfoPayload
    }
  }

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationPayload, S>

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface ApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Application'], meta: { name: 'Application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicationWithIdOnly = await prisma.application.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicationFindManyArgs>(args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends ApplicationCreateArgs>(args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationCreateManyArgs>(args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDeleteArgs>(args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationUpdateArgs>(args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationUpdateManyArgs>(args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applications that matches the filter.
     * @param {ApplicationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const application = await prisma.application.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ApplicationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Application.
     * @param {ApplicationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const application = await prisma.application.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ApplicationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Application model
   */
  readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Application model
   */
  interface ApplicationFieldRefs {
    readonly id: FieldRef<"Application", 'String'>
    readonly version: FieldRef<"Application", 'String'>
    readonly ORCID: FieldRef<"Application", 'String'>
    readonly PI: FieldRef<"Application", 'String'>
    readonly controlledAccess: FieldRef<"Application", 'Boolean'>
    readonly inactiveReminder: FieldRef<"Application", 'Boolean'>
    readonly openAccess: FieldRef<"Application", 'Boolean'>
    readonly programAbbreviation: FieldRef<"Application", 'String'>
    readonly programDescription: FieldRef<"Application", 'String'>
    readonly programName: FieldRef<"Application", 'String'>
    readonly questionnaireData: FieldRef<"Application", 'String'>
    readonly reviewComment: FieldRef<"Application", 'String'>
    readonly status: FieldRef<"Application", 'String'>
    readonly studyAbbreviation: FieldRef<"Application", 'String'>
    readonly studyName: FieldRef<"Application", 'String'>
    readonly submittedDate: FieldRef<"Application", 'DateTime'>
    readonly wholeProgram: FieldRef<"Application", 'Boolean'>
    readonly createdAt: FieldRef<"Application", 'DateTime'>
    readonly updatedAt: FieldRef<"Application", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application create
   */
  export type ApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
  }

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
  }

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to update.
     */
    limit?: number
  }

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
  }

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to delete.
     */
    limit?: number
  }

  /**
   * Application findRaw
   */
  export type ApplicationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Application aggregateRaw
   */
  export type ApplicationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
  }


  /**
   * Model ApprovedStudy
   */

  export type AggregateApprovedStudy = {
    _count: ApprovedStudyCountAggregateOutputType | null
    _min: ApprovedStudyMinAggregateOutputType | null
    _max: ApprovedStudyMaxAggregateOutputType | null
  }

  export type ApprovedStudyMinAggregateOutputType = {
    id: string | null
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean | null
    dbGaPID: string | null
    openAccess: boolean | null
    originalOrg: string | null
    primaryContactID: string | null
    programName: string | null
    studyAbbreviation: string | null
    studyName: string | null
    useProgramPC: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovedStudyMaxAggregateOutputType = {
    id: string | null
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean | null
    dbGaPID: string | null
    openAccess: boolean | null
    originalOrg: string | null
    primaryContactID: string | null
    programName: string | null
    studyAbbreviation: string | null
    studyName: string | null
    useProgramPC: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovedStudyCountAggregateOutputType = {
    id: number
    ORCID: number
    PI: number
    controlledAccess: number
    dbGaPID: number
    openAccess: number
    originalOrg: number
    primaryContactID: number
    programName: number
    studyAbbreviation: number
    studyName: number
    useProgramPC: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApprovedStudyMinAggregateInputType = {
    id?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    dbGaPID?: true
    openAccess?: true
    originalOrg?: true
    primaryContactID?: true
    programName?: true
    studyAbbreviation?: true
    studyName?: true
    useProgramPC?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovedStudyMaxAggregateInputType = {
    id?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    dbGaPID?: true
    openAccess?: true
    originalOrg?: true
    primaryContactID?: true
    programName?: true
    studyAbbreviation?: true
    studyName?: true
    useProgramPC?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovedStudyCountAggregateInputType = {
    id?: true
    ORCID?: true
    PI?: true
    controlledAccess?: true
    dbGaPID?: true
    openAccess?: true
    originalOrg?: true
    primaryContactID?: true
    programName?: true
    studyAbbreviation?: true
    studyName?: true
    useProgramPC?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApprovedStudyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovedStudy to aggregate.
     */
    where?: ApprovedStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovedStudies to fetch.
     */
    orderBy?: ApprovedStudyOrderByWithRelationInput | ApprovedStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovedStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovedStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovedStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovedStudies
    **/
    _count?: true | ApprovedStudyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovedStudyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovedStudyMaxAggregateInputType
  }

  export type GetApprovedStudyAggregateType<T extends ApprovedStudyAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovedStudy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovedStudy[P]>
      : GetScalarType<T[P], AggregateApprovedStudy[P]>
  }




  export type ApprovedStudyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovedStudyWhereInput
    orderBy?: ApprovedStudyOrderByWithAggregationInput | ApprovedStudyOrderByWithAggregationInput[]
    by: ApprovedStudyScalarFieldEnum[] | ApprovedStudyScalarFieldEnum
    having?: ApprovedStudyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovedStudyCountAggregateInputType | true
    _min?: ApprovedStudyMinAggregateInputType
    _max?: ApprovedStudyMaxAggregateInputType
  }

  export type ApprovedStudyGroupByOutputType = {
    id: string
    ORCID: string | null
    PI: string | null
    controlledAccess: boolean
    dbGaPID: string | null
    openAccess: boolean | null
    originalOrg: string | null
    primaryContactID: string | null
    programName: string | null
    studyAbbreviation: string
    studyName: string
    useProgramPC: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: ApprovedStudyCountAggregateOutputType | null
    _min: ApprovedStudyMinAggregateOutputType | null
    _max: ApprovedStudyMaxAggregateOutputType | null
  }

  type GetApprovedStudyGroupByPayload<T extends ApprovedStudyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovedStudyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovedStudyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovedStudyGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovedStudyGroupByOutputType[P]>
        }
      >
    >


  export type ApprovedStudySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ORCID?: boolean
    PI?: boolean
    controlledAccess?: boolean
    dbGaPID?: boolean
    openAccess?: boolean
    originalOrg?: boolean
    primaryContactID?: boolean
    programName?: boolean
    studyAbbreviation?: boolean
    studyName?: boolean
    useProgramPC?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Concierge?: boolean | ApprovedStudy$ConciergeArgs<ExtArgs>
  }, ExtArgs["result"]["approvedStudy"]>



  export type ApprovedStudySelectScalar = {
    id?: boolean
    ORCID?: boolean
    PI?: boolean
    controlledAccess?: boolean
    dbGaPID?: boolean
    openAccess?: boolean
    originalOrg?: boolean
    primaryContactID?: boolean
    programName?: boolean
    studyAbbreviation?: boolean
    studyName?: boolean
    useProgramPC?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApprovedStudyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ORCID" | "PI" | "controlledAccess" | "dbGaPID" | "openAccess" | "originalOrg" | "primaryContactID" | "programName" | "studyAbbreviation" | "studyName" | "useProgramPC" | "createdAt" | "updatedAt", ExtArgs["result"]["approvedStudy"]>
  export type ApprovedStudyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Concierge?: boolean | ApprovedStudy$ConciergeArgs<ExtArgs>
  }

  export type $ApprovedStudyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovedStudy"
    objects: {
      Concierge: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ORCID: string | null
      PI: string | null
      controlledAccess: boolean
      dbGaPID: string | null
      openAccess: boolean | null
      originalOrg: string | null
      primaryContactID: string | null
      programName: string | null
      studyAbbreviation: string
      studyName: string
      useProgramPC: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["approvedStudy"]>
    composites: {}
  }

  type ApprovedStudyGetPayload<S extends boolean | null | undefined | ApprovedStudyDefaultArgs> = $Result.GetResult<Prisma.$ApprovedStudyPayload, S>

  type ApprovedStudyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApprovedStudyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApprovedStudyCountAggregateInputType | true
    }

  export interface ApprovedStudyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovedStudy'], meta: { name: 'ApprovedStudy' } }
    /**
     * Find zero or one ApprovedStudy that matches the filter.
     * @param {ApprovedStudyFindUniqueArgs} args - Arguments to find a ApprovedStudy
     * @example
     * // Get one ApprovedStudy
     * const approvedStudy = await prisma.approvedStudy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovedStudyFindUniqueArgs>(args: SelectSubset<T, ApprovedStudyFindUniqueArgs<ExtArgs>>): Prisma__ApprovedStudyClient<$Result.GetResult<Prisma.$ApprovedStudyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApprovedStudy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApprovedStudyFindUniqueOrThrowArgs} args - Arguments to find a ApprovedStudy
     * @example
     * // Get one ApprovedStudy
     * const approvedStudy = await prisma.approvedStudy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovedStudyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovedStudyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovedStudyClient<$Result.GetResult<Prisma.$ApprovedStudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovedStudy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovedStudyFindFirstArgs} args - Arguments to find a ApprovedStudy
     * @example
     * // Get one ApprovedStudy
     * const approvedStudy = await prisma.approvedStudy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovedStudyFindFirstArgs>(args?: SelectSubset<T, ApprovedStudyFindFirstArgs<ExtArgs>>): Prisma__ApprovedStudyClient<$Result.GetResult<Prisma.$ApprovedStudyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovedStudy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovedStudyFindFirstOrThrowArgs} args - Arguments to find a ApprovedStudy
     * @example
     * // Get one ApprovedStudy
     * const approvedStudy = await prisma.approvedStudy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovedStudyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovedStudyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovedStudyClient<$Result.GetResult<Prisma.$ApprovedStudyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApprovedStudies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovedStudyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovedStudies
     * const approvedStudies = await prisma.approvedStudy.findMany()
     * 
     * // Get first 10 ApprovedStudies
     * const approvedStudies = await prisma.approvedStudy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvedStudyWithIdOnly = await prisma.approvedStudy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovedStudyFindManyArgs>(args?: SelectSubset<T, ApprovedStudyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovedStudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApprovedStudy.
     * @param {ApprovedStudyCreateArgs} args - Arguments to create a ApprovedStudy.
     * @example
     * // Create one ApprovedStudy
     * const ApprovedStudy = await prisma.approvedStudy.create({
     *   data: {
     *     // ... data to create a ApprovedStudy
     *   }
     * })
     * 
     */
    create<T extends ApprovedStudyCreateArgs>(args: SelectSubset<T, ApprovedStudyCreateArgs<ExtArgs>>): Prisma__ApprovedStudyClient<$Result.GetResult<Prisma.$ApprovedStudyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApprovedStudies.
     * @param {ApprovedStudyCreateManyArgs} args - Arguments to create many ApprovedStudies.
     * @example
     * // Create many ApprovedStudies
     * const approvedStudy = await prisma.approvedStudy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovedStudyCreateManyArgs>(args?: SelectSubset<T, ApprovedStudyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ApprovedStudy.
     * @param {ApprovedStudyDeleteArgs} args - Arguments to delete one ApprovedStudy.
     * @example
     * // Delete one ApprovedStudy
     * const ApprovedStudy = await prisma.approvedStudy.delete({
     *   where: {
     *     // ... filter to delete one ApprovedStudy
     *   }
     * })
     * 
     */
    delete<T extends ApprovedStudyDeleteArgs>(args: SelectSubset<T, ApprovedStudyDeleteArgs<ExtArgs>>): Prisma__ApprovedStudyClient<$Result.GetResult<Prisma.$ApprovedStudyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApprovedStudy.
     * @param {ApprovedStudyUpdateArgs} args - Arguments to update one ApprovedStudy.
     * @example
     * // Update one ApprovedStudy
     * const approvedStudy = await prisma.approvedStudy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovedStudyUpdateArgs>(args: SelectSubset<T, ApprovedStudyUpdateArgs<ExtArgs>>): Prisma__ApprovedStudyClient<$Result.GetResult<Prisma.$ApprovedStudyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApprovedStudies.
     * @param {ApprovedStudyDeleteManyArgs} args - Arguments to filter ApprovedStudies to delete.
     * @example
     * // Delete a few ApprovedStudies
     * const { count } = await prisma.approvedStudy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovedStudyDeleteManyArgs>(args?: SelectSubset<T, ApprovedStudyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovedStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovedStudyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovedStudies
     * const approvedStudy = await prisma.approvedStudy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovedStudyUpdateManyArgs>(args: SelectSubset<T, ApprovedStudyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApprovedStudy.
     * @param {ApprovedStudyUpsertArgs} args - Arguments to update or create a ApprovedStudy.
     * @example
     * // Update or create a ApprovedStudy
     * const approvedStudy = await prisma.approvedStudy.upsert({
     *   create: {
     *     // ... data to create a ApprovedStudy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovedStudy we want to update
     *   }
     * })
     */
    upsert<T extends ApprovedStudyUpsertArgs>(args: SelectSubset<T, ApprovedStudyUpsertArgs<ExtArgs>>): Prisma__ApprovedStudyClient<$Result.GetResult<Prisma.$ApprovedStudyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApprovedStudies that matches the filter.
     * @param {ApprovedStudyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const approvedStudy = await prisma.approvedStudy.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ApprovedStudyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ApprovedStudy.
     * @param {ApprovedStudyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const approvedStudy = await prisma.approvedStudy.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ApprovedStudyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ApprovedStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovedStudyCountArgs} args - Arguments to filter ApprovedStudies to count.
     * @example
     * // Count the number of ApprovedStudies
     * const count = await prisma.approvedStudy.count({
     *   where: {
     *     // ... the filter for the ApprovedStudies we want to count
     *   }
     * })
    **/
    count<T extends ApprovedStudyCountArgs>(
      args?: Subset<T, ApprovedStudyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovedStudyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovedStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovedStudyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovedStudyAggregateArgs>(args: Subset<T, ApprovedStudyAggregateArgs>): Prisma.PrismaPromise<GetApprovedStudyAggregateType<T>>

    /**
     * Group by ApprovedStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovedStudyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovedStudyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovedStudyGroupByArgs['orderBy'] }
        : { orderBy?: ApprovedStudyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovedStudyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovedStudyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovedStudy model
   */
  readonly fields: ApprovedStudyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovedStudy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovedStudyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Concierge<T extends ApprovedStudy$ConciergeArgs<ExtArgs> = {}>(args?: Subset<T, ApprovedStudy$ConciergeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovedStudy model
   */
  interface ApprovedStudyFieldRefs {
    readonly id: FieldRef<"ApprovedStudy", 'String'>
    readonly ORCID: FieldRef<"ApprovedStudy", 'String'>
    readonly PI: FieldRef<"ApprovedStudy", 'String'>
    readonly controlledAccess: FieldRef<"ApprovedStudy", 'Boolean'>
    readonly dbGaPID: FieldRef<"ApprovedStudy", 'String'>
    readonly openAccess: FieldRef<"ApprovedStudy", 'Boolean'>
    readonly originalOrg: FieldRef<"ApprovedStudy", 'String'>
    readonly primaryContactID: FieldRef<"ApprovedStudy", 'String'>
    readonly programName: FieldRef<"ApprovedStudy", 'String'>
    readonly studyAbbreviation: FieldRef<"ApprovedStudy", 'String'>
    readonly studyName: FieldRef<"ApprovedStudy", 'String'>
    readonly useProgramPC: FieldRef<"ApprovedStudy", 'Boolean'>
    readonly createdAt: FieldRef<"ApprovedStudy", 'DateTime'>
    readonly updatedAt: FieldRef<"ApprovedStudy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovedStudy findUnique
   */
  export type ApprovedStudyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovedStudy
     */
    select?: ApprovedStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovedStudy
     */
    omit?: ApprovedStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovedStudyInclude<ExtArgs> | null
    /**
     * Filter, which ApprovedStudy to fetch.
     */
    where: ApprovedStudyWhereUniqueInput
  }

  /**
   * ApprovedStudy findUniqueOrThrow
   */
  export type ApprovedStudyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovedStudy
     */
    select?: ApprovedStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovedStudy
     */
    omit?: ApprovedStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovedStudyInclude<ExtArgs> | null
    /**
     * Filter, which ApprovedStudy to fetch.
     */
    where: ApprovedStudyWhereUniqueInput
  }

  /**
   * ApprovedStudy findFirst
   */
  export type ApprovedStudyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovedStudy
     */
    select?: ApprovedStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovedStudy
     */
    omit?: ApprovedStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovedStudyInclude<ExtArgs> | null
    /**
     * Filter, which ApprovedStudy to fetch.
     */
    where?: ApprovedStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovedStudies to fetch.
     */
    orderBy?: ApprovedStudyOrderByWithRelationInput | ApprovedStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovedStudies.
     */
    cursor?: ApprovedStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovedStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovedStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovedStudies.
     */
    distinct?: ApprovedStudyScalarFieldEnum | ApprovedStudyScalarFieldEnum[]
  }

  /**
   * ApprovedStudy findFirstOrThrow
   */
  export type ApprovedStudyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovedStudy
     */
    select?: ApprovedStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovedStudy
     */
    omit?: ApprovedStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovedStudyInclude<ExtArgs> | null
    /**
     * Filter, which ApprovedStudy to fetch.
     */
    where?: ApprovedStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovedStudies to fetch.
     */
    orderBy?: ApprovedStudyOrderByWithRelationInput | ApprovedStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovedStudies.
     */
    cursor?: ApprovedStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovedStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovedStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovedStudies.
     */
    distinct?: ApprovedStudyScalarFieldEnum | ApprovedStudyScalarFieldEnum[]
  }

  /**
   * ApprovedStudy findMany
   */
  export type ApprovedStudyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovedStudy
     */
    select?: ApprovedStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovedStudy
     */
    omit?: ApprovedStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovedStudyInclude<ExtArgs> | null
    /**
     * Filter, which ApprovedStudies to fetch.
     */
    where?: ApprovedStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovedStudies to fetch.
     */
    orderBy?: ApprovedStudyOrderByWithRelationInput | ApprovedStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovedStudies.
     */
    cursor?: ApprovedStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovedStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovedStudies.
     */
    skip?: number
    distinct?: ApprovedStudyScalarFieldEnum | ApprovedStudyScalarFieldEnum[]
  }

  /**
   * ApprovedStudy create
   */
  export type ApprovedStudyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovedStudy
     */
    select?: ApprovedStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovedStudy
     */
    omit?: ApprovedStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovedStudyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovedStudy.
     */
    data: XOR<ApprovedStudyCreateInput, ApprovedStudyUncheckedCreateInput>
  }

  /**
   * ApprovedStudy createMany
   */
  export type ApprovedStudyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovedStudies.
     */
    data: ApprovedStudyCreateManyInput | ApprovedStudyCreateManyInput[]
  }

  /**
   * ApprovedStudy update
   */
  export type ApprovedStudyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovedStudy
     */
    select?: ApprovedStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovedStudy
     */
    omit?: ApprovedStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovedStudyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovedStudy.
     */
    data: XOR<ApprovedStudyUpdateInput, ApprovedStudyUncheckedUpdateInput>
    /**
     * Choose, which ApprovedStudy to update.
     */
    where: ApprovedStudyWhereUniqueInput
  }

  /**
   * ApprovedStudy updateMany
   */
  export type ApprovedStudyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovedStudies.
     */
    data: XOR<ApprovedStudyUpdateManyMutationInput, ApprovedStudyUncheckedUpdateManyInput>
    /**
     * Filter which ApprovedStudies to update
     */
    where?: ApprovedStudyWhereInput
    /**
     * Limit how many ApprovedStudies to update.
     */
    limit?: number
  }

  /**
   * ApprovedStudy upsert
   */
  export type ApprovedStudyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovedStudy
     */
    select?: ApprovedStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovedStudy
     */
    omit?: ApprovedStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovedStudyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovedStudy to update in case it exists.
     */
    where: ApprovedStudyWhereUniqueInput
    /**
     * In case the ApprovedStudy found by the `where` argument doesn't exist, create a new ApprovedStudy with this data.
     */
    create: XOR<ApprovedStudyCreateInput, ApprovedStudyUncheckedCreateInput>
    /**
     * In case the ApprovedStudy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovedStudyUpdateInput, ApprovedStudyUncheckedUpdateInput>
  }

  /**
   * ApprovedStudy delete
   */
  export type ApprovedStudyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovedStudy
     */
    select?: ApprovedStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovedStudy
     */
    omit?: ApprovedStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovedStudyInclude<ExtArgs> | null
    /**
     * Filter which ApprovedStudy to delete.
     */
    where: ApprovedStudyWhereUniqueInput
  }

  /**
   * ApprovedStudy deleteMany
   */
  export type ApprovedStudyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovedStudies to delete
     */
    where?: ApprovedStudyWhereInput
    /**
     * Limit how many ApprovedStudies to delete.
     */
    limit?: number
  }

  /**
   * ApprovedStudy findRaw
   */
  export type ApprovedStudyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ApprovedStudy aggregateRaw
   */
  export type ApprovedStudyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ApprovedStudy.Concierge
   */
  export type ApprovedStudy$ConciergeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ApprovedStudy without action
   */
  export type ApprovedStudyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovedStudy
     */
    select?: ApprovedStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovedStudy
     */
    omit?: ApprovedStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovedStudyInclude<ExtArgs> | null
  }


  /**
   * Model Batch
   */

  export type AggregateBatch = {
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  export type BatchAvgAggregateOutputType = {
    displayID: number | null
    fileCount: number | null
  }

  export type BatchSumAggregateOutputType = {
    displayID: number | null
    fileCount: number | null
  }

  export type BatchMinAggregateOutputType = {
    id: string | null
    bucketName: string | null
    displayID: number | null
    fileCount: number | null
    filePrefix: string | null
    status: string | null
    submissionID: string | null
    submitterID: string | null
    submitterName: string | null
    type: string | null
    zipFileName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchMaxAggregateOutputType = {
    id: string | null
    bucketName: string | null
    displayID: number | null
    fileCount: number | null
    filePrefix: string | null
    status: string | null
    submissionID: string | null
    submitterID: string | null
    submitterName: string | null
    type: string | null
    zipFileName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchCountAggregateOutputType = {
    id: number
    bucketName: number
    displayID: number
    errors: number
    fileCount: number
    filePrefix: number
    status: number
    submissionID: number
    submitterID: number
    submitterName: number
    type: number
    zipFileName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchAvgAggregateInputType = {
    displayID?: true
    fileCount?: true
  }

  export type BatchSumAggregateInputType = {
    displayID?: true
    fileCount?: true
  }

  export type BatchMinAggregateInputType = {
    id?: true
    bucketName?: true
    displayID?: true
    fileCount?: true
    filePrefix?: true
    status?: true
    submissionID?: true
    submitterID?: true
    submitterName?: true
    type?: true
    zipFileName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchMaxAggregateInputType = {
    id?: true
    bucketName?: true
    displayID?: true
    fileCount?: true
    filePrefix?: true
    status?: true
    submissionID?: true
    submitterID?: true
    submitterName?: true
    type?: true
    zipFileName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchCountAggregateInputType = {
    id?: true
    bucketName?: true
    displayID?: true
    errors?: true
    fileCount?: true
    filePrefix?: true
    status?: true
    submissionID?: true
    submitterID?: true
    submitterName?: true
    type?: true
    zipFileName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batch to aggregate.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Batches
    **/
    _count?: true | BatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchMaxAggregateInputType
  }

  export type GetBatchAggregateType<T extends BatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatch[P]>
      : GetScalarType<T[P], AggregateBatch[P]>
  }




  export type BatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithAggregationInput | BatchOrderByWithAggregationInput[]
    by: BatchScalarFieldEnum[] | BatchScalarFieldEnum
    having?: BatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchCountAggregateInputType | true
    _avg?: BatchAvgAggregateInputType
    _sum?: BatchSumAggregateInputType
    _min?: BatchMinAggregateInputType
    _max?: BatchMaxAggregateInputType
  }

  export type BatchGroupByOutputType = {
    id: string
    bucketName: string
    displayID: number
    errors: string[]
    fileCount: number
    filePrefix: string
    status: string
    submissionID: string
    submitterID: string | null
    submitterName: string | null
    type: string
    zipFileName: string | null
    createdAt: Date
    updatedAt: Date
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  type GetBatchGroupByPayload<T extends BatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchGroupByOutputType[P]>
            : GetScalarType<T[P], BatchGroupByOutputType[P]>
        }
      >
    >


  export type BatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bucketName?: boolean
    displayID?: boolean
    errors?: boolean
    fileCount?: boolean
    filePrefix?: boolean
    files?: boolean | BatchFilesDefaultArgs<ExtArgs>
    status?: boolean
    submissionID?: boolean
    submitterID?: boolean
    submitterName?: boolean
    type?: boolean
    zipFileName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submission?: boolean | SubmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>



  export type BatchSelectScalar = {
    id?: boolean
    bucketName?: boolean
    displayID?: boolean
    errors?: boolean
    fileCount?: boolean
    filePrefix?: boolean
    status?: boolean
    submissionID?: boolean
    submitterID?: boolean
    submitterName?: boolean
    type?: boolean
    zipFileName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bucketName" | "displayID" | "errors" | "fileCount" | "filePrefix" | "files" | "status" | "submissionID" | "submitterID" | "submitterName" | "type" | "zipFileName" | "createdAt" | "updatedAt", ExtArgs["result"]["batch"]>
  export type BatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | SubmissionDefaultArgs<ExtArgs>
  }

  export type $BatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Batch"
    objects: {
      submission: Prisma.$SubmissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bucketName: string
      displayID: number
      errors: string[]
      fileCount: number
      filePrefix: string
      status: string
      submissionID: string
      submitterID: string | null
      submitterName: string | null
      type: string
      zipFileName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batch"]>
    composites: {
      files: Prisma.$BatchFilesPayload[]
    }
  }

  type BatchGetPayload<S extends boolean | null | undefined | BatchDefaultArgs> = $Result.GetResult<Prisma.$BatchPayload, S>

  type BatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchCountAggregateInputType | true
    }

  export interface BatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Batch'], meta: { name: 'Batch' } }
    /**
     * Find zero or one Batch that matches the filter.
     * @param {BatchFindUniqueArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchFindUniqueArgs>(args: SelectSubset<T, BatchFindUniqueArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Batch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchFindUniqueOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchFindFirstArgs>(args?: SelectSubset<T, BatchFindFirstArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batches
     * const batches = await prisma.batch.findMany()
     * 
     * // Get first 10 Batches
     * const batches = await prisma.batch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchWithIdOnly = await prisma.batch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchFindManyArgs>(args?: SelectSubset<T, BatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Batch.
     * @param {BatchCreateArgs} args - Arguments to create a Batch.
     * @example
     * // Create one Batch
     * const Batch = await prisma.batch.create({
     *   data: {
     *     // ... data to create a Batch
     *   }
     * })
     * 
     */
    create<T extends BatchCreateArgs>(args: SelectSubset<T, BatchCreateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Batches.
     * @param {BatchCreateManyArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchCreateManyArgs>(args?: SelectSubset<T, BatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Batch.
     * @param {BatchDeleteArgs} args - Arguments to delete one Batch.
     * @example
     * // Delete one Batch
     * const Batch = await prisma.batch.delete({
     *   where: {
     *     // ... filter to delete one Batch
     *   }
     * })
     * 
     */
    delete<T extends BatchDeleteArgs>(args: SelectSubset<T, BatchDeleteArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Batch.
     * @param {BatchUpdateArgs} args - Arguments to update one Batch.
     * @example
     * // Update one Batch
     * const batch = await prisma.batch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchUpdateArgs>(args: SelectSubset<T, BatchUpdateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Batches.
     * @param {BatchDeleteManyArgs} args - Arguments to filter Batches to delete.
     * @example
     * // Delete a few Batches
     * const { count } = await prisma.batch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchDeleteManyArgs>(args?: SelectSubset<T, BatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchUpdateManyArgs>(args: SelectSubset<T, BatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Batch.
     * @param {BatchUpsertArgs} args - Arguments to update or create a Batch.
     * @example
     * // Update or create a Batch
     * const batch = await prisma.batch.upsert({
     *   create: {
     *     // ... data to create a Batch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batch we want to update
     *   }
     * })
     */
    upsert<T extends BatchUpsertArgs>(args: SelectSubset<T, BatchUpsertArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batches that matches the filter.
     * @param {BatchFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const batch = await prisma.batch.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BatchFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Batch.
     * @param {BatchAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const batch = await prisma.batch.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BatchAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCountArgs} args - Arguments to filter Batches to count.
     * @example
     * // Count the number of Batches
     * const count = await prisma.batch.count({
     *   where: {
     *     // ... the filter for the Batches we want to count
     *   }
     * })
    **/
    count<T extends BatchCountArgs>(
      args?: Subset<T, BatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAggregateArgs>(args: Subset<T, BatchAggregateArgs>): Prisma.PrismaPromise<GetBatchAggregateType<T>>

    /**
     * Group by Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchGroupByArgs['orderBy'] }
        : { orderBy?: BatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Batch model
   */
  readonly fields: BatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Batch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submission<T extends SubmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubmissionDefaultArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Batch model
   */
  interface BatchFieldRefs {
    readonly id: FieldRef<"Batch", 'String'>
    readonly bucketName: FieldRef<"Batch", 'String'>
    readonly displayID: FieldRef<"Batch", 'Int'>
    readonly errors: FieldRef<"Batch", 'String[]'>
    readonly fileCount: FieldRef<"Batch", 'Int'>
    readonly filePrefix: FieldRef<"Batch", 'String'>
    readonly status: FieldRef<"Batch", 'String'>
    readonly submissionID: FieldRef<"Batch", 'String'>
    readonly submitterID: FieldRef<"Batch", 'String'>
    readonly submitterName: FieldRef<"Batch", 'String'>
    readonly type: FieldRef<"Batch", 'String'>
    readonly zipFileName: FieldRef<"Batch", 'String'>
    readonly createdAt: FieldRef<"Batch", 'DateTime'>
    readonly updatedAt: FieldRef<"Batch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Batch findUnique
   */
  export type BatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findUniqueOrThrow
   */
  export type BatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findFirst
   */
  export type BatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findFirstOrThrow
   */
  export type BatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findMany
   */
  export type BatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batches to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch create
   */
  export type BatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Batch.
     */
    data: XOR<BatchCreateInput, BatchUncheckedCreateInput>
  }

  /**
   * Batch createMany
   */
  export type BatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
  }

  /**
   * Batch update
   */
  export type BatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Batch.
     */
    data: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
    /**
     * Choose, which Batch to update.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch updateMany
   */
  export type BatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
  }

  /**
   * Batch upsert
   */
  export type BatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Batch to update in case it exists.
     */
    where: BatchWhereUniqueInput
    /**
     * In case the Batch found by the `where` argument doesn't exist, create a new Batch with this data.
     */
    create: XOR<BatchCreateInput, BatchUncheckedCreateInput>
    /**
     * In case the Batch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
  }

  /**
   * Batch delete
   */
  export type BatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter which Batch to delete.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch deleteMany
   */
  export type BatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batches to delete
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to delete.
     */
    limit?: number
  }

  /**
   * Batch findRaw
   */
  export type BatchFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Batch aggregateRaw
   */
  export type BatchAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Batch without action
   */
  export type BatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
  }


  /**
   * Model Configuration
   */

  export type AggregateConfiguration = {
    _count: ConfigurationCountAggregateOutputType | null
    _avg: ConfigurationAvgAggregateOutputType | null
    _sum: ConfigurationSumAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  export type ConfigurationAvgAggregateOutputType = {
    COMPLETED_RETENTION_DAYS: number | null
    DASHBOARD_SESSION_TIMEOUT: number | null
    INACTIVE_APPLICATION_DAYS: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE: number | null
    INACTIVE_USER_DAYS: number | null
    PRESIGN_EXPIRATION: number | null
    REMIND_APPLICATION_DAYS: number | null
    ROLE_TIMEOUT: number | null
    age: number | null
    days: number | null
    interval: number | null
    timeout: number | null
  }

  export type ConfigurationSumAggregateOutputType = {
    COMPLETED_RETENTION_DAYS: number | null
    DASHBOARD_SESSION_TIMEOUT: number | null
    INACTIVE_APPLICATION_DAYS: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE: number | null
    INACTIVE_USER_DAYS: number | null
    PRESIGN_EXPIRATION: number | null
    REMIND_APPLICATION_DAYS: number | null
    ROLE_TIMEOUT: number | null
    age: number | null
    days: number | null
    interval: number | null
    timeout: number | null
  }

  export type ConfigurationMinAggregateOutputType = {
    id: string | null
    COMPLETED_RETENTION_DAYS: number | null
    DASHBOARD_SESSION_TIMEOUT: number | null
    EMAIL_URL: string | null
    INACTIVE_APPLICATION_DAYS: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE: number | null
    INACTIVE_USER_DAYS: number | null
    OFFICIAL_EMAIL: string | null
    PRESIGN_EXPIRATION: number | null
    PROD_URL: string | null
    REMIND_APPLICATION_DAYS: number | null
    ROLE_TIMEOUT: number | null
    SCHEDULED_JOBS: string | null
    SUBMISSION_BUCKET: string | null
    SUBMISSION_HELPDESK: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL: string | null
    SUBMISSION_SYSTEM_PORTAL: string | null
    TECH_SUPPORT_EMAIL: string | null
    age: number | null
    bucketName: string | null
    current: string | null
    current_version: string | null
    dashboardID: string | null
    dataCommons: string | null
    days: number | null
    interval: number | null
    new: string | null
    prefix: string | null
    timeout: number | null
    type: string | null
    version: string | null
  }

  export type ConfigurationMaxAggregateOutputType = {
    id: string | null
    COMPLETED_RETENTION_DAYS: number | null
    DASHBOARD_SESSION_TIMEOUT: number | null
    EMAIL_URL: string | null
    INACTIVE_APPLICATION_DAYS: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE: number | null
    INACTIVE_USER_DAYS: number | null
    OFFICIAL_EMAIL: string | null
    PRESIGN_EXPIRATION: number | null
    PROD_URL: string | null
    REMIND_APPLICATION_DAYS: number | null
    ROLE_TIMEOUT: number | null
    SCHEDULED_JOBS: string | null
    SUBMISSION_BUCKET: string | null
    SUBMISSION_HELPDESK: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL: string | null
    SUBMISSION_SYSTEM_PORTAL: string | null
    TECH_SUPPORT_EMAIL: string | null
    age: number | null
    bucketName: string | null
    current: string | null
    current_version: string | null
    dashboardID: string | null
    dataCommons: string | null
    days: number | null
    interval: number | null
    new: string | null
    prefix: string | null
    timeout: number | null
    type: string | null
    version: string | null
  }

  export type ConfigurationCountAggregateOutputType = {
    id: number
    COMPLETED_RETENTION_DAYS: number
    DASHBOARD_SESSION_TIMEOUT: number
    EMAIL_URL: number
    INACTIVE_APPLICATION_DAYS: number
    INACTIVE_SUBMISSION_DAYS_DELETE: number
    INACTIVE_USER_DAYS: number
    OFFICIAL_EMAIL: number
    PRESIGN_EXPIRATION: number
    PROD_URL: number
    REMIND_APPLICATION_DAYS: number
    REVIEW_COMMITTEE_EMAIL: number
    ROLE_TIMEOUT: number
    SCHEDULED_JOBS: number
    SUBMISSION_BUCKET: number
    SUBMISSION_HELPDESK: number
    SUBMISSION_REQUEST_CONTACT_EMAIL: number
    SUBMISSION_SYSTEM_PORTAL: number
    TECH_SUPPORT_EMAIL: number
    age: number
    bucketName: number
    current: number
    current_version: number
    dashboardID: number
    dataCommons: number
    days: number
    interval: number
    key: number
    keys: number
    new: number
    prefix: number
    timeout: number
    type: number
    version: number
    _all: number
  }


  export type ConfigurationAvgAggregateInputType = {
    COMPLETED_RETENTION_DAYS?: true
    DASHBOARD_SESSION_TIMEOUT?: true
    INACTIVE_APPLICATION_DAYS?: true
    INACTIVE_SUBMISSION_DAYS_DELETE?: true
    INACTIVE_USER_DAYS?: true
    PRESIGN_EXPIRATION?: true
    REMIND_APPLICATION_DAYS?: true
    ROLE_TIMEOUT?: true
    age?: true
    days?: true
    interval?: true
    timeout?: true
  }

  export type ConfigurationSumAggregateInputType = {
    COMPLETED_RETENTION_DAYS?: true
    DASHBOARD_SESSION_TIMEOUT?: true
    INACTIVE_APPLICATION_DAYS?: true
    INACTIVE_SUBMISSION_DAYS_DELETE?: true
    INACTIVE_USER_DAYS?: true
    PRESIGN_EXPIRATION?: true
    REMIND_APPLICATION_DAYS?: true
    ROLE_TIMEOUT?: true
    age?: true
    days?: true
    interval?: true
    timeout?: true
  }

  export type ConfigurationMinAggregateInputType = {
    id?: true
    COMPLETED_RETENTION_DAYS?: true
    DASHBOARD_SESSION_TIMEOUT?: true
    EMAIL_URL?: true
    INACTIVE_APPLICATION_DAYS?: true
    INACTIVE_SUBMISSION_DAYS_DELETE?: true
    INACTIVE_USER_DAYS?: true
    OFFICIAL_EMAIL?: true
    PRESIGN_EXPIRATION?: true
    PROD_URL?: true
    REMIND_APPLICATION_DAYS?: true
    ROLE_TIMEOUT?: true
    SCHEDULED_JOBS?: true
    SUBMISSION_BUCKET?: true
    SUBMISSION_HELPDESK?: true
    SUBMISSION_REQUEST_CONTACT_EMAIL?: true
    SUBMISSION_SYSTEM_PORTAL?: true
    TECH_SUPPORT_EMAIL?: true
    age?: true
    bucketName?: true
    current?: true
    current_version?: true
    dashboardID?: true
    dataCommons?: true
    days?: true
    interval?: true
    new?: true
    prefix?: true
    timeout?: true
    type?: true
    version?: true
  }

  export type ConfigurationMaxAggregateInputType = {
    id?: true
    COMPLETED_RETENTION_DAYS?: true
    DASHBOARD_SESSION_TIMEOUT?: true
    EMAIL_URL?: true
    INACTIVE_APPLICATION_DAYS?: true
    INACTIVE_SUBMISSION_DAYS_DELETE?: true
    INACTIVE_USER_DAYS?: true
    OFFICIAL_EMAIL?: true
    PRESIGN_EXPIRATION?: true
    PROD_URL?: true
    REMIND_APPLICATION_DAYS?: true
    ROLE_TIMEOUT?: true
    SCHEDULED_JOBS?: true
    SUBMISSION_BUCKET?: true
    SUBMISSION_HELPDESK?: true
    SUBMISSION_REQUEST_CONTACT_EMAIL?: true
    SUBMISSION_SYSTEM_PORTAL?: true
    TECH_SUPPORT_EMAIL?: true
    age?: true
    bucketName?: true
    current?: true
    current_version?: true
    dashboardID?: true
    dataCommons?: true
    days?: true
    interval?: true
    new?: true
    prefix?: true
    timeout?: true
    type?: true
    version?: true
  }

  export type ConfigurationCountAggregateInputType = {
    id?: true
    COMPLETED_RETENTION_DAYS?: true
    DASHBOARD_SESSION_TIMEOUT?: true
    EMAIL_URL?: true
    INACTIVE_APPLICATION_DAYS?: true
    INACTIVE_SUBMISSION_DAYS_DELETE?: true
    INACTIVE_USER_DAYS?: true
    OFFICIAL_EMAIL?: true
    PRESIGN_EXPIRATION?: true
    PROD_URL?: true
    REMIND_APPLICATION_DAYS?: true
    REVIEW_COMMITTEE_EMAIL?: true
    ROLE_TIMEOUT?: true
    SCHEDULED_JOBS?: true
    SUBMISSION_BUCKET?: true
    SUBMISSION_HELPDESK?: true
    SUBMISSION_REQUEST_CONTACT_EMAIL?: true
    SUBMISSION_SYSTEM_PORTAL?: true
    TECH_SUPPORT_EMAIL?: true
    age?: true
    bucketName?: true
    current?: true
    current_version?: true
    dashboardID?: true
    dataCommons?: true
    days?: true
    interval?: true
    key?: true
    keys?: true
    new?: true
    prefix?: true
    timeout?: true
    type?: true
    version?: true
    _all?: true
  }

  export type ConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configuration to aggregate.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Configurations
    **/
    _count?: true | ConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigurationMaxAggregateInputType
  }

  export type GetConfigurationAggregateType<T extends ConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguration[P]>
      : GetScalarType<T[P], AggregateConfiguration[P]>
  }




  export type ConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigurationWhereInput
    orderBy?: ConfigurationOrderByWithAggregationInput | ConfigurationOrderByWithAggregationInput[]
    by: ConfigurationScalarFieldEnum[] | ConfigurationScalarFieldEnum
    having?: ConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigurationCountAggregateInputType | true
    _avg?: ConfigurationAvgAggregateInputType
    _sum?: ConfigurationSumAggregateInputType
    _min?: ConfigurationMinAggregateInputType
    _max?: ConfigurationMaxAggregateInputType
  }

  export type ConfigurationGroupByOutputType = {
    id: string
    COMPLETED_RETENTION_DAYS: number | null
    DASHBOARD_SESSION_TIMEOUT: number | null
    EMAIL_URL: string | null
    INACTIVE_APPLICATION_DAYS: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE: number | null
    INACTIVE_USER_DAYS: number | null
    OFFICIAL_EMAIL: string | null
    PRESIGN_EXPIRATION: number | null
    PROD_URL: string | null
    REMIND_APPLICATION_DAYS: number | null
    REVIEW_COMMITTEE_EMAIL: string[]
    ROLE_TIMEOUT: number | null
    SCHEDULED_JOBS: string | null
    SUBMISSION_BUCKET: string | null
    SUBMISSION_HELPDESK: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL: string | null
    SUBMISSION_SYSTEM_PORTAL: string | null
    TECH_SUPPORT_EMAIL: string | null
    age: number | null
    bucketName: string | null
    current: string | null
    current_version: string | null
    dashboardID: string | null
    dataCommons: string | null
    days: number | null
    interval: number | null
    key: string[]
    keys: JsonValue | null
    new: string | null
    prefix: string | null
    timeout: number | null
    type: string
    version: string | null
    _count: ConfigurationCountAggregateOutputType | null
    _avg: ConfigurationAvgAggregateOutputType | null
    _sum: ConfigurationSumAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  type GetConfigurationGroupByPayload<T extends ConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type ConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    COMPLETED_RETENTION_DAYS?: boolean
    DASHBOARD_SESSION_TIMEOUT?: boolean
    Defaults?: boolean | PBACDefaultsDefaultArgs<ExtArgs>
    EMAIL_URL?: boolean
    INACTIVE_APPLICATION_DAYS?: boolean
    INACTIVE_SUBMISSION_DAYS_DELETE?: boolean
    INACTIVE_USER_DAYS?: boolean
    OFFICIAL_EMAIL?: boolean
    PRESIGN_EXPIRATION?: boolean
    PROD_URL?: boolean
    REMIND_APPLICATION_DAYS?: boolean
    REVIEW_COMMITTEE_EMAIL?: boolean
    ROLE_TIMEOUT?: boolean
    SCHEDULED_JOBS?: boolean
    SUBMISSION_BUCKET?: boolean
    SUBMISSION_HELPDESK?: boolean
    SUBMISSION_REQUEST_CONTACT_EMAIL?: boolean
    SUBMISSION_SYSTEM_PORTAL?: boolean
    TECH_SUPPORT_EMAIL?: boolean
    age?: boolean
    bucketName?: boolean
    current?: boolean
    current_version?: boolean
    dashboardID?: boolean
    dataCommons?: boolean
    days?: boolean
    interval?: boolean
    key?: boolean
    keys?: boolean
    new?: boolean
    prefix?: boolean
    tag?: boolean | ConfigurationTagDefaultArgs<ExtArgs>
    timeout?: boolean
    type?: boolean
    version?: boolean
  }, ExtArgs["result"]["configuration"]>



  export type ConfigurationSelectScalar = {
    id?: boolean
    COMPLETED_RETENTION_DAYS?: boolean
    DASHBOARD_SESSION_TIMEOUT?: boolean
    EMAIL_URL?: boolean
    INACTIVE_APPLICATION_DAYS?: boolean
    INACTIVE_SUBMISSION_DAYS_DELETE?: boolean
    INACTIVE_USER_DAYS?: boolean
    OFFICIAL_EMAIL?: boolean
    PRESIGN_EXPIRATION?: boolean
    PROD_URL?: boolean
    REMIND_APPLICATION_DAYS?: boolean
    REVIEW_COMMITTEE_EMAIL?: boolean
    ROLE_TIMEOUT?: boolean
    SCHEDULED_JOBS?: boolean
    SUBMISSION_BUCKET?: boolean
    SUBMISSION_HELPDESK?: boolean
    SUBMISSION_REQUEST_CONTACT_EMAIL?: boolean
    SUBMISSION_SYSTEM_PORTAL?: boolean
    TECH_SUPPORT_EMAIL?: boolean
    age?: boolean
    bucketName?: boolean
    current?: boolean
    current_version?: boolean
    dashboardID?: boolean
    dataCommons?: boolean
    days?: boolean
    interval?: boolean
    key?: boolean
    keys?: boolean
    new?: boolean
    prefix?: boolean
    timeout?: boolean
    type?: boolean
    version?: boolean
  }

  export type ConfigurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "COMPLETED_RETENTION_DAYS" | "DASHBOARD_SESSION_TIMEOUT" | "Defaults" | "EMAIL_URL" | "INACTIVE_APPLICATION_DAYS" | "INACTIVE_SUBMISSION_DAYS_DELETE" | "INACTIVE_USER_DAYS" | "OFFICIAL_EMAIL" | "PRESIGN_EXPIRATION" | "PROD_URL" | "REMIND_APPLICATION_DAYS" | "REVIEW_COMMITTEE_EMAIL" | "ROLE_TIMEOUT" | "SCHEDULED_JOBS" | "SUBMISSION_BUCKET" | "SUBMISSION_HELPDESK" | "SUBMISSION_REQUEST_CONTACT_EMAIL" | "SUBMISSION_SYSTEM_PORTAL" | "TECH_SUPPORT_EMAIL" | "age" | "bucketName" | "current" | "current_version" | "dashboardID" | "dataCommons" | "days" | "interval" | "key" | "keys" | "new" | "prefix" | "tag" | "timeout" | "type" | "version", ExtArgs["result"]["configuration"]>
  export type ConfigurationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Configuration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      COMPLETED_RETENTION_DAYS: number | null
      DASHBOARD_SESSION_TIMEOUT: number | null
      EMAIL_URL: string | null
      INACTIVE_APPLICATION_DAYS: number | null
      INACTIVE_SUBMISSION_DAYS_DELETE: number | null
      INACTIVE_USER_DAYS: number | null
      OFFICIAL_EMAIL: string | null
      PRESIGN_EXPIRATION: number | null
      PROD_URL: string | null
      REMIND_APPLICATION_DAYS: number | null
      REVIEW_COMMITTEE_EMAIL: string[]
      ROLE_TIMEOUT: number | null
      SCHEDULED_JOBS: string | null
      SUBMISSION_BUCKET: string | null
      SUBMISSION_HELPDESK: string | null
      SUBMISSION_REQUEST_CONTACT_EMAIL: string | null
      SUBMISSION_SYSTEM_PORTAL: string | null
      TECH_SUPPORT_EMAIL: string | null
      age: number | null
      bucketName: string | null
      current: string | null
      current_version: string | null
      dashboardID: string | null
      dataCommons: string | null
      days: number | null
      interval: number | null
      key: string[]
      keys: Prisma.JsonValue | null
      new: string | null
      prefix: string | null
      timeout: number | null
      type: string
      version: string | null
    }, ExtArgs["result"]["configuration"]>
    composites: {
      Defaults: Prisma.$PBACDefaultsPayload[]
      tag: Prisma.$ConfigurationTagPayload | null
    }
  }

  type ConfigurationGetPayload<S extends boolean | null | undefined | ConfigurationDefaultArgs> = $Result.GetResult<Prisma.$ConfigurationPayload, S>

  type ConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigurationCountAggregateInputType | true
    }

  export interface ConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Configuration'], meta: { name: 'Configuration' } }
    /**
     * Find zero or one Configuration that matches the filter.
     * @param {ConfigurationFindUniqueArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigurationFindUniqueArgs>(args: SelectSubset<T, ConfigurationFindUniqueArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Configuration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfigurationFindUniqueOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configuration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigurationFindFirstArgs>(args?: SelectSubset<T, ConfigurationFindFirstArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configuration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configurations
     * const configurations = await prisma.configuration.findMany()
     * 
     * // Get first 10 Configurations
     * const configurations = await prisma.configuration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configurationWithIdOnly = await prisma.configuration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigurationFindManyArgs>(args?: SelectSubset<T, ConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Configuration.
     * @param {ConfigurationCreateArgs} args - Arguments to create a Configuration.
     * @example
     * // Create one Configuration
     * const Configuration = await prisma.configuration.create({
     *   data: {
     *     // ... data to create a Configuration
     *   }
     * })
     * 
     */
    create<T extends ConfigurationCreateArgs>(args: SelectSubset<T, ConfigurationCreateArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Configurations.
     * @param {ConfigurationCreateManyArgs} args - Arguments to create many Configurations.
     * @example
     * // Create many Configurations
     * const configuration = await prisma.configuration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigurationCreateManyArgs>(args?: SelectSubset<T, ConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Configuration.
     * @param {ConfigurationDeleteArgs} args - Arguments to delete one Configuration.
     * @example
     * // Delete one Configuration
     * const Configuration = await prisma.configuration.delete({
     *   where: {
     *     // ... filter to delete one Configuration
     *   }
     * })
     * 
     */
    delete<T extends ConfigurationDeleteArgs>(args: SelectSubset<T, ConfigurationDeleteArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Configuration.
     * @param {ConfigurationUpdateArgs} args - Arguments to update one Configuration.
     * @example
     * // Update one Configuration
     * const configuration = await prisma.configuration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigurationUpdateArgs>(args: SelectSubset<T, ConfigurationUpdateArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Configurations.
     * @param {ConfigurationDeleteManyArgs} args - Arguments to filter Configurations to delete.
     * @example
     * // Delete a few Configurations
     * const { count } = await prisma.configuration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigurationDeleteManyArgs>(args?: SelectSubset<T, ConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configurations
     * const configuration = await prisma.configuration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigurationUpdateManyArgs>(args: SelectSubset<T, ConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configuration.
     * @param {ConfigurationUpsertArgs} args - Arguments to update or create a Configuration.
     * @example
     * // Update or create a Configuration
     * const configuration = await prisma.configuration.upsert({
     *   create: {
     *     // ... data to create a Configuration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configuration we want to update
     *   }
     * })
     */
    upsert<T extends ConfigurationUpsertArgs>(args: SelectSubset<T, ConfigurationUpsertArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configurations that matches the filter.
     * @param {ConfigurationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const configuration = await prisma.configuration.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ConfigurationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Configuration.
     * @param {ConfigurationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const configuration = await prisma.configuration.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ConfigurationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationCountArgs} args - Arguments to filter Configurations to count.
     * @example
     * // Count the number of Configurations
     * const count = await prisma.configuration.count({
     *   where: {
     *     // ... the filter for the Configurations we want to count
     *   }
     * })
    **/
    count<T extends ConfigurationCountArgs>(
      args?: Subset<T, ConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigurationAggregateArgs>(args: Subset<T, ConfigurationAggregateArgs>): Prisma.PrismaPromise<GetConfigurationAggregateType<T>>

    /**
     * Group by Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: ConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Configuration model
   */
  readonly fields: ConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Configuration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Configuration model
   */
  interface ConfigurationFieldRefs {
    readonly id: FieldRef<"Configuration", 'String'>
    readonly COMPLETED_RETENTION_DAYS: FieldRef<"Configuration", 'Int'>
    readonly DASHBOARD_SESSION_TIMEOUT: FieldRef<"Configuration", 'Int'>
    readonly EMAIL_URL: FieldRef<"Configuration", 'String'>
    readonly INACTIVE_APPLICATION_DAYS: FieldRef<"Configuration", 'Int'>
    readonly INACTIVE_SUBMISSION_DAYS_DELETE: FieldRef<"Configuration", 'Int'>
    readonly INACTIVE_USER_DAYS: FieldRef<"Configuration", 'Int'>
    readonly OFFICIAL_EMAIL: FieldRef<"Configuration", 'String'>
    readonly PRESIGN_EXPIRATION: FieldRef<"Configuration", 'Int'>
    readonly PROD_URL: FieldRef<"Configuration", 'String'>
    readonly REMIND_APPLICATION_DAYS: FieldRef<"Configuration", 'Int'>
    readonly REVIEW_COMMITTEE_EMAIL: FieldRef<"Configuration", 'String[]'>
    readonly ROLE_TIMEOUT: FieldRef<"Configuration", 'Int'>
    readonly SCHEDULED_JOBS: FieldRef<"Configuration", 'String'>
    readonly SUBMISSION_BUCKET: FieldRef<"Configuration", 'String'>
    readonly SUBMISSION_HELPDESK: FieldRef<"Configuration", 'String'>
    readonly SUBMISSION_REQUEST_CONTACT_EMAIL: FieldRef<"Configuration", 'String'>
    readonly SUBMISSION_SYSTEM_PORTAL: FieldRef<"Configuration", 'String'>
    readonly TECH_SUPPORT_EMAIL: FieldRef<"Configuration", 'String'>
    readonly age: FieldRef<"Configuration", 'Int'>
    readonly bucketName: FieldRef<"Configuration", 'String'>
    readonly current: FieldRef<"Configuration", 'String'>
    readonly current_version: FieldRef<"Configuration", 'String'>
    readonly dashboardID: FieldRef<"Configuration", 'String'>
    readonly dataCommons: FieldRef<"Configuration", 'String'>
    readonly days: FieldRef<"Configuration", 'Int'>
    readonly interval: FieldRef<"Configuration", 'Int'>
    readonly key: FieldRef<"Configuration", 'String[]'>
    readonly keys: FieldRef<"Configuration", 'Json'>
    readonly new: FieldRef<"Configuration", 'String'>
    readonly prefix: FieldRef<"Configuration", 'String'>
    readonly timeout: FieldRef<"Configuration", 'Int'>
    readonly type: FieldRef<"Configuration", 'String'>
    readonly version: FieldRef<"Configuration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Configuration findUnique
   */
  export type ConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration findUniqueOrThrow
   */
  export type ConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration findFirst
   */
  export type ConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration findFirstOrThrow
   */
  export type ConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration findMany
   */
  export type ConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which Configurations to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration create
   */
  export type ConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to create a Configuration.
     */
    data: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
  }

  /**
   * Configuration createMany
   */
  export type ConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Configurations.
     */
    data: ConfigurationCreateManyInput | ConfigurationCreateManyInput[]
  }

  /**
   * Configuration update
   */
  export type ConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to update a Configuration.
     */
    data: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
    /**
     * Choose, which Configuration to update.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration updateMany
   */
  export type ConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Configurations.
     */
    data: XOR<ConfigurationUpdateManyMutationInput, ConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which Configurations to update
     */
    where?: ConfigurationWhereInput
    /**
     * Limit how many Configurations to update.
     */
    limit?: number
  }

  /**
   * Configuration upsert
   */
  export type ConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * The filter to search for the Configuration to update in case it exists.
     */
    where: ConfigurationWhereUniqueInput
    /**
     * In case the Configuration found by the `where` argument doesn't exist, create a new Configuration with this data.
     */
    create: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
    /**
     * In case the Configuration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
  }

  /**
   * Configuration delete
   */
  export type ConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
    /**
     * Filter which Configuration to delete.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration deleteMany
   */
  export type ConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configurations to delete
     */
    where?: ConfigurationWhereInput
    /**
     * Limit how many Configurations to delete.
     */
    limit?: number
  }

  /**
   * Configuration findRaw
   */
  export type ConfigurationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Configuration aggregateRaw
   */
  export type ConfigurationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Configuration without action
   */
  export type ConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigurationInclude<ExtArgs> | null
  }


  /**
   * Model DataRecord
   */

  export type AggregateDataRecord = {
    _count: DataRecordCountAggregateOutputType | null
    _avg: DataRecordAvgAggregateOutputType | null
    _sum: DataRecordSumAggregateOutputType | null
    _min: DataRecordMinAggregateOutputType | null
    _max: DataRecordMaxAggregateOutputType | null
  }

  export type DataRecordAvgAggregateOutputType = {
    latestBatchDisplayID: number | null
    lineNumber: number | null
  }

  export type DataRecordSumAggregateOutputType = {
    latestBatchDisplayID: number | null
    lineNumber: number | null
  }

  export type DataRecordMinAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    IDPropName: string | null
    dataCommons: string | null
    entityType: string | null
    latestBatchDisplayID: number | null
    latestBatchID: string | null
    lineNumber: number | null
    nodeID: string | null
    nodeType: string | null
    orginalFileName: string | null
    qcResultID: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    uploadedDate: Date | null
    validatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataRecordMaxAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    IDPropName: string | null
    dataCommons: string | null
    entityType: string | null
    latestBatchDisplayID: number | null
    latestBatchID: string | null
    lineNumber: number | null
    nodeID: string | null
    nodeType: string | null
    orginalFileName: string | null
    qcResultID: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    uploadedDate: Date | null
    validatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataRecordCountAggregateOutputType = {
    id: number
    CRDC_ID: number
    IDPropName: number
    batchIDs: number
    dataCommons: number
    entityType: number
    latestBatchDisplayID: number
    latestBatchID: number
    lineNumber: number
    nodeID: number
    nodeType: number
    orginalFileName: number
    props: number
    qcResultID: number
    rawData: number
    status: number
    studyID: number
    submissionID: number
    uploadedDate: number
    validatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataRecordAvgAggregateInputType = {
    latestBatchDisplayID?: true
    lineNumber?: true
  }

  export type DataRecordSumAggregateInputType = {
    latestBatchDisplayID?: true
    lineNumber?: true
  }

  export type DataRecordMinAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    qcResultID?: true
    status?: true
    studyID?: true
    submissionID?: true
    uploadedDate?: true
    validatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataRecordMaxAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    qcResultID?: true
    status?: true
    studyID?: true
    submissionID?: true
    uploadedDate?: true
    validatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataRecordCountAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    batchIDs?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    props?: true
    qcResultID?: true
    rawData?: true
    status?: true
    studyID?: true
    submissionID?: true
    uploadedDate?: true
    validatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRecord to aggregate.
     */
    where?: DataRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRecords to fetch.
     */
    orderBy?: DataRecordOrderByWithRelationInput | DataRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataRecords
    **/
    _count?: true | DataRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataRecordMaxAggregateInputType
  }

  export type GetDataRecordAggregateType<T extends DataRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateDataRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataRecord[P]>
      : GetScalarType<T[P], AggregateDataRecord[P]>
  }




  export type DataRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRecordWhereInput
    orderBy?: DataRecordOrderByWithAggregationInput | DataRecordOrderByWithAggregationInput[]
    by: DataRecordScalarFieldEnum[] | DataRecordScalarFieldEnum
    having?: DataRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataRecordCountAggregateInputType | true
    _avg?: DataRecordAvgAggregateInputType
    _sum?: DataRecordSumAggregateInputType
    _min?: DataRecordMinAggregateInputType
    _max?: DataRecordMaxAggregateInputType
  }

  export type DataRecordGroupByOutputType = {
    id: string
    CRDC_ID: string | null
    IDPropName: string
    batchIDs: string[]
    dataCommons: string
    entityType: string | null
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    props: JsonValue
    qcResultID: string | null
    rawData: JsonValue
    status: string
    studyID: string
    submissionID: string
    uploadedDate: Date
    validatedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DataRecordCountAggregateOutputType | null
    _avg: DataRecordAvgAggregateOutputType | null
    _sum: DataRecordSumAggregateOutputType | null
    _min: DataRecordMinAggregateOutputType | null
    _max: DataRecordMaxAggregateOutputType | null
  }

  type GetDataRecordGroupByPayload<T extends DataRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataRecordGroupByOutputType[P]>
            : GetScalarType<T[P], DataRecordGroupByOutputType[P]>
        }
      >
    >


  export type DataRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CRDC_ID?: boolean
    IDPropName?: boolean
    additionalErrors?: boolean | AdditionalErrorDefaultArgs<ExtArgs>
    batchIDs?: boolean
    dataCommons?: boolean
    entityType?: boolean
    errors?: boolean | ErrorDefaultArgs<ExtArgs>
    latestBatchDisplayID?: boolean
    latestBatchID?: boolean
    lineNumber?: boolean
    nodeID?: boolean
    nodeType?: boolean
    orginalFileName?: boolean
    parents?: boolean | ParentDefaultArgs<ExtArgs>
    props?: boolean
    qcResultID?: boolean
    rawData?: boolean
    s3FileInfo?: boolean | S3FileInfoDefaultArgs<ExtArgs>
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    uploadedDate?: boolean
    validatedAt?: boolean
    warnings?: boolean | ErrorDefaultArgs<ExtArgs>
    createdAt?: boolean
    updatedAt?: boolean
    submission?: boolean | SubmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataRecord"]>



  export type DataRecordSelectScalar = {
    id?: boolean
    CRDC_ID?: boolean
    IDPropName?: boolean
    batchIDs?: boolean
    dataCommons?: boolean
    entityType?: boolean
    latestBatchDisplayID?: boolean
    latestBatchID?: boolean
    lineNumber?: boolean
    nodeID?: boolean
    nodeType?: boolean
    orginalFileName?: boolean
    props?: boolean
    qcResultID?: boolean
    rawData?: boolean
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    uploadedDate?: boolean
    validatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "CRDC_ID" | "IDPropName" | "additionalErrors" | "batchIDs" | "dataCommons" | "entityType" | "errors" | "latestBatchDisplayID" | "latestBatchID" | "lineNumber" | "nodeID" | "nodeType" | "orginalFileName" | "parents" | "props" | "qcResultID" | "rawData" | "s3FileInfo" | "status" | "studyID" | "submissionID" | "uploadedDate" | "validatedAt" | "warnings" | "createdAt" | "updatedAt", ExtArgs["result"]["dataRecord"]>
  export type DataRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | SubmissionDefaultArgs<ExtArgs>
  }

  export type $DataRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataRecord"
    objects: {
      submission: Prisma.$SubmissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      CRDC_ID: string | null
      IDPropName: string
      batchIDs: string[]
      dataCommons: string
      entityType: string | null
      latestBatchDisplayID: number
      latestBatchID: string
      lineNumber: number
      nodeID: string
      nodeType: string
      orginalFileName: string
      props: Prisma.JsonValue
      qcResultID: string | null
      rawData: Prisma.JsonValue
      status: string
      studyID: string
      submissionID: string
      uploadedDate: Date
      validatedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataRecord"]>
    composites: {
      additionalErrors: Prisma.$AdditionalErrorPayload[]
      errors: Prisma.$ErrorPayload[]
      parents: Prisma.$ParentPayload[]
      s3FileInfo: Prisma.$S3FileInfoPayload | null
      warnings: Prisma.$ErrorPayload[]
    }
  }

  type DataRecordGetPayload<S extends boolean | null | undefined | DataRecordDefaultArgs> = $Result.GetResult<Prisma.$DataRecordPayload, S>

  type DataRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataRecordCountAggregateInputType | true
    }

  export interface DataRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataRecord'], meta: { name: 'DataRecord' } }
    /**
     * Find zero or one DataRecord that matches the filter.
     * @param {DataRecordFindUniqueArgs} args - Arguments to find a DataRecord
     * @example
     * // Get one DataRecord
     * const dataRecord = await prisma.dataRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataRecordFindUniqueArgs>(args: SelectSubset<T, DataRecordFindUniqueArgs<ExtArgs>>): Prisma__DataRecordClient<$Result.GetResult<Prisma.$DataRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataRecordFindUniqueOrThrowArgs} args - Arguments to find a DataRecord
     * @example
     * // Get one DataRecord
     * const dataRecord = await prisma.dataRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, DataRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataRecordClient<$Result.GetResult<Prisma.$DataRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordFindFirstArgs} args - Arguments to find a DataRecord
     * @example
     * // Get one DataRecord
     * const dataRecord = await prisma.dataRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataRecordFindFirstArgs>(args?: SelectSubset<T, DataRecordFindFirstArgs<ExtArgs>>): Prisma__DataRecordClient<$Result.GetResult<Prisma.$DataRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordFindFirstOrThrowArgs} args - Arguments to find a DataRecord
     * @example
     * // Get one DataRecord
     * const dataRecord = await prisma.dataRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, DataRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataRecordClient<$Result.GetResult<Prisma.$DataRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataRecords
     * const dataRecords = await prisma.dataRecord.findMany()
     * 
     * // Get first 10 DataRecords
     * const dataRecords = await prisma.dataRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataRecordWithIdOnly = await prisma.dataRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataRecordFindManyArgs>(args?: SelectSubset<T, DataRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataRecord.
     * @param {DataRecordCreateArgs} args - Arguments to create a DataRecord.
     * @example
     * // Create one DataRecord
     * const DataRecord = await prisma.dataRecord.create({
     *   data: {
     *     // ... data to create a DataRecord
     *   }
     * })
     * 
     */
    create<T extends DataRecordCreateArgs>(args: SelectSubset<T, DataRecordCreateArgs<ExtArgs>>): Prisma__DataRecordClient<$Result.GetResult<Prisma.$DataRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataRecords.
     * @param {DataRecordCreateManyArgs} args - Arguments to create many DataRecords.
     * @example
     * // Create many DataRecords
     * const dataRecord = await prisma.dataRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataRecordCreateManyArgs>(args?: SelectSubset<T, DataRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataRecord.
     * @param {DataRecordDeleteArgs} args - Arguments to delete one DataRecord.
     * @example
     * // Delete one DataRecord
     * const DataRecord = await prisma.dataRecord.delete({
     *   where: {
     *     // ... filter to delete one DataRecord
     *   }
     * })
     * 
     */
    delete<T extends DataRecordDeleteArgs>(args: SelectSubset<T, DataRecordDeleteArgs<ExtArgs>>): Prisma__DataRecordClient<$Result.GetResult<Prisma.$DataRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataRecord.
     * @param {DataRecordUpdateArgs} args - Arguments to update one DataRecord.
     * @example
     * // Update one DataRecord
     * const dataRecord = await prisma.dataRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataRecordUpdateArgs>(args: SelectSubset<T, DataRecordUpdateArgs<ExtArgs>>): Prisma__DataRecordClient<$Result.GetResult<Prisma.$DataRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataRecords.
     * @param {DataRecordDeleteManyArgs} args - Arguments to filter DataRecords to delete.
     * @example
     * // Delete a few DataRecords
     * const { count } = await prisma.dataRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataRecordDeleteManyArgs>(args?: SelectSubset<T, DataRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataRecords
     * const dataRecord = await prisma.dataRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataRecordUpdateManyArgs>(args: SelectSubset<T, DataRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataRecord.
     * @param {DataRecordUpsertArgs} args - Arguments to update or create a DataRecord.
     * @example
     * // Update or create a DataRecord
     * const dataRecord = await prisma.dataRecord.upsert({
     *   create: {
     *     // ... data to create a DataRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataRecord we want to update
     *   }
     * })
     */
    upsert<T extends DataRecordUpsertArgs>(args: SelectSubset<T, DataRecordUpsertArgs<ExtArgs>>): Prisma__DataRecordClient<$Result.GetResult<Prisma.$DataRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataRecords that matches the filter.
     * @param {DataRecordFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dataRecord = await prisma.dataRecord.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DataRecordFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DataRecord.
     * @param {DataRecordAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dataRecord = await prisma.dataRecord.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DataRecordAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DataRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordCountArgs} args - Arguments to filter DataRecords to count.
     * @example
     * // Count the number of DataRecords
     * const count = await prisma.dataRecord.count({
     *   where: {
     *     // ... the filter for the DataRecords we want to count
     *   }
     * })
    **/
    count<T extends DataRecordCountArgs>(
      args?: Subset<T, DataRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataRecordAggregateArgs>(args: Subset<T, DataRecordAggregateArgs>): Prisma.PrismaPromise<GetDataRecordAggregateType<T>>

    /**
     * Group by DataRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataRecordGroupByArgs['orderBy'] }
        : { orderBy?: DataRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataRecord model
   */
  readonly fields: DataRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submission<T extends SubmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubmissionDefaultArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataRecord model
   */
  interface DataRecordFieldRefs {
    readonly id: FieldRef<"DataRecord", 'String'>
    readonly CRDC_ID: FieldRef<"DataRecord", 'String'>
    readonly IDPropName: FieldRef<"DataRecord", 'String'>
    readonly batchIDs: FieldRef<"DataRecord", 'String[]'>
    readonly dataCommons: FieldRef<"DataRecord", 'String'>
    readonly entityType: FieldRef<"DataRecord", 'String'>
    readonly latestBatchDisplayID: FieldRef<"DataRecord", 'Int'>
    readonly latestBatchID: FieldRef<"DataRecord", 'String'>
    readonly lineNumber: FieldRef<"DataRecord", 'Int'>
    readonly nodeID: FieldRef<"DataRecord", 'String'>
    readonly nodeType: FieldRef<"DataRecord", 'String'>
    readonly orginalFileName: FieldRef<"DataRecord", 'String'>
    readonly props: FieldRef<"DataRecord", 'Json'>
    readonly qcResultID: FieldRef<"DataRecord", 'String'>
    readonly rawData: FieldRef<"DataRecord", 'Json'>
    readonly status: FieldRef<"DataRecord", 'String'>
    readonly studyID: FieldRef<"DataRecord", 'String'>
    readonly submissionID: FieldRef<"DataRecord", 'String'>
    readonly uploadedDate: FieldRef<"DataRecord", 'DateTime'>
    readonly validatedAt: FieldRef<"DataRecord", 'DateTime'>
    readonly createdAt: FieldRef<"DataRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"DataRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataRecord findUnique
   */
  export type DataRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecord
     */
    select?: DataRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecord
     */
    omit?: DataRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordInclude<ExtArgs> | null
    /**
     * Filter, which DataRecord to fetch.
     */
    where: DataRecordWhereUniqueInput
  }

  /**
   * DataRecord findUniqueOrThrow
   */
  export type DataRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecord
     */
    select?: DataRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecord
     */
    omit?: DataRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordInclude<ExtArgs> | null
    /**
     * Filter, which DataRecord to fetch.
     */
    where: DataRecordWhereUniqueInput
  }

  /**
   * DataRecord findFirst
   */
  export type DataRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecord
     */
    select?: DataRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecord
     */
    omit?: DataRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordInclude<ExtArgs> | null
    /**
     * Filter, which DataRecord to fetch.
     */
    where?: DataRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRecords to fetch.
     */
    orderBy?: DataRecordOrderByWithRelationInput | DataRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRecords.
     */
    cursor?: DataRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRecords.
     */
    distinct?: DataRecordScalarFieldEnum | DataRecordScalarFieldEnum[]
  }

  /**
   * DataRecord findFirstOrThrow
   */
  export type DataRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecord
     */
    select?: DataRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecord
     */
    omit?: DataRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordInclude<ExtArgs> | null
    /**
     * Filter, which DataRecord to fetch.
     */
    where?: DataRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRecords to fetch.
     */
    orderBy?: DataRecordOrderByWithRelationInput | DataRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRecords.
     */
    cursor?: DataRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRecords.
     */
    distinct?: DataRecordScalarFieldEnum | DataRecordScalarFieldEnum[]
  }

  /**
   * DataRecord findMany
   */
  export type DataRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecord
     */
    select?: DataRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecord
     */
    omit?: DataRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordInclude<ExtArgs> | null
    /**
     * Filter, which DataRecords to fetch.
     */
    where?: DataRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRecords to fetch.
     */
    orderBy?: DataRecordOrderByWithRelationInput | DataRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataRecords.
     */
    cursor?: DataRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRecords.
     */
    skip?: number
    distinct?: DataRecordScalarFieldEnum | DataRecordScalarFieldEnum[]
  }

  /**
   * DataRecord create
   */
  export type DataRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecord
     */
    select?: DataRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecord
     */
    omit?: DataRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a DataRecord.
     */
    data: XOR<DataRecordCreateInput, DataRecordUncheckedCreateInput>
  }

  /**
   * DataRecord createMany
   */
  export type DataRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataRecords.
     */
    data: DataRecordCreateManyInput | DataRecordCreateManyInput[]
  }

  /**
   * DataRecord update
   */
  export type DataRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecord
     */
    select?: DataRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecord
     */
    omit?: DataRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a DataRecord.
     */
    data: XOR<DataRecordUpdateInput, DataRecordUncheckedUpdateInput>
    /**
     * Choose, which DataRecord to update.
     */
    where: DataRecordWhereUniqueInput
  }

  /**
   * DataRecord updateMany
   */
  export type DataRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataRecords.
     */
    data: XOR<DataRecordUpdateManyMutationInput, DataRecordUncheckedUpdateManyInput>
    /**
     * Filter which DataRecords to update
     */
    where?: DataRecordWhereInput
    /**
     * Limit how many DataRecords to update.
     */
    limit?: number
  }

  /**
   * DataRecord upsert
   */
  export type DataRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecord
     */
    select?: DataRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecord
     */
    omit?: DataRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the DataRecord to update in case it exists.
     */
    where: DataRecordWhereUniqueInput
    /**
     * In case the DataRecord found by the `where` argument doesn't exist, create a new DataRecord with this data.
     */
    create: XOR<DataRecordCreateInput, DataRecordUncheckedCreateInput>
    /**
     * In case the DataRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataRecordUpdateInput, DataRecordUncheckedUpdateInput>
  }

  /**
   * DataRecord delete
   */
  export type DataRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecord
     */
    select?: DataRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecord
     */
    omit?: DataRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordInclude<ExtArgs> | null
    /**
     * Filter which DataRecord to delete.
     */
    where: DataRecordWhereUniqueInput
  }

  /**
   * DataRecord deleteMany
   */
  export type DataRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRecords to delete
     */
    where?: DataRecordWhereInput
    /**
     * Limit how many DataRecords to delete.
     */
    limit?: number
  }

  /**
   * DataRecord findRaw
   */
  export type DataRecordFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataRecord aggregateRaw
   */
  export type DataRecordAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataRecord without action
   */
  export type DataRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecord
     */
    select?: DataRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecord
     */
    omit?: DataRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordInclude<ExtArgs> | null
  }


  /**
   * Model DataRecordsArchived
   */

  export type AggregateDataRecordsArchived = {
    _count: DataRecordsArchivedCountAggregateOutputType | null
    _avg: DataRecordsArchivedAvgAggregateOutputType | null
    _sum: DataRecordsArchivedSumAggregateOutputType | null
    _min: DataRecordsArchivedMinAggregateOutputType | null
    _max: DataRecordsArchivedMaxAggregateOutputType | null
  }

  export type DataRecordsArchivedAvgAggregateOutputType = {
    latestBatchDisplayID: number | null
    lineNumber: number | null
  }

  export type DataRecordsArchivedSumAggregateOutputType = {
    latestBatchDisplayID: number | null
    lineNumber: number | null
  }

  export type DataRecordsArchivedMinAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    IDPropName: string | null
    dataCommons: string | null
    entityType: string | null
    latestBatchDisplayID: number | null
    latestBatchID: string | null
    lineNumber: number | null
    nodeID: string | null
    nodeType: string | null
    orginalFileName: string | null
    qcResultID: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    uploadedDate: Date | null
    validatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataRecordsArchivedMaxAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    IDPropName: string | null
    dataCommons: string | null
    entityType: string | null
    latestBatchDisplayID: number | null
    latestBatchID: string | null
    lineNumber: number | null
    nodeID: string | null
    nodeType: string | null
    orginalFileName: string | null
    qcResultID: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    uploadedDate: Date | null
    validatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataRecordsArchivedCountAggregateOutputType = {
    id: number
    CRDC_ID: number
    IDPropName: number
    batchIDs: number
    dataCommons: number
    entityType: number
    latestBatchDisplayID: number
    latestBatchID: number
    lineNumber: number
    nodeID: number
    nodeType: number
    orginalFileName: number
    props: number
    qcResultID: number
    rawData: number
    status: number
    studyID: number
    submissionID: number
    uploadedDate: number
    validatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataRecordsArchivedAvgAggregateInputType = {
    latestBatchDisplayID?: true
    lineNumber?: true
  }

  export type DataRecordsArchivedSumAggregateInputType = {
    latestBatchDisplayID?: true
    lineNumber?: true
  }

  export type DataRecordsArchivedMinAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    qcResultID?: true
    status?: true
    studyID?: true
    submissionID?: true
    uploadedDate?: true
    validatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataRecordsArchivedMaxAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    qcResultID?: true
    status?: true
    studyID?: true
    submissionID?: true
    uploadedDate?: true
    validatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataRecordsArchivedCountAggregateInputType = {
    id?: true
    CRDC_ID?: true
    IDPropName?: true
    batchIDs?: true
    dataCommons?: true
    entityType?: true
    latestBatchDisplayID?: true
    latestBatchID?: true
    lineNumber?: true
    nodeID?: true
    nodeType?: true
    orginalFileName?: true
    props?: true
    qcResultID?: true
    rawData?: true
    status?: true
    studyID?: true
    submissionID?: true
    uploadedDate?: true
    validatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataRecordsArchivedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRecordsArchived to aggregate.
     */
    where?: DataRecordsArchivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRecordsArchiveds to fetch.
     */
    orderBy?: DataRecordsArchivedOrderByWithRelationInput | DataRecordsArchivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataRecordsArchivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRecordsArchiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRecordsArchiveds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataRecordsArchiveds
    **/
    _count?: true | DataRecordsArchivedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataRecordsArchivedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataRecordsArchivedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataRecordsArchivedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataRecordsArchivedMaxAggregateInputType
  }

  export type GetDataRecordsArchivedAggregateType<T extends DataRecordsArchivedAggregateArgs> = {
        [P in keyof T & keyof AggregateDataRecordsArchived]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataRecordsArchived[P]>
      : GetScalarType<T[P], AggregateDataRecordsArchived[P]>
  }




  export type DataRecordsArchivedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRecordsArchivedWhereInput
    orderBy?: DataRecordsArchivedOrderByWithAggregationInput | DataRecordsArchivedOrderByWithAggregationInput[]
    by: DataRecordsArchivedScalarFieldEnum[] | DataRecordsArchivedScalarFieldEnum
    having?: DataRecordsArchivedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataRecordsArchivedCountAggregateInputType | true
    _avg?: DataRecordsArchivedAvgAggregateInputType
    _sum?: DataRecordsArchivedSumAggregateInputType
    _min?: DataRecordsArchivedMinAggregateInputType
    _max?: DataRecordsArchivedMaxAggregateInputType
  }

  export type DataRecordsArchivedGroupByOutputType = {
    id: string
    CRDC_ID: string | null
    IDPropName: string
    batchIDs: string[]
    dataCommons: string
    entityType: string | null
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    props: JsonValue
    qcResultID: string | null
    rawData: JsonValue
    status: string
    studyID: string | null
    submissionID: string
    uploadedDate: Date
    validatedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DataRecordsArchivedCountAggregateOutputType | null
    _avg: DataRecordsArchivedAvgAggregateOutputType | null
    _sum: DataRecordsArchivedSumAggregateOutputType | null
    _min: DataRecordsArchivedMinAggregateOutputType | null
    _max: DataRecordsArchivedMaxAggregateOutputType | null
  }

  type GetDataRecordsArchivedGroupByPayload<T extends DataRecordsArchivedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataRecordsArchivedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataRecordsArchivedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataRecordsArchivedGroupByOutputType[P]>
            : GetScalarType<T[P], DataRecordsArchivedGroupByOutputType[P]>
        }
      >
    >


  export type DataRecordsArchivedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CRDC_ID?: boolean
    IDPropName?: boolean
    additionalErrors?: boolean | AdditionalErrorDefaultArgs<ExtArgs>
    batchIDs?: boolean
    dataCommons?: boolean
    entityType?: boolean
    errors?: boolean | ErrorDefaultArgs<ExtArgs>
    latestBatchDisplayID?: boolean
    latestBatchID?: boolean
    lineNumber?: boolean
    nodeID?: boolean
    nodeType?: boolean
    orginalFileName?: boolean
    parents?: boolean | ParentDefaultArgs<ExtArgs>
    props?: boolean
    qcResultID?: boolean
    rawData?: boolean
    s3FileInfo?: boolean | S3FileInfoDefaultArgs<ExtArgs>
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    uploadedDate?: boolean
    validatedAt?: boolean
    warnings?: boolean | ErrorDefaultArgs<ExtArgs>
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataRecordsArchived"]>



  export type DataRecordsArchivedSelectScalar = {
    id?: boolean
    CRDC_ID?: boolean
    IDPropName?: boolean
    batchIDs?: boolean
    dataCommons?: boolean
    entityType?: boolean
    latestBatchDisplayID?: boolean
    latestBatchID?: boolean
    lineNumber?: boolean
    nodeID?: boolean
    nodeType?: boolean
    orginalFileName?: boolean
    props?: boolean
    qcResultID?: boolean
    rawData?: boolean
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    uploadedDate?: boolean
    validatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataRecordsArchivedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "CRDC_ID" | "IDPropName" | "additionalErrors" | "batchIDs" | "dataCommons" | "entityType" | "errors" | "latestBatchDisplayID" | "latestBatchID" | "lineNumber" | "nodeID" | "nodeType" | "orginalFileName" | "parents" | "props" | "qcResultID" | "rawData" | "s3FileInfo" | "status" | "studyID" | "submissionID" | "uploadedDate" | "validatedAt" | "warnings" | "createdAt" | "updatedAt", ExtArgs["result"]["dataRecordsArchived"]>
  export type DataRecordsArchivedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DataRecordsArchivedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataRecordsArchived"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      CRDC_ID: string | null
      IDPropName: string
      batchIDs: string[]
      dataCommons: string
      entityType: string | null
      latestBatchDisplayID: number
      latestBatchID: string
      lineNumber: number
      nodeID: string
      nodeType: string
      orginalFileName: string
      props: Prisma.JsonValue
      qcResultID: string | null
      rawData: Prisma.JsonValue
      status: string
      studyID: string | null
      submissionID: string
      uploadedDate: Date
      validatedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataRecordsArchived"]>
    composites: {
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      additionalErrors: Prisma.$AdditionalErrorPayload[]
      errors: Prisma.$ErrorPayload[]
      parents: Prisma.$ParentPayload[]
      s3FileInfo: Prisma.$S3FileInfoPayload | null
      warnings: Prisma.$ErrorPayload[]
    }
  }

  type DataRecordsArchivedGetPayload<S extends boolean | null | undefined | DataRecordsArchivedDefaultArgs> = $Result.GetResult<Prisma.$DataRecordsArchivedPayload, S>

  type DataRecordsArchivedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataRecordsArchivedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataRecordsArchivedCountAggregateInputType | true
    }

  export interface DataRecordsArchivedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataRecordsArchived'], meta: { name: 'DataRecordsArchived' } }
    /**
     * Find zero or one DataRecordsArchived that matches the filter.
     * @param {DataRecordsArchivedFindUniqueArgs} args - Arguments to find a DataRecordsArchived
     * @example
     * // Get one DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataRecordsArchivedFindUniqueArgs>(args: SelectSubset<T, DataRecordsArchivedFindUniqueArgs<ExtArgs>>): Prisma__DataRecordsArchivedClient<$Result.GetResult<Prisma.$DataRecordsArchivedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataRecordsArchived that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataRecordsArchivedFindUniqueOrThrowArgs} args - Arguments to find a DataRecordsArchived
     * @example
     * // Get one DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataRecordsArchivedFindUniqueOrThrowArgs>(args: SelectSubset<T, DataRecordsArchivedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataRecordsArchivedClient<$Result.GetResult<Prisma.$DataRecordsArchivedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRecordsArchived that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordsArchivedFindFirstArgs} args - Arguments to find a DataRecordsArchived
     * @example
     * // Get one DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataRecordsArchivedFindFirstArgs>(args?: SelectSubset<T, DataRecordsArchivedFindFirstArgs<ExtArgs>>): Prisma__DataRecordsArchivedClient<$Result.GetResult<Prisma.$DataRecordsArchivedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataRecordsArchived that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordsArchivedFindFirstOrThrowArgs} args - Arguments to find a DataRecordsArchived
     * @example
     * // Get one DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataRecordsArchivedFindFirstOrThrowArgs>(args?: SelectSubset<T, DataRecordsArchivedFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataRecordsArchivedClient<$Result.GetResult<Prisma.$DataRecordsArchivedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataRecordsArchiveds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordsArchivedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataRecordsArchiveds
     * const dataRecordsArchiveds = await prisma.dataRecordsArchived.findMany()
     * 
     * // Get first 10 DataRecordsArchiveds
     * const dataRecordsArchiveds = await prisma.dataRecordsArchived.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataRecordsArchivedWithIdOnly = await prisma.dataRecordsArchived.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataRecordsArchivedFindManyArgs>(args?: SelectSubset<T, DataRecordsArchivedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRecordsArchivedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataRecordsArchived.
     * @param {DataRecordsArchivedCreateArgs} args - Arguments to create a DataRecordsArchived.
     * @example
     * // Create one DataRecordsArchived
     * const DataRecordsArchived = await prisma.dataRecordsArchived.create({
     *   data: {
     *     // ... data to create a DataRecordsArchived
     *   }
     * })
     * 
     */
    create<T extends DataRecordsArchivedCreateArgs>(args: SelectSubset<T, DataRecordsArchivedCreateArgs<ExtArgs>>): Prisma__DataRecordsArchivedClient<$Result.GetResult<Prisma.$DataRecordsArchivedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataRecordsArchiveds.
     * @param {DataRecordsArchivedCreateManyArgs} args - Arguments to create many DataRecordsArchiveds.
     * @example
     * // Create many DataRecordsArchiveds
     * const dataRecordsArchived = await prisma.dataRecordsArchived.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataRecordsArchivedCreateManyArgs>(args?: SelectSubset<T, DataRecordsArchivedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataRecordsArchived.
     * @param {DataRecordsArchivedDeleteArgs} args - Arguments to delete one DataRecordsArchived.
     * @example
     * // Delete one DataRecordsArchived
     * const DataRecordsArchived = await prisma.dataRecordsArchived.delete({
     *   where: {
     *     // ... filter to delete one DataRecordsArchived
     *   }
     * })
     * 
     */
    delete<T extends DataRecordsArchivedDeleteArgs>(args: SelectSubset<T, DataRecordsArchivedDeleteArgs<ExtArgs>>): Prisma__DataRecordsArchivedClient<$Result.GetResult<Prisma.$DataRecordsArchivedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataRecordsArchived.
     * @param {DataRecordsArchivedUpdateArgs} args - Arguments to update one DataRecordsArchived.
     * @example
     * // Update one DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataRecordsArchivedUpdateArgs>(args: SelectSubset<T, DataRecordsArchivedUpdateArgs<ExtArgs>>): Prisma__DataRecordsArchivedClient<$Result.GetResult<Prisma.$DataRecordsArchivedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataRecordsArchiveds.
     * @param {DataRecordsArchivedDeleteManyArgs} args - Arguments to filter DataRecordsArchiveds to delete.
     * @example
     * // Delete a few DataRecordsArchiveds
     * const { count } = await prisma.dataRecordsArchived.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataRecordsArchivedDeleteManyArgs>(args?: SelectSubset<T, DataRecordsArchivedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRecordsArchiveds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordsArchivedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataRecordsArchiveds
     * const dataRecordsArchived = await prisma.dataRecordsArchived.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataRecordsArchivedUpdateManyArgs>(args: SelectSubset<T, DataRecordsArchivedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataRecordsArchived.
     * @param {DataRecordsArchivedUpsertArgs} args - Arguments to update or create a DataRecordsArchived.
     * @example
     * // Update or create a DataRecordsArchived
     * const dataRecordsArchived = await prisma.dataRecordsArchived.upsert({
     *   create: {
     *     // ... data to create a DataRecordsArchived
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataRecordsArchived we want to update
     *   }
     * })
     */
    upsert<T extends DataRecordsArchivedUpsertArgs>(args: SelectSubset<T, DataRecordsArchivedUpsertArgs<ExtArgs>>): Prisma__DataRecordsArchivedClient<$Result.GetResult<Prisma.$DataRecordsArchivedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataRecordsArchiveds that matches the filter.
     * @param {DataRecordsArchivedFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dataRecordsArchived = await prisma.dataRecordsArchived.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DataRecordsArchivedFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DataRecordsArchived.
     * @param {DataRecordsArchivedAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dataRecordsArchived = await prisma.dataRecordsArchived.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DataRecordsArchivedAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DataRecordsArchiveds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordsArchivedCountArgs} args - Arguments to filter DataRecordsArchiveds to count.
     * @example
     * // Count the number of DataRecordsArchiveds
     * const count = await prisma.dataRecordsArchived.count({
     *   where: {
     *     // ... the filter for the DataRecordsArchiveds we want to count
     *   }
     * })
    **/
    count<T extends DataRecordsArchivedCountArgs>(
      args?: Subset<T, DataRecordsArchivedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataRecordsArchivedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataRecordsArchived.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordsArchivedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataRecordsArchivedAggregateArgs>(args: Subset<T, DataRecordsArchivedAggregateArgs>): Prisma.PrismaPromise<GetDataRecordsArchivedAggregateType<T>>

    /**
     * Group by DataRecordsArchived.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRecordsArchivedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataRecordsArchivedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataRecordsArchivedGroupByArgs['orderBy'] }
        : { orderBy?: DataRecordsArchivedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataRecordsArchivedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataRecordsArchivedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataRecordsArchived model
   */
  readonly fields: DataRecordsArchivedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataRecordsArchived.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataRecordsArchivedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataRecordsArchived model
   */
  interface DataRecordsArchivedFieldRefs {
    readonly id: FieldRef<"DataRecordsArchived", 'String'>
    readonly CRDC_ID: FieldRef<"DataRecordsArchived", 'String'>
    readonly IDPropName: FieldRef<"DataRecordsArchived", 'String'>
    readonly batchIDs: FieldRef<"DataRecordsArchived", 'String[]'>
    readonly dataCommons: FieldRef<"DataRecordsArchived", 'String'>
    readonly entityType: FieldRef<"DataRecordsArchived", 'String'>
    readonly latestBatchDisplayID: FieldRef<"DataRecordsArchived", 'Int'>
    readonly latestBatchID: FieldRef<"DataRecordsArchived", 'String'>
    readonly lineNumber: FieldRef<"DataRecordsArchived", 'Int'>
    readonly nodeID: FieldRef<"DataRecordsArchived", 'String'>
    readonly nodeType: FieldRef<"DataRecordsArchived", 'String'>
    readonly orginalFileName: FieldRef<"DataRecordsArchived", 'String'>
    readonly props: FieldRef<"DataRecordsArchived", 'Json'>
    readonly qcResultID: FieldRef<"DataRecordsArchived", 'String'>
    readonly rawData: FieldRef<"DataRecordsArchived", 'Json'>
    readonly status: FieldRef<"DataRecordsArchived", 'String'>
    readonly studyID: FieldRef<"DataRecordsArchived", 'String'>
    readonly submissionID: FieldRef<"DataRecordsArchived", 'String'>
    readonly uploadedDate: FieldRef<"DataRecordsArchived", 'DateTime'>
    readonly validatedAt: FieldRef<"DataRecordsArchived", 'DateTime'>
    readonly createdAt: FieldRef<"DataRecordsArchived", 'DateTime'>
    readonly updatedAt: FieldRef<"DataRecordsArchived", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataRecordsArchived findUnique
   */
  export type DataRecordsArchivedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecordsArchived
     */
    select?: DataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecordsArchived
     */
    omit?: DataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter, which DataRecordsArchived to fetch.
     */
    where: DataRecordsArchivedWhereUniqueInput
  }

  /**
   * DataRecordsArchived findUniqueOrThrow
   */
  export type DataRecordsArchivedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecordsArchived
     */
    select?: DataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecordsArchived
     */
    omit?: DataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter, which DataRecordsArchived to fetch.
     */
    where: DataRecordsArchivedWhereUniqueInput
  }

  /**
   * DataRecordsArchived findFirst
   */
  export type DataRecordsArchivedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecordsArchived
     */
    select?: DataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecordsArchived
     */
    omit?: DataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter, which DataRecordsArchived to fetch.
     */
    where?: DataRecordsArchivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRecordsArchiveds to fetch.
     */
    orderBy?: DataRecordsArchivedOrderByWithRelationInput | DataRecordsArchivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRecordsArchiveds.
     */
    cursor?: DataRecordsArchivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRecordsArchiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRecordsArchiveds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRecordsArchiveds.
     */
    distinct?: DataRecordsArchivedScalarFieldEnum | DataRecordsArchivedScalarFieldEnum[]
  }

  /**
   * DataRecordsArchived findFirstOrThrow
   */
  export type DataRecordsArchivedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecordsArchived
     */
    select?: DataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecordsArchived
     */
    omit?: DataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter, which DataRecordsArchived to fetch.
     */
    where?: DataRecordsArchivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRecordsArchiveds to fetch.
     */
    orderBy?: DataRecordsArchivedOrderByWithRelationInput | DataRecordsArchivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRecordsArchiveds.
     */
    cursor?: DataRecordsArchivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRecordsArchiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRecordsArchiveds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRecordsArchiveds.
     */
    distinct?: DataRecordsArchivedScalarFieldEnum | DataRecordsArchivedScalarFieldEnum[]
  }

  /**
   * DataRecordsArchived findMany
   */
  export type DataRecordsArchivedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecordsArchived
     */
    select?: DataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecordsArchived
     */
    omit?: DataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter, which DataRecordsArchiveds to fetch.
     */
    where?: DataRecordsArchivedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRecordsArchiveds to fetch.
     */
    orderBy?: DataRecordsArchivedOrderByWithRelationInput | DataRecordsArchivedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataRecordsArchiveds.
     */
    cursor?: DataRecordsArchivedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRecordsArchiveds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRecordsArchiveds.
     */
    skip?: number
    distinct?: DataRecordsArchivedScalarFieldEnum | DataRecordsArchivedScalarFieldEnum[]
  }

  /**
   * DataRecordsArchived create
   */
  export type DataRecordsArchivedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecordsArchived
     */
    select?: DataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecordsArchived
     */
    omit?: DataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordsArchivedInclude<ExtArgs> | null
    /**
     * The data needed to create a DataRecordsArchived.
     */
    data: XOR<DataRecordsArchivedCreateInput, DataRecordsArchivedUncheckedCreateInput>
  }

  /**
   * DataRecordsArchived createMany
   */
  export type DataRecordsArchivedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataRecordsArchiveds.
     */
    data: DataRecordsArchivedCreateManyInput | DataRecordsArchivedCreateManyInput[]
  }

  /**
   * DataRecordsArchived update
   */
  export type DataRecordsArchivedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecordsArchived
     */
    select?: DataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecordsArchived
     */
    omit?: DataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordsArchivedInclude<ExtArgs> | null
    /**
     * The data needed to update a DataRecordsArchived.
     */
    data: XOR<DataRecordsArchivedUpdateInput, DataRecordsArchivedUncheckedUpdateInput>
    /**
     * Choose, which DataRecordsArchived to update.
     */
    where: DataRecordsArchivedWhereUniqueInput
  }

  /**
   * DataRecordsArchived updateMany
   */
  export type DataRecordsArchivedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataRecordsArchiveds.
     */
    data: XOR<DataRecordsArchivedUpdateManyMutationInput, DataRecordsArchivedUncheckedUpdateManyInput>
    /**
     * Filter which DataRecordsArchiveds to update
     */
    where?: DataRecordsArchivedWhereInput
    /**
     * Limit how many DataRecordsArchiveds to update.
     */
    limit?: number
  }

  /**
   * DataRecordsArchived upsert
   */
  export type DataRecordsArchivedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecordsArchived
     */
    select?: DataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecordsArchived
     */
    omit?: DataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordsArchivedInclude<ExtArgs> | null
    /**
     * The filter to search for the DataRecordsArchived to update in case it exists.
     */
    where: DataRecordsArchivedWhereUniqueInput
    /**
     * In case the DataRecordsArchived found by the `where` argument doesn't exist, create a new DataRecordsArchived with this data.
     */
    create: XOR<DataRecordsArchivedCreateInput, DataRecordsArchivedUncheckedCreateInput>
    /**
     * In case the DataRecordsArchived was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataRecordsArchivedUpdateInput, DataRecordsArchivedUncheckedUpdateInput>
  }

  /**
   * DataRecordsArchived delete
   */
  export type DataRecordsArchivedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecordsArchived
     */
    select?: DataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecordsArchived
     */
    omit?: DataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordsArchivedInclude<ExtArgs> | null
    /**
     * Filter which DataRecordsArchived to delete.
     */
    where: DataRecordsArchivedWhereUniqueInput
  }

  /**
   * DataRecordsArchived deleteMany
   */
  export type DataRecordsArchivedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRecordsArchiveds to delete
     */
    where?: DataRecordsArchivedWhereInput
    /**
     * Limit how many DataRecordsArchiveds to delete.
     */
    limit?: number
  }

  /**
   * DataRecordsArchived findRaw
   */
  export type DataRecordsArchivedFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataRecordsArchived aggregateRaw
   */
  export type DataRecordsArchivedAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DataRecordsArchived without action
   */
  export type DataRecordsArchivedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecordsArchived
     */
    select?: DataRecordsArchivedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecordsArchived
     */
    omit?: DataRecordsArchivedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordsArchivedInclude<ExtArgs> | null
  }


  /**
   * Model FileMD5
   */

  export type AggregateFileMD5 = {
    _count: FileMD5CountAggregateOutputType | null
    _min: FileMD5MinAggregateOutputType | null
    _max: FileMD5MaxAggregateOutputType | null
  }

  export type FileMD5MinAggregateOutputType = {
    id: string | null
    LastModified: Date | null
    fileName: string | null
    md5: string | null
    submissionID: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileMD5MaxAggregateOutputType = {
    id: string | null
    LastModified: Date | null
    fileName: string | null
    md5: string | null
    submissionID: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileMD5CountAggregateOutputType = {
    id: number
    LastModified: number
    fileName: number
    md5: number
    submissionID: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FileMD5MinAggregateInputType = {
    id?: true
    LastModified?: true
    fileName?: true
    md5?: true
    submissionID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileMD5MaxAggregateInputType = {
    id?: true
    LastModified?: true
    fileName?: true
    md5?: true
    submissionID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileMD5CountAggregateInputType = {
    id?: true
    LastModified?: true
    fileName?: true
    md5?: true
    submissionID?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FileMD5AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileMD5 to aggregate.
     */
    where?: FileMD5WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMD5s to fetch.
     */
    orderBy?: FileMD5OrderByWithRelationInput | FileMD5OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileMD5WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMD5s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMD5s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileMD5s
    **/
    _count?: true | FileMD5CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMD5MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMD5MaxAggregateInputType
  }

  export type GetFileMD5AggregateType<T extends FileMD5AggregateArgs> = {
        [P in keyof T & keyof AggregateFileMD5]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileMD5[P]>
      : GetScalarType<T[P], AggregateFileMD5[P]>
  }




  export type FileMD5GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMD5WhereInput
    orderBy?: FileMD5OrderByWithAggregationInput | FileMD5OrderByWithAggregationInput[]
    by: FileMD5ScalarFieldEnum[] | FileMD5ScalarFieldEnum
    having?: FileMD5ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileMD5CountAggregateInputType | true
    _min?: FileMD5MinAggregateInputType
    _max?: FileMD5MaxAggregateInputType
  }

  export type FileMD5GroupByOutputType = {
    id: string
    LastModified: Date
    fileName: string
    md5: string
    submissionID: string
    createdAt: Date
    updatedAt: Date
    _count: FileMD5CountAggregateOutputType | null
    _min: FileMD5MinAggregateOutputType | null
    _max: FileMD5MaxAggregateOutputType | null
  }

  type GetFileMD5GroupByPayload<T extends FileMD5GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileMD5GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileMD5GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileMD5GroupByOutputType[P]>
            : GetScalarType<T[P], FileMD5GroupByOutputType[P]>
        }
      >
    >


  export type FileMD5Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    LastModified?: boolean
    fileName?: boolean
    md5?: boolean
    submissionID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fileMD5"]>



  export type FileMD5SelectScalar = {
    id?: boolean
    LastModified?: boolean
    fileName?: boolean
    md5?: boolean
    submissionID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FileMD5Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "LastModified" | "fileName" | "md5" | "submissionID" | "createdAt" | "updatedAt", ExtArgs["result"]["fileMD5"]>

  export type $FileMD5Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileMD5"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      LastModified: Date
      fileName: string
      md5: string
      submissionID: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fileMD5"]>
    composites: {}
  }

  type FileMD5GetPayload<S extends boolean | null | undefined | FileMD5DefaultArgs> = $Result.GetResult<Prisma.$FileMD5Payload, S>

  type FileMD5CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileMD5FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileMD5CountAggregateInputType | true
    }

  export interface FileMD5Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileMD5'], meta: { name: 'FileMD5' } }
    /**
     * Find zero or one FileMD5 that matches the filter.
     * @param {FileMD5FindUniqueArgs} args - Arguments to find a FileMD5
     * @example
     * // Get one FileMD5
     * const fileMD5 = await prisma.fileMD5.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileMD5FindUniqueArgs>(args: SelectSubset<T, FileMD5FindUniqueArgs<ExtArgs>>): Prisma__FileMD5Client<$Result.GetResult<Prisma.$FileMD5Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileMD5 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileMD5FindUniqueOrThrowArgs} args - Arguments to find a FileMD5
     * @example
     * // Get one FileMD5
     * const fileMD5 = await prisma.fileMD5.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileMD5FindUniqueOrThrowArgs>(args: SelectSubset<T, FileMD5FindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileMD5Client<$Result.GetResult<Prisma.$FileMD5Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileMD5 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMD5FindFirstArgs} args - Arguments to find a FileMD5
     * @example
     * // Get one FileMD5
     * const fileMD5 = await prisma.fileMD5.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileMD5FindFirstArgs>(args?: SelectSubset<T, FileMD5FindFirstArgs<ExtArgs>>): Prisma__FileMD5Client<$Result.GetResult<Prisma.$FileMD5Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileMD5 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMD5FindFirstOrThrowArgs} args - Arguments to find a FileMD5
     * @example
     * // Get one FileMD5
     * const fileMD5 = await prisma.fileMD5.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileMD5FindFirstOrThrowArgs>(args?: SelectSubset<T, FileMD5FindFirstOrThrowArgs<ExtArgs>>): Prisma__FileMD5Client<$Result.GetResult<Prisma.$FileMD5Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileMD5s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMD5FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileMD5s
     * const fileMD5s = await prisma.fileMD5.findMany()
     * 
     * // Get first 10 FileMD5s
     * const fileMD5s = await prisma.fileMD5.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileMD5WithIdOnly = await prisma.fileMD5.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileMD5FindManyArgs>(args?: SelectSubset<T, FileMD5FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMD5Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileMD5.
     * @param {FileMD5CreateArgs} args - Arguments to create a FileMD5.
     * @example
     * // Create one FileMD5
     * const FileMD5 = await prisma.fileMD5.create({
     *   data: {
     *     // ... data to create a FileMD5
     *   }
     * })
     * 
     */
    create<T extends FileMD5CreateArgs>(args: SelectSubset<T, FileMD5CreateArgs<ExtArgs>>): Prisma__FileMD5Client<$Result.GetResult<Prisma.$FileMD5Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileMD5s.
     * @param {FileMD5CreateManyArgs} args - Arguments to create many FileMD5s.
     * @example
     * // Create many FileMD5s
     * const fileMD5 = await prisma.fileMD5.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileMD5CreateManyArgs>(args?: SelectSubset<T, FileMD5CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FileMD5.
     * @param {FileMD5DeleteArgs} args - Arguments to delete one FileMD5.
     * @example
     * // Delete one FileMD5
     * const FileMD5 = await prisma.fileMD5.delete({
     *   where: {
     *     // ... filter to delete one FileMD5
     *   }
     * })
     * 
     */
    delete<T extends FileMD5DeleteArgs>(args: SelectSubset<T, FileMD5DeleteArgs<ExtArgs>>): Prisma__FileMD5Client<$Result.GetResult<Prisma.$FileMD5Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileMD5.
     * @param {FileMD5UpdateArgs} args - Arguments to update one FileMD5.
     * @example
     * // Update one FileMD5
     * const fileMD5 = await prisma.fileMD5.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileMD5UpdateArgs>(args: SelectSubset<T, FileMD5UpdateArgs<ExtArgs>>): Prisma__FileMD5Client<$Result.GetResult<Prisma.$FileMD5Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileMD5s.
     * @param {FileMD5DeleteManyArgs} args - Arguments to filter FileMD5s to delete.
     * @example
     * // Delete a few FileMD5s
     * const { count } = await prisma.fileMD5.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileMD5DeleteManyArgs>(args?: SelectSubset<T, FileMD5DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileMD5s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMD5UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileMD5s
     * const fileMD5 = await prisma.fileMD5.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileMD5UpdateManyArgs>(args: SelectSubset<T, FileMD5UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FileMD5.
     * @param {FileMD5UpsertArgs} args - Arguments to update or create a FileMD5.
     * @example
     * // Update or create a FileMD5
     * const fileMD5 = await prisma.fileMD5.upsert({
     *   create: {
     *     // ... data to create a FileMD5
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileMD5 we want to update
     *   }
     * })
     */
    upsert<T extends FileMD5UpsertArgs>(args: SelectSubset<T, FileMD5UpsertArgs<ExtArgs>>): Prisma__FileMD5Client<$Result.GetResult<Prisma.$FileMD5Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileMD5s that matches the filter.
     * @param {FileMD5FindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fileMD5 = await prisma.fileMD5.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FileMD5FindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FileMD5.
     * @param {FileMD5AggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fileMD5 = await prisma.fileMD5.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FileMD5AggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FileMD5s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMD5CountArgs} args - Arguments to filter FileMD5s to count.
     * @example
     * // Count the number of FileMD5s
     * const count = await prisma.fileMD5.count({
     *   where: {
     *     // ... the filter for the FileMD5s we want to count
     *   }
     * })
    **/
    count<T extends FileMD5CountArgs>(
      args?: Subset<T, FileMD5CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileMD5CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileMD5.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMD5AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileMD5AggregateArgs>(args: Subset<T, FileMD5AggregateArgs>): Prisma.PrismaPromise<GetFileMD5AggregateType<T>>

    /**
     * Group by FileMD5.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMD5GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileMD5GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileMD5GroupByArgs['orderBy'] }
        : { orderBy?: FileMD5GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileMD5GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileMD5GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileMD5 model
   */
  readonly fields: FileMD5FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileMD5.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileMD5Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileMD5 model
   */
  interface FileMD5FieldRefs {
    readonly id: FieldRef<"FileMD5", 'String'>
    readonly LastModified: FieldRef<"FileMD5", 'DateTime'>
    readonly fileName: FieldRef<"FileMD5", 'String'>
    readonly md5: FieldRef<"FileMD5", 'String'>
    readonly submissionID: FieldRef<"FileMD5", 'String'>
    readonly createdAt: FieldRef<"FileMD5", 'DateTime'>
    readonly updatedAt: FieldRef<"FileMD5", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileMD5 findUnique
   */
  export type FileMD5FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMD5
     */
    select?: FileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the FileMD5
     */
    omit?: FileMD5Omit<ExtArgs> | null
    /**
     * Filter, which FileMD5 to fetch.
     */
    where: FileMD5WhereUniqueInput
  }

  /**
   * FileMD5 findUniqueOrThrow
   */
  export type FileMD5FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMD5
     */
    select?: FileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the FileMD5
     */
    omit?: FileMD5Omit<ExtArgs> | null
    /**
     * Filter, which FileMD5 to fetch.
     */
    where: FileMD5WhereUniqueInput
  }

  /**
   * FileMD5 findFirst
   */
  export type FileMD5FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMD5
     */
    select?: FileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the FileMD5
     */
    omit?: FileMD5Omit<ExtArgs> | null
    /**
     * Filter, which FileMD5 to fetch.
     */
    where?: FileMD5WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMD5s to fetch.
     */
    orderBy?: FileMD5OrderByWithRelationInput | FileMD5OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileMD5s.
     */
    cursor?: FileMD5WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMD5s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMD5s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileMD5s.
     */
    distinct?: FileMD5ScalarFieldEnum | FileMD5ScalarFieldEnum[]
  }

  /**
   * FileMD5 findFirstOrThrow
   */
  export type FileMD5FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMD5
     */
    select?: FileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the FileMD5
     */
    omit?: FileMD5Omit<ExtArgs> | null
    /**
     * Filter, which FileMD5 to fetch.
     */
    where?: FileMD5WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMD5s to fetch.
     */
    orderBy?: FileMD5OrderByWithRelationInput | FileMD5OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileMD5s.
     */
    cursor?: FileMD5WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMD5s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMD5s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileMD5s.
     */
    distinct?: FileMD5ScalarFieldEnum | FileMD5ScalarFieldEnum[]
  }

  /**
   * FileMD5 findMany
   */
  export type FileMD5FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMD5
     */
    select?: FileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the FileMD5
     */
    omit?: FileMD5Omit<ExtArgs> | null
    /**
     * Filter, which FileMD5s to fetch.
     */
    where?: FileMD5WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMD5s to fetch.
     */
    orderBy?: FileMD5OrderByWithRelationInput | FileMD5OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileMD5s.
     */
    cursor?: FileMD5WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMD5s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMD5s.
     */
    skip?: number
    distinct?: FileMD5ScalarFieldEnum | FileMD5ScalarFieldEnum[]
  }

  /**
   * FileMD5 create
   */
  export type FileMD5CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMD5
     */
    select?: FileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the FileMD5
     */
    omit?: FileMD5Omit<ExtArgs> | null
    /**
     * The data needed to create a FileMD5.
     */
    data: XOR<FileMD5CreateInput, FileMD5UncheckedCreateInput>
  }

  /**
   * FileMD5 createMany
   */
  export type FileMD5CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileMD5s.
     */
    data: FileMD5CreateManyInput | FileMD5CreateManyInput[]
  }

  /**
   * FileMD5 update
   */
  export type FileMD5UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMD5
     */
    select?: FileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the FileMD5
     */
    omit?: FileMD5Omit<ExtArgs> | null
    /**
     * The data needed to update a FileMD5.
     */
    data: XOR<FileMD5UpdateInput, FileMD5UncheckedUpdateInput>
    /**
     * Choose, which FileMD5 to update.
     */
    where: FileMD5WhereUniqueInput
  }

  /**
   * FileMD5 updateMany
   */
  export type FileMD5UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileMD5s.
     */
    data: XOR<FileMD5UpdateManyMutationInput, FileMD5UncheckedUpdateManyInput>
    /**
     * Filter which FileMD5s to update
     */
    where?: FileMD5WhereInput
    /**
     * Limit how many FileMD5s to update.
     */
    limit?: number
  }

  /**
   * FileMD5 upsert
   */
  export type FileMD5UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMD5
     */
    select?: FileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the FileMD5
     */
    omit?: FileMD5Omit<ExtArgs> | null
    /**
     * The filter to search for the FileMD5 to update in case it exists.
     */
    where: FileMD5WhereUniqueInput
    /**
     * In case the FileMD5 found by the `where` argument doesn't exist, create a new FileMD5 with this data.
     */
    create: XOR<FileMD5CreateInput, FileMD5UncheckedCreateInput>
    /**
     * In case the FileMD5 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileMD5UpdateInput, FileMD5UncheckedUpdateInput>
  }

  /**
   * FileMD5 delete
   */
  export type FileMD5DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMD5
     */
    select?: FileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the FileMD5
     */
    omit?: FileMD5Omit<ExtArgs> | null
    /**
     * Filter which FileMD5 to delete.
     */
    where: FileMD5WhereUniqueInput
  }

  /**
   * FileMD5 deleteMany
   */
  export type FileMD5DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileMD5s to delete
     */
    where?: FileMD5WhereInput
    /**
     * Limit how many FileMD5s to delete.
     */
    limit?: number
  }

  /**
   * FileMD5 findRaw
   */
  export type FileMD5FindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FileMD5 aggregateRaw
   */
  export type FileMD5AggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FileMD5 without action
   */
  export type FileMD5DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMD5
     */
    select?: FileMD5Select<ExtArgs> | null
    /**
     * Omit specific fields from the FileMD5
     */
    omit?: FileMD5Omit<ExtArgs> | null
  }


  /**
   * Model Institution
   */

  export type AggregateInstitution = {
    _count: InstitutionCountAggregateOutputType | null
    _avg: InstitutionAvgAggregateOutputType | null
    _sum: InstitutionSumAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  export type InstitutionAvgAggregateOutputType = {
    submitterCount: number | null
  }

  export type InstitutionSumAggregateOutputType = {
    submitterCount: number | null
  }

  export type InstitutionMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: string | null
    submitterCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstitutionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: string | null
    submitterCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstitutionCountAggregateOutputType = {
    id: number
    name: number
    status: number
    submitterCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstitutionAvgAggregateInputType = {
    submitterCount?: true
  }

  export type InstitutionSumAggregateInputType = {
    submitterCount?: true
  }

  export type InstitutionMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    submitterCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstitutionMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    submitterCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstitutionCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    submitterCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institution to aggregate.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Institutions
    **/
    _count?: true | InstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstitutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstitutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionMaxAggregateInputType
  }

  export type GetInstitutionAggregateType<T extends InstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitution[P]>
      : GetScalarType<T[P], AggregateInstitution[P]>
  }




  export type InstitutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionWhereInput
    orderBy?: InstitutionOrderByWithAggregationInput | InstitutionOrderByWithAggregationInput[]
    by: InstitutionScalarFieldEnum[] | InstitutionScalarFieldEnum
    having?: InstitutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionCountAggregateInputType | true
    _avg?: InstitutionAvgAggregateInputType
    _sum?: InstitutionSumAggregateInputType
    _min?: InstitutionMinAggregateInputType
    _max?: InstitutionMaxAggregateInputType
  }

  export type InstitutionGroupByOutputType = {
    id: string
    name: string
    status: string
    submitterCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: InstitutionCountAggregateOutputType | null
    _avg: InstitutionAvgAggregateOutputType | null
    _sum: InstitutionSumAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  type GetInstitutionGroupByPayload<T extends InstitutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
        }
      >
    >


  export type InstitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    submitterCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["institution"]>



  export type InstitutionSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    submitterCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstitutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "submitterCount" | "createdAt" | "updatedAt", ExtArgs["result"]["institution"]>

  export type $InstitutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Institution"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: string
      submitterCount: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["institution"]>
    composites: {}
  }

  type InstitutionGetPayload<S extends boolean | null | undefined | InstitutionDefaultArgs> = $Result.GetResult<Prisma.$InstitutionPayload, S>

  type InstitutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstitutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstitutionCountAggregateInputType | true
    }

  export interface InstitutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Institution'], meta: { name: 'Institution' } }
    /**
     * Find zero or one Institution that matches the filter.
     * @param {InstitutionFindUniqueArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstitutionFindUniqueArgs>(args: SelectSubset<T, InstitutionFindUniqueArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstitutionFindUniqueOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstitutionFindUniqueOrThrowArgs>(args: SelectSubset<T, InstitutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstitutionFindFirstArgs>(args?: SelectSubset<T, InstitutionFindFirstArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstitutionFindFirstOrThrowArgs>(args?: SelectSubset<T, InstitutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutions
     * const institutions = await prisma.institution.findMany()
     * 
     * // Get first 10 Institutions
     * const institutions = await prisma.institution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionWithIdOnly = await prisma.institution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstitutionFindManyArgs>(args?: SelectSubset<T, InstitutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institution.
     * @param {InstitutionCreateArgs} args - Arguments to create a Institution.
     * @example
     * // Create one Institution
     * const Institution = await prisma.institution.create({
     *   data: {
     *     // ... data to create a Institution
     *   }
     * })
     * 
     */
    create<T extends InstitutionCreateArgs>(args: SelectSubset<T, InstitutionCreateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institutions.
     * @param {InstitutionCreateManyArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institution = await prisma.institution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstitutionCreateManyArgs>(args?: SelectSubset<T, InstitutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Institution.
     * @param {InstitutionDeleteArgs} args - Arguments to delete one Institution.
     * @example
     * // Delete one Institution
     * const Institution = await prisma.institution.delete({
     *   where: {
     *     // ... filter to delete one Institution
     *   }
     * })
     * 
     */
    delete<T extends InstitutionDeleteArgs>(args: SelectSubset<T, InstitutionDeleteArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institution.
     * @param {InstitutionUpdateArgs} args - Arguments to update one Institution.
     * @example
     * // Update one Institution
     * const institution = await prisma.institution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstitutionUpdateArgs>(args: SelectSubset<T, InstitutionUpdateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institutions.
     * @param {InstitutionDeleteManyArgs} args - Arguments to filter Institutions to delete.
     * @example
     * // Delete a few Institutions
     * const { count } = await prisma.institution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstitutionDeleteManyArgs>(args?: SelectSubset<T, InstitutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutions
     * const institution = await prisma.institution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstitutionUpdateManyArgs>(args: SelectSubset<T, InstitutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Institution.
     * @param {InstitutionUpsertArgs} args - Arguments to update or create a Institution.
     * @example
     * // Update or create a Institution
     * const institution = await prisma.institution.upsert({
     *   create: {
     *     // ... data to create a Institution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institution we want to update
     *   }
     * })
     */
    upsert<T extends InstitutionUpsertArgs>(args: SelectSubset<T, InstitutionUpsertArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutions that matches the filter.
     * @param {InstitutionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const institution = await prisma.institution.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InstitutionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Institution.
     * @param {InstitutionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const institution = await prisma.institution.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InstitutionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionCountArgs} args - Arguments to filter Institutions to count.
     * @example
     * // Count the number of Institutions
     * const count = await prisma.institution.count({
     *   where: {
     *     // ... the filter for the Institutions we want to count
     *   }
     * })
    **/
    count<T extends InstitutionCountArgs>(
      args?: Subset<T, InstitutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionAggregateArgs>(args: Subset<T, InstitutionAggregateArgs>): Prisma.PrismaPromise<GetInstitutionAggregateType<T>>

    /**
     * Group by Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutionGroupByArgs['orderBy'] }
        : { orderBy?: InstitutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Institution model
   */
  readonly fields: InstitutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Institution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstitutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Institution model
   */
  interface InstitutionFieldRefs {
    readonly id: FieldRef<"Institution", 'String'>
    readonly name: FieldRef<"Institution", 'String'>
    readonly status: FieldRef<"Institution", 'String'>
    readonly submitterCount: FieldRef<"Institution", 'Int'>
    readonly createdAt: FieldRef<"Institution", 'DateTime'>
    readonly updatedAt: FieldRef<"Institution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Institution findUnique
   */
  export type InstitutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findUniqueOrThrow
   */
  export type InstitutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findFirst
   */
  export type InstitutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findFirstOrThrow
   */
  export type InstitutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findMany
   */
  export type InstitutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Filter, which Institutions to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution create
   */
  export type InstitutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * The data needed to create a Institution.
     */
    data: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
  }

  /**
   * Institution createMany
   */
  export type InstitutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Institutions.
     */
    data: InstitutionCreateManyInput | InstitutionCreateManyInput[]
  }

  /**
   * Institution update
   */
  export type InstitutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * The data needed to update a Institution.
     */
    data: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
    /**
     * Choose, which Institution to update.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution updateMany
   */
  export type InstitutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Institutions.
     */
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Institutions to update
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to update.
     */
    limit?: number
  }

  /**
   * Institution upsert
   */
  export type InstitutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * The filter to search for the Institution to update in case it exists.
     */
    where: InstitutionWhereUniqueInput
    /**
     * In case the Institution found by the `where` argument doesn't exist, create a new Institution with this data.
     */
    create: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
    /**
     * In case the Institution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
  }

  /**
   * Institution delete
   */
  export type InstitutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Filter which Institution to delete.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution deleteMany
   */
  export type InstitutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutions to delete
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to delete.
     */
    limit?: number
  }

  /**
   * Institution findRaw
   */
  export type InstitutionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Institution aggregateRaw
   */
  export type InstitutionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Institution without action
   */
  export type InstitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    timestamp: number | null
  }

  export type LogSumAggregateOutputType = {
    timestamp: number | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    action: string | null
    applicationID: string | null
    eventType: string | null
    localtime: Date | null
    newState: string | null
    prevState: string | null
    submissionID: string | null
    timestamp: number | null
    userEmail: string | null
    userID: string | null
    userIDP: string | null
    userName: string | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    applicationID: string | null
    eventType: string | null
    localtime: Date | null
    newState: string | null
    prevState: string | null
    submissionID: string | null
    timestamp: number | null
    userEmail: string | null
    userID: string | null
    userIDP: string | null
    userName: string | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    action: number
    applicationID: number
    eventType: number
    localtime: number
    newProfile: number
    newState: number
    prevProfile: number
    prevState: number
    submissionID: number
    timestamp: number
    userEmail: number
    userID: number
    userIDP: number
    userName: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    timestamp?: true
  }

  export type LogSumAggregateInputType = {
    timestamp?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    action?: true
    applicationID?: true
    eventType?: true
    localtime?: true
    newState?: true
    prevState?: true
    submissionID?: true
    timestamp?: true
    userEmail?: true
    userID?: true
    userIDP?: true
    userName?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    action?: true
    applicationID?: true
    eventType?: true
    localtime?: true
    newState?: true
    prevState?: true
    submissionID?: true
    timestamp?: true
    userEmail?: true
    userID?: true
    userIDP?: true
    userName?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    action?: true
    applicationID?: true
    eventType?: true
    localtime?: true
    newProfile?: true
    newState?: true
    prevProfile?: true
    prevState?: true
    submissionID?: true
    timestamp?: true
    userEmail?: true
    userID?: true
    userIDP?: true
    userName?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: string
    action: string | null
    applicationID: string | null
    eventType: string
    localtime: Date
    newProfile: JsonValue | null
    newState: string | null
    prevProfile: JsonValue | null
    prevState: string | null
    submissionID: string | null
    timestamp: number
    userEmail: string
    userID: string
    userIDP: string | null
    userName: string | null
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    applicationID?: boolean
    eventDetail?: boolean | LogsEventDetailDefaultArgs<ExtArgs>
    eventType?: boolean
    localtime?: boolean
    newProfile?: boolean
    newState?: boolean
    prevProfile?: boolean
    prevState?: boolean
    submissionID?: boolean
    timestamp?: boolean
    userEmail?: boolean
    userID?: boolean
    userIDP?: boolean
    userName?: boolean
  }, ExtArgs["result"]["log"]>



  export type LogSelectScalar = {
    id?: boolean
    action?: boolean
    applicationID?: boolean
    eventType?: boolean
    localtime?: boolean
    newProfile?: boolean
    newState?: boolean
    prevProfile?: boolean
    prevState?: boolean
    submissionID?: boolean
    timestamp?: boolean
    userEmail?: boolean
    userID?: boolean
    userIDP?: boolean
    userName?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "applicationID" | "eventDetail" | "eventType" | "localtime" | "newProfile" | "newState" | "prevProfile" | "prevState" | "submissionID" | "timestamp" | "userEmail" | "userID" | "userIDP" | "userName", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string | null
      applicationID: string | null
      eventType: string
      localtime: Date
      newProfile: Prisma.JsonValue | null
      newState: string | null
      prevProfile: Prisma.JsonValue | null
      prevState: string | null
      submissionID: string | null
      timestamp: number
      userEmail: string
      userID: string
      userIDP: string | null
      userName: string | null
    }, ExtArgs["result"]["log"]>
    composites: {
      eventDetail: Prisma.$LogsEventDetailPayload | null
    }
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * @param {LogFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const log = await prisma.log.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LogFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Log.
     * @param {LogAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const log = await prisma.log.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LogAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'String'>
    readonly action: FieldRef<"Log", 'String'>
    readonly applicationID: FieldRef<"Log", 'String'>
    readonly eventType: FieldRef<"Log", 'String'>
    readonly localtime: FieldRef<"Log", 'DateTime'>
    readonly newProfile: FieldRef<"Log", 'Json'>
    readonly newState: FieldRef<"Log", 'String'>
    readonly prevProfile: FieldRef<"Log", 'Json'>
    readonly prevState: FieldRef<"Log", 'String'>
    readonly submissionID: FieldRef<"Log", 'String'>
    readonly timestamp: FieldRef<"Log", 'Float'>
    readonly userEmail: FieldRef<"Log", 'String'>
    readonly userID: FieldRef<"Log", 'String'>
    readonly userIDP: FieldRef<"Log", 'String'>
    readonly userName: FieldRef<"Log", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log findRaw
   */
  export type LogFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Log aggregateRaw
   */
  export type LogAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramMinAggregateOutputType = {
    id: string | null
    abbreviation: string | null
    bucketName: string | null
    conciergeEmail: string | null
    conciergeID: string | null
    conciergeName: string | null
    description: string | null
    name: string | null
    rootPath: string | null
    status: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: string | null
    abbreviation: string | null
    bucketName: string | null
    conciergeEmail: string | null
    conciergeID: string | null
    conciergeName: string | null
    description: string | null
    name: string | null
    rootPath: string | null
    status: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    abbreviation: number
    bucketName: number
    conciergeEmail: number
    conciergeID: number
    conciergeName: number
    description: number
    name: number
    rootPath: number
    status: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type ProgramMinAggregateInputType = {
    id?: true
    abbreviation?: true
    bucketName?: true
    conciergeEmail?: true
    conciergeID?: true
    conciergeName?: true
    description?: true
    name?: true
    rootPath?: true
    status?: true
    createdAt?: true
    updateAt?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    abbreviation?: true
    bucketName?: true
    conciergeEmail?: true
    conciergeID?: true
    conciergeName?: true
    description?: true
    name?: true
    rootPath?: true
    status?: true
    createdAt?: true
    updateAt?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    abbreviation?: true
    bucketName?: true
    conciergeEmail?: true
    conciergeID?: true
    conciergeName?: true
    description?: true
    name?: true
    rootPath?: true
    status?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: string
    abbreviation: string | null
    bucketName: string | null
    conciergeEmail: string | null
    conciergeID: string | null
    conciergeName: string | null
    description: string | null
    name: string
    rootPath: string | null
    status: string
    createdAt: Date
    updateAt: Date
    _count: ProgramCountAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    abbreviation?: boolean
    bucketName?: boolean
    conciergeEmail?: boolean
    conciergeID?: boolean
    conciergeName?: boolean
    description?: boolean
    name?: boolean
    rootPath?: boolean
    status?: boolean
    studies?: boolean | StudyByIDDefaultArgs<ExtArgs>
    createdAt?: boolean
    updateAt?: boolean
    Concierge?: boolean | Program$ConciergeArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>



  export type ProgramSelectScalar = {
    id?: boolean
    abbreviation?: boolean
    bucketName?: boolean
    conciergeEmail?: boolean
    conciergeID?: boolean
    conciergeName?: boolean
    description?: boolean
    name?: boolean
    rootPath?: boolean
    status?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type ProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "abbreviation" | "bucketName" | "conciergeEmail" | "conciergeID" | "conciergeName" | "description" | "name" | "rootPath" | "status" | "studies" | "createdAt" | "updateAt", ExtArgs["result"]["program"]>
  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Concierge?: boolean | Program$ConciergeArgs<ExtArgs>
  }

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      Concierge: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      abbreviation: string | null
      bucketName: string | null
      conciergeEmail: string | null
      conciergeID: string | null
      conciergeName: string | null
      description: string | null
      name: string
      rootPath: string | null
      status: string
      createdAt: Date
      updateAt: Date
    }, ExtArgs["result"]["program"]>
    composites: {
      studies: Prisma.$StudyByIDPayload[]
    }
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Programs that matches the filter.
     * @param {ProgramFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const program = await prisma.program.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProgramFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Program.
     * @param {ProgramAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const program = await prisma.program.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProgramAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Concierge<T extends Program$ConciergeArgs<ExtArgs> = {}>(args?: Subset<T, Program$ConciergeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'String'>
    readonly abbreviation: FieldRef<"Program", 'String'>
    readonly bucketName: FieldRef<"Program", 'String'>
    readonly conciergeEmail: FieldRef<"Program", 'String'>
    readonly conciergeID: FieldRef<"Program", 'String'>
    readonly conciergeName: FieldRef<"Program", 'String'>
    readonly description: FieldRef<"Program", 'String'>
    readonly name: FieldRef<"Program", 'String'>
    readonly rootPath: FieldRef<"Program", 'String'>
    readonly status: FieldRef<"Program", 'String'>
    readonly createdAt: FieldRef<"Program", 'DateTime'>
    readonly updateAt: FieldRef<"Program", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to delete.
     */
    limit?: number
  }

  /**
   * Program findRaw
   */
  export type ProgramFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Program aggregateRaw
   */
  export type ProgramAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Program.Concierge
   */
  export type Program$ConciergeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model QcResult
   */

  export type AggregateQcResult = {
    _count: QcResultCountAggregateOutputType | null
    _avg: QcResultAvgAggregateOutputType | null
    _sum: QcResultSumAggregateOutputType | null
    _min: QcResultMinAggregateOutputType | null
    _max: QcResultMaxAggregateOutputType | null
  }

  export type QcResultAvgAggregateOutputType = {
    displayID: number | null
  }

  export type QcResultSumAggregateOutputType = {
    displayID: number | null
  }

  export type QcResultMinAggregateOutputType = {
    id: string | null
    dataRecordID: string | null
    displayID: number | null
    latestBatchID: string | null
    origin: string | null
    severity: string | null
    submissionID: string | null
    submittedID: string | null
    type: string | null
    uploadedDate: Date | null
    validatedDate: Date | null
    validationType: string | null
  }

  export type QcResultMaxAggregateOutputType = {
    id: string | null
    dataRecordID: string | null
    displayID: number | null
    latestBatchID: string | null
    origin: string | null
    severity: string | null
    submissionID: string | null
    submittedID: string | null
    type: string | null
    uploadedDate: Date | null
    validatedDate: Date | null
    validationType: string | null
  }

  export type QcResultCountAggregateOutputType = {
    id: number
    batchIDs: number
    dataRecordID: number
    displayID: number
    latestBatchID: number
    origin: number
    severity: number
    submissionID: number
    submittedID: number
    type: number
    uploadedDate: number
    validatedDate: number
    validationType: number
    _all: number
  }


  export type QcResultAvgAggregateInputType = {
    displayID?: true
  }

  export type QcResultSumAggregateInputType = {
    displayID?: true
  }

  export type QcResultMinAggregateInputType = {
    id?: true
    dataRecordID?: true
    displayID?: true
    latestBatchID?: true
    origin?: true
    severity?: true
    submissionID?: true
    submittedID?: true
    type?: true
    uploadedDate?: true
    validatedDate?: true
    validationType?: true
  }

  export type QcResultMaxAggregateInputType = {
    id?: true
    dataRecordID?: true
    displayID?: true
    latestBatchID?: true
    origin?: true
    severity?: true
    submissionID?: true
    submittedID?: true
    type?: true
    uploadedDate?: true
    validatedDate?: true
    validationType?: true
  }

  export type QcResultCountAggregateInputType = {
    id?: true
    batchIDs?: true
    dataRecordID?: true
    displayID?: true
    latestBatchID?: true
    origin?: true
    severity?: true
    submissionID?: true
    submittedID?: true
    type?: true
    uploadedDate?: true
    validatedDate?: true
    validationType?: true
    _all?: true
  }

  export type QcResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QcResult to aggregate.
     */
    where?: QcResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcResults to fetch.
     */
    orderBy?: QcResultOrderByWithRelationInput | QcResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QcResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QcResults
    **/
    _count?: true | QcResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QcResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QcResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QcResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QcResultMaxAggregateInputType
  }

  export type GetQcResultAggregateType<T extends QcResultAggregateArgs> = {
        [P in keyof T & keyof AggregateQcResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQcResult[P]>
      : GetScalarType<T[P], AggregateQcResult[P]>
  }




  export type QcResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QcResultWhereInput
    orderBy?: QcResultOrderByWithAggregationInput | QcResultOrderByWithAggregationInput[]
    by: QcResultScalarFieldEnum[] | QcResultScalarFieldEnum
    having?: QcResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QcResultCountAggregateInputType | true
    _avg?: QcResultAvgAggregateInputType
    _sum?: QcResultSumAggregateInputType
    _min?: QcResultMinAggregateInputType
    _max?: QcResultMaxAggregateInputType
  }

  export type QcResultGroupByOutputType = {
    id: string
    batchIDs: string[]
    dataRecordID: string
    displayID: number
    latestBatchID: string
    origin: string | null
    severity: string
    submissionID: string
    submittedID: string
    type: string
    uploadedDate: Date
    validatedDate: Date
    validationType: string
    _count: QcResultCountAggregateOutputType | null
    _avg: QcResultAvgAggregateOutputType | null
    _sum: QcResultSumAggregateOutputType | null
    _min: QcResultMinAggregateOutputType | null
    _max: QcResultMaxAggregateOutputType | null
  }

  type GetQcResultGroupByPayload<T extends QcResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QcResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QcResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QcResultGroupByOutputType[P]>
            : GetScalarType<T[P], QcResultGroupByOutputType[P]>
        }
      >
    >


  export type QcResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchIDs?: boolean
    dataRecordID?: boolean
    displayID?: boolean
    errors?: boolean | ErrorDefaultArgs<ExtArgs>
    latestBatchID?: boolean
    origin?: boolean
    severity?: boolean
    submissionID?: boolean
    submittedID?: boolean
    type?: boolean
    uploadedDate?: boolean
    validatedDate?: boolean
    validationType?: boolean
    warnings?: boolean | ErrorDefaultArgs<ExtArgs>
    submission?: boolean | SubmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qcResult"]>



  export type QcResultSelectScalar = {
    id?: boolean
    batchIDs?: boolean
    dataRecordID?: boolean
    displayID?: boolean
    latestBatchID?: boolean
    origin?: boolean
    severity?: boolean
    submissionID?: boolean
    submittedID?: boolean
    type?: boolean
    uploadedDate?: boolean
    validatedDate?: boolean
    validationType?: boolean
  }

  export type QcResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "batchIDs" | "dataRecordID" | "displayID" | "errors" | "latestBatchID" | "origin" | "severity" | "submissionID" | "submittedID" | "type" | "uploadedDate" | "validatedDate" | "validationType" | "warnings", ExtArgs["result"]["qcResult"]>
  export type QcResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | SubmissionDefaultArgs<ExtArgs>
  }

  export type $QcResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QcResult"
    objects: {
      submission: Prisma.$SubmissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batchIDs: string[]
      dataRecordID: string
      displayID: number
      latestBatchID: string
      origin: string | null
      severity: string
      submissionID: string
      submittedID: string
      type: string
      uploadedDate: Date
      validatedDate: Date
      validationType: string
    }, ExtArgs["result"]["qcResult"]>
    composites: {
      errors: Prisma.$ErrorPayload[]
      warnings: Prisma.$ErrorPayload[]
    }
  }

  type QcResultGetPayload<S extends boolean | null | undefined | QcResultDefaultArgs> = $Result.GetResult<Prisma.$QcResultPayload, S>

  type QcResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QcResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QcResultCountAggregateInputType | true
    }

  export interface QcResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QcResult'], meta: { name: 'QcResult' } }
    /**
     * Find zero or one QcResult that matches the filter.
     * @param {QcResultFindUniqueArgs} args - Arguments to find a QcResult
     * @example
     * // Get one QcResult
     * const qcResult = await prisma.qcResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QcResultFindUniqueArgs>(args: SelectSubset<T, QcResultFindUniqueArgs<ExtArgs>>): Prisma__QcResultClient<$Result.GetResult<Prisma.$QcResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QcResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QcResultFindUniqueOrThrowArgs} args - Arguments to find a QcResult
     * @example
     * // Get one QcResult
     * const qcResult = await prisma.qcResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QcResultFindUniqueOrThrowArgs>(args: SelectSubset<T, QcResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QcResultClient<$Result.GetResult<Prisma.$QcResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultFindFirstArgs} args - Arguments to find a QcResult
     * @example
     * // Get one QcResult
     * const qcResult = await prisma.qcResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QcResultFindFirstArgs>(args?: SelectSubset<T, QcResultFindFirstArgs<ExtArgs>>): Prisma__QcResultClient<$Result.GetResult<Prisma.$QcResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QcResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultFindFirstOrThrowArgs} args - Arguments to find a QcResult
     * @example
     * // Get one QcResult
     * const qcResult = await prisma.qcResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QcResultFindFirstOrThrowArgs>(args?: SelectSubset<T, QcResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__QcResultClient<$Result.GetResult<Prisma.$QcResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QcResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QcResults
     * const qcResults = await prisma.qcResult.findMany()
     * 
     * // Get first 10 QcResults
     * const qcResults = await prisma.qcResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qcResultWithIdOnly = await prisma.qcResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QcResultFindManyArgs>(args?: SelectSubset<T, QcResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QcResult.
     * @param {QcResultCreateArgs} args - Arguments to create a QcResult.
     * @example
     * // Create one QcResult
     * const QcResult = await prisma.qcResult.create({
     *   data: {
     *     // ... data to create a QcResult
     *   }
     * })
     * 
     */
    create<T extends QcResultCreateArgs>(args: SelectSubset<T, QcResultCreateArgs<ExtArgs>>): Prisma__QcResultClient<$Result.GetResult<Prisma.$QcResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QcResults.
     * @param {QcResultCreateManyArgs} args - Arguments to create many QcResults.
     * @example
     * // Create many QcResults
     * const qcResult = await prisma.qcResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QcResultCreateManyArgs>(args?: SelectSubset<T, QcResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QcResult.
     * @param {QcResultDeleteArgs} args - Arguments to delete one QcResult.
     * @example
     * // Delete one QcResult
     * const QcResult = await prisma.qcResult.delete({
     *   where: {
     *     // ... filter to delete one QcResult
     *   }
     * })
     * 
     */
    delete<T extends QcResultDeleteArgs>(args: SelectSubset<T, QcResultDeleteArgs<ExtArgs>>): Prisma__QcResultClient<$Result.GetResult<Prisma.$QcResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QcResult.
     * @param {QcResultUpdateArgs} args - Arguments to update one QcResult.
     * @example
     * // Update one QcResult
     * const qcResult = await prisma.qcResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QcResultUpdateArgs>(args: SelectSubset<T, QcResultUpdateArgs<ExtArgs>>): Prisma__QcResultClient<$Result.GetResult<Prisma.$QcResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QcResults.
     * @param {QcResultDeleteManyArgs} args - Arguments to filter QcResults to delete.
     * @example
     * // Delete a few QcResults
     * const { count } = await prisma.qcResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QcResultDeleteManyArgs>(args?: SelectSubset<T, QcResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QcResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QcResults
     * const qcResult = await prisma.qcResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QcResultUpdateManyArgs>(args: SelectSubset<T, QcResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QcResult.
     * @param {QcResultUpsertArgs} args - Arguments to update or create a QcResult.
     * @example
     * // Update or create a QcResult
     * const qcResult = await prisma.qcResult.upsert({
     *   create: {
     *     // ... data to create a QcResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QcResult we want to update
     *   }
     * })
     */
    upsert<T extends QcResultUpsertArgs>(args: SelectSubset<T, QcResultUpsertArgs<ExtArgs>>): Prisma__QcResultClient<$Result.GetResult<Prisma.$QcResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QcResults that matches the filter.
     * @param {QcResultFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const qcResult = await prisma.qcResult.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: QcResultFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a QcResult.
     * @param {QcResultAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const qcResult = await prisma.qcResult.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: QcResultAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of QcResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultCountArgs} args - Arguments to filter QcResults to count.
     * @example
     * // Count the number of QcResults
     * const count = await prisma.qcResult.count({
     *   where: {
     *     // ... the filter for the QcResults we want to count
     *   }
     * })
    **/
    count<T extends QcResultCountArgs>(
      args?: Subset<T, QcResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QcResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QcResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QcResultAggregateArgs>(args: Subset<T, QcResultAggregateArgs>): Prisma.PrismaPromise<GetQcResultAggregateType<T>>

    /**
     * Group by QcResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QcResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QcResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QcResultGroupByArgs['orderBy'] }
        : { orderBy?: QcResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QcResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQcResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QcResult model
   */
  readonly fields: QcResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QcResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QcResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submission<T extends SubmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubmissionDefaultArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QcResult model
   */
  interface QcResultFieldRefs {
    readonly id: FieldRef<"QcResult", 'String'>
    readonly batchIDs: FieldRef<"QcResult", 'String[]'>
    readonly dataRecordID: FieldRef<"QcResult", 'String'>
    readonly displayID: FieldRef<"QcResult", 'Int'>
    readonly latestBatchID: FieldRef<"QcResult", 'String'>
    readonly origin: FieldRef<"QcResult", 'String'>
    readonly severity: FieldRef<"QcResult", 'String'>
    readonly submissionID: FieldRef<"QcResult", 'String'>
    readonly submittedID: FieldRef<"QcResult", 'String'>
    readonly type: FieldRef<"QcResult", 'String'>
    readonly uploadedDate: FieldRef<"QcResult", 'DateTime'>
    readonly validatedDate: FieldRef<"QcResult", 'DateTime'>
    readonly validationType: FieldRef<"QcResult", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QcResult findUnique
   */
  export type QcResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResult
     */
    select?: QcResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResult
     */
    omit?: QcResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultInclude<ExtArgs> | null
    /**
     * Filter, which QcResult to fetch.
     */
    where: QcResultWhereUniqueInput
  }

  /**
   * QcResult findUniqueOrThrow
   */
  export type QcResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResult
     */
    select?: QcResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResult
     */
    omit?: QcResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultInclude<ExtArgs> | null
    /**
     * Filter, which QcResult to fetch.
     */
    where: QcResultWhereUniqueInput
  }

  /**
   * QcResult findFirst
   */
  export type QcResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResult
     */
    select?: QcResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResult
     */
    omit?: QcResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultInclude<ExtArgs> | null
    /**
     * Filter, which QcResult to fetch.
     */
    where?: QcResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcResults to fetch.
     */
    orderBy?: QcResultOrderByWithRelationInput | QcResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QcResults.
     */
    cursor?: QcResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QcResults.
     */
    distinct?: QcResultScalarFieldEnum | QcResultScalarFieldEnum[]
  }

  /**
   * QcResult findFirstOrThrow
   */
  export type QcResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResult
     */
    select?: QcResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResult
     */
    omit?: QcResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultInclude<ExtArgs> | null
    /**
     * Filter, which QcResult to fetch.
     */
    where?: QcResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcResults to fetch.
     */
    orderBy?: QcResultOrderByWithRelationInput | QcResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QcResults.
     */
    cursor?: QcResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QcResults.
     */
    distinct?: QcResultScalarFieldEnum | QcResultScalarFieldEnum[]
  }

  /**
   * QcResult findMany
   */
  export type QcResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResult
     */
    select?: QcResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResult
     */
    omit?: QcResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultInclude<ExtArgs> | null
    /**
     * Filter, which QcResults to fetch.
     */
    where?: QcResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QcResults to fetch.
     */
    orderBy?: QcResultOrderByWithRelationInput | QcResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QcResults.
     */
    cursor?: QcResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QcResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QcResults.
     */
    skip?: number
    distinct?: QcResultScalarFieldEnum | QcResultScalarFieldEnum[]
  }

  /**
   * QcResult create
   */
  export type QcResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResult
     */
    select?: QcResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResult
     */
    omit?: QcResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultInclude<ExtArgs> | null
    /**
     * The data needed to create a QcResult.
     */
    data: XOR<QcResultCreateInput, QcResultUncheckedCreateInput>
  }

  /**
   * QcResult createMany
   */
  export type QcResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QcResults.
     */
    data: QcResultCreateManyInput | QcResultCreateManyInput[]
  }

  /**
   * QcResult update
   */
  export type QcResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResult
     */
    select?: QcResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResult
     */
    omit?: QcResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultInclude<ExtArgs> | null
    /**
     * The data needed to update a QcResult.
     */
    data: XOR<QcResultUpdateInput, QcResultUncheckedUpdateInput>
    /**
     * Choose, which QcResult to update.
     */
    where: QcResultWhereUniqueInput
  }

  /**
   * QcResult updateMany
   */
  export type QcResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QcResults.
     */
    data: XOR<QcResultUpdateManyMutationInput, QcResultUncheckedUpdateManyInput>
    /**
     * Filter which QcResults to update
     */
    where?: QcResultWhereInput
    /**
     * Limit how many QcResults to update.
     */
    limit?: number
  }

  /**
   * QcResult upsert
   */
  export type QcResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResult
     */
    select?: QcResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResult
     */
    omit?: QcResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultInclude<ExtArgs> | null
    /**
     * The filter to search for the QcResult to update in case it exists.
     */
    where: QcResultWhereUniqueInput
    /**
     * In case the QcResult found by the `where` argument doesn't exist, create a new QcResult with this data.
     */
    create: XOR<QcResultCreateInput, QcResultUncheckedCreateInput>
    /**
     * In case the QcResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QcResultUpdateInput, QcResultUncheckedUpdateInput>
  }

  /**
   * QcResult delete
   */
  export type QcResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResult
     */
    select?: QcResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResult
     */
    omit?: QcResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultInclude<ExtArgs> | null
    /**
     * Filter which QcResult to delete.
     */
    where: QcResultWhereUniqueInput
  }

  /**
   * QcResult deleteMany
   */
  export type QcResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QcResults to delete
     */
    where?: QcResultWhereInput
    /**
     * Limit how many QcResults to delete.
     */
    limit?: number
  }

  /**
   * QcResult findRaw
   */
  export type QcResultFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * QcResult aggregateRaw
   */
  export type QcResultAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * QcResult without action
   */
  export type QcResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResult
     */
    select?: QcResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResult
     */
    omit?: QcResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultInclude<ExtArgs> | null
  }


  /**
   * Model Release
   */

  export type AggregateRelease = {
    _count: ReleaseCountAggregateOutputType | null
    _min: ReleaseMinAggregateOutputType | null
    _max: ReleaseMaxAggregateOutputType | null
  }

  export type ReleaseMinAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    dataCommons: string | null
    entityType: string | null
    nodeID: string | null
    nodeType: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleaseMaxAggregateOutputType = {
    id: string | null
    CRDC_ID: string | null
    dataCommons: string | null
    entityType: string | null
    nodeID: string | null
    nodeType: string | null
    status: string | null
    studyID: string | null
    submissionID: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleaseCountAggregateOutputType = {
    id: number
    CRDC_ID: number
    dataCommons: number
    entityType: number
    nodeID: number
    nodeType: number
    props: number
    status: number
    studyID: number
    submissionID: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReleaseMinAggregateInputType = {
    id?: true
    CRDC_ID?: true
    dataCommons?: true
    entityType?: true
    nodeID?: true
    nodeType?: true
    status?: true
    studyID?: true
    submissionID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleaseMaxAggregateInputType = {
    id?: true
    CRDC_ID?: true
    dataCommons?: true
    entityType?: true
    nodeID?: true
    nodeType?: true
    status?: true
    studyID?: true
    submissionID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleaseCountAggregateInputType = {
    id?: true
    CRDC_ID?: true
    dataCommons?: true
    entityType?: true
    nodeID?: true
    nodeType?: true
    props?: true
    status?: true
    studyID?: true
    submissionID?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReleaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Release to aggregate.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Releases
    **/
    _count?: true | ReleaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReleaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReleaseMaxAggregateInputType
  }

  export type GetReleaseAggregateType<T extends ReleaseAggregateArgs> = {
        [P in keyof T & keyof AggregateRelease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelease[P]>
      : GetScalarType<T[P], AggregateRelease[P]>
  }




  export type ReleaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseWhereInput
    orderBy?: ReleaseOrderByWithAggregationInput | ReleaseOrderByWithAggregationInput[]
    by: ReleaseScalarFieldEnum[] | ReleaseScalarFieldEnum
    having?: ReleaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReleaseCountAggregateInputType | true
    _min?: ReleaseMinAggregateInputType
    _max?: ReleaseMaxAggregateInputType
  }

  export type ReleaseGroupByOutputType = {
    id: string
    CRDC_ID: string | null
    dataCommons: string
    entityType: string | null
    nodeID: string
    nodeType: string
    props: JsonValue
    status: string
    studyID: string | null
    submissionID: string
    createdAt: Date
    updatedAt: Date | null
    _count: ReleaseCountAggregateOutputType | null
    _min: ReleaseMinAggregateOutputType | null
    _max: ReleaseMaxAggregateOutputType | null
  }

  type GetReleaseGroupByPayload<T extends ReleaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReleaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReleaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReleaseGroupByOutputType[P]>
            : GetScalarType<T[P], ReleaseGroupByOutputType[P]>
        }
      >
    >


  export type ReleaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CRDC_ID?: boolean
    dataCommons?: boolean
    entityType?: boolean
    nodeID?: boolean
    nodeType?: boolean
    parents?: boolean | ParentDefaultArgs<ExtArgs>
    props?: boolean
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["release"]>



  export type ReleaseSelectScalar = {
    id?: boolean
    CRDC_ID?: boolean
    dataCommons?: boolean
    entityType?: boolean
    nodeID?: boolean
    nodeType?: boolean
    props?: boolean
    status?: boolean
    studyID?: boolean
    submissionID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReleaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "CRDC_ID" | "dataCommons" | "entityType" | "nodeID" | "nodeType" | "parents" | "props" | "status" | "studyID" | "submissionID" | "createdAt" | "updatedAt", ExtArgs["result"]["release"]>
  export type ReleaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReleasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Release"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      CRDC_ID: string | null
      dataCommons: string
      entityType: string | null
      nodeID: string
      nodeType: string
      props: Prisma.JsonValue
      status: string
      studyID: string | null
      submissionID: string
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["release"]>
    composites: {
      parents: Prisma.$ParentPayload[]
    }
  }

  type ReleaseGetPayload<S extends boolean | null | undefined | ReleaseDefaultArgs> = $Result.GetResult<Prisma.$ReleasePayload, S>

  type ReleaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReleaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReleaseCountAggregateInputType | true
    }

  export interface ReleaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Release'], meta: { name: 'Release' } }
    /**
     * Find zero or one Release that matches the filter.
     * @param {ReleaseFindUniqueArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReleaseFindUniqueArgs>(args: SelectSubset<T, ReleaseFindUniqueArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Release that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReleaseFindUniqueOrThrowArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReleaseFindUniqueOrThrowArgs>(args: SelectSubset<T, ReleaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Release that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseFindFirstArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReleaseFindFirstArgs>(args?: SelectSubset<T, ReleaseFindFirstArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Release that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseFindFirstOrThrowArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReleaseFindFirstOrThrowArgs>(args?: SelectSubset<T, ReleaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Releases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Releases
     * const releases = await prisma.release.findMany()
     * 
     * // Get first 10 Releases
     * const releases = await prisma.release.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const releaseWithIdOnly = await prisma.release.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReleaseFindManyArgs>(args?: SelectSubset<T, ReleaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Release.
     * @param {ReleaseCreateArgs} args - Arguments to create a Release.
     * @example
     * // Create one Release
     * const Release = await prisma.release.create({
     *   data: {
     *     // ... data to create a Release
     *   }
     * })
     * 
     */
    create<T extends ReleaseCreateArgs>(args: SelectSubset<T, ReleaseCreateArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Releases.
     * @param {ReleaseCreateManyArgs} args - Arguments to create many Releases.
     * @example
     * // Create many Releases
     * const release = await prisma.release.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReleaseCreateManyArgs>(args?: SelectSubset<T, ReleaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Release.
     * @param {ReleaseDeleteArgs} args - Arguments to delete one Release.
     * @example
     * // Delete one Release
     * const Release = await prisma.release.delete({
     *   where: {
     *     // ... filter to delete one Release
     *   }
     * })
     * 
     */
    delete<T extends ReleaseDeleteArgs>(args: SelectSubset<T, ReleaseDeleteArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Release.
     * @param {ReleaseUpdateArgs} args - Arguments to update one Release.
     * @example
     * // Update one Release
     * const release = await prisma.release.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReleaseUpdateArgs>(args: SelectSubset<T, ReleaseUpdateArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Releases.
     * @param {ReleaseDeleteManyArgs} args - Arguments to filter Releases to delete.
     * @example
     * // Delete a few Releases
     * const { count } = await prisma.release.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReleaseDeleteManyArgs>(args?: SelectSubset<T, ReleaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Releases
     * const release = await prisma.release.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReleaseUpdateManyArgs>(args: SelectSubset<T, ReleaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Release.
     * @param {ReleaseUpsertArgs} args - Arguments to update or create a Release.
     * @example
     * // Update or create a Release
     * const release = await prisma.release.upsert({
     *   create: {
     *     // ... data to create a Release
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Release we want to update
     *   }
     * })
     */
    upsert<T extends ReleaseUpsertArgs>(args: SelectSubset<T, ReleaseUpsertArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Releases that matches the filter.
     * @param {ReleaseFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const release = await prisma.release.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ReleaseFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Release.
     * @param {ReleaseAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const release = await prisma.release.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ReleaseAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseCountArgs} args - Arguments to filter Releases to count.
     * @example
     * // Count the number of Releases
     * const count = await prisma.release.count({
     *   where: {
     *     // ... the filter for the Releases we want to count
     *   }
     * })
    **/
    count<T extends ReleaseCountArgs>(
      args?: Subset<T, ReleaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReleaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Release.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReleaseAggregateArgs>(args: Subset<T, ReleaseAggregateArgs>): Prisma.PrismaPromise<GetReleaseAggregateType<T>>

    /**
     * Group by Release.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReleaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReleaseGroupByArgs['orderBy'] }
        : { orderBy?: ReleaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReleaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReleaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Release model
   */
  readonly fields: ReleaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Release.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReleaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Release model
   */
  interface ReleaseFieldRefs {
    readonly id: FieldRef<"Release", 'String'>
    readonly CRDC_ID: FieldRef<"Release", 'String'>
    readonly dataCommons: FieldRef<"Release", 'String'>
    readonly entityType: FieldRef<"Release", 'String'>
    readonly nodeID: FieldRef<"Release", 'String'>
    readonly nodeType: FieldRef<"Release", 'String'>
    readonly props: FieldRef<"Release", 'Json'>
    readonly status: FieldRef<"Release", 'String'>
    readonly studyID: FieldRef<"Release", 'String'>
    readonly submissionID: FieldRef<"Release", 'String'>
    readonly createdAt: FieldRef<"Release", 'DateTime'>
    readonly updatedAt: FieldRef<"Release", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Release findUnique
   */
  export type ReleaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release findUniqueOrThrow
   */
  export type ReleaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release findFirst
   */
  export type ReleaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Releases.
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Releases.
     */
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * Release findFirstOrThrow
   */
  export type ReleaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Releases.
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Releases.
     */
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * Release findMany
   */
  export type ReleaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Releases to fetch.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Releases.
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Releases.
     */
    skip?: number
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * Release create
   */
  export type ReleaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Release.
     */
    data: XOR<ReleaseCreateInput, ReleaseUncheckedCreateInput>
  }

  /**
   * Release createMany
   */
  export type ReleaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Releases.
     */
    data: ReleaseCreateManyInput | ReleaseCreateManyInput[]
  }

  /**
   * Release update
   */
  export type ReleaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Release.
     */
    data: XOR<ReleaseUpdateInput, ReleaseUncheckedUpdateInput>
    /**
     * Choose, which Release to update.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release updateMany
   */
  export type ReleaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Releases.
     */
    data: XOR<ReleaseUpdateManyMutationInput, ReleaseUncheckedUpdateManyInput>
    /**
     * Filter which Releases to update
     */
    where?: ReleaseWhereInput
    /**
     * Limit how many Releases to update.
     */
    limit?: number
  }

  /**
   * Release upsert
   */
  export type ReleaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Release to update in case it exists.
     */
    where: ReleaseWhereUniqueInput
    /**
     * In case the Release found by the `where` argument doesn't exist, create a new Release with this data.
     */
    create: XOR<ReleaseCreateInput, ReleaseUncheckedCreateInput>
    /**
     * In case the Release was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReleaseUpdateInput, ReleaseUncheckedUpdateInput>
  }

  /**
   * Release delete
   */
  export type ReleaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter which Release to delete.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release deleteMany
   */
  export type ReleaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Releases to delete
     */
    where?: ReleaseWhereInput
    /**
     * Limit how many Releases to delete.
     */
    limit?: number
  }

  /**
   * Release findRaw
   */
  export type ReleaseFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Release aggregateRaw
   */
  export type ReleaseAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Release without action
   */
  export type ReleaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
  }


  /**
   * Model Submission
   */

  export type AggregateSubmission = {
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  export type SubmissionAvgAggregateOutputType = {
    nodeCount: number | null
  }

  export type SubmissionSumAggregateOutputType = {
    nodeCount: number | null
  }

  export type SubmissionMinAggregateOutputType = {
    id: string | null
    ORCID: string | null
    accessedAt: Date | null
    archived: boolean | null
    bucketName: string | null
    conciergeEmail: string | null
    conciergeName: string | null
    controlledAccess: boolean | null
    crossSubmissionStatus: string | null
    dataCommons: string | null
    dataCommonsDisplayName: string | null
    dataType: string | null
    dbGaPID: string | null
    deletingData: boolean | null
    fileValidationStatus: string | null
    finalInactiveReminder: boolean | null
    inactiveReminder: boolean | null
    inactiveReminder_30: boolean | null
    inactiveReminder_60: boolean | null
    inactiveReminder_7: boolean | null
    intention: string | null
    metadataValidationStatus: string | null
    modelVersion: string | null
    name: string | null
    nodeCount: number | null
    reviewComment: string | null
    rootPath: string | null
    status: string | null
    studyAbbreviation: string | null
    studyID: string | null
    submitterID: string | null
    submitterName: string | null
    validationEnded: Date | null
    validationScope: string | null
    validationStarted: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubmissionMaxAggregateOutputType = {
    id: string | null
    ORCID: string | null
    accessedAt: Date | null
    archived: boolean | null
    bucketName: string | null
    conciergeEmail: string | null
    conciergeName: string | null
    controlledAccess: boolean | null
    crossSubmissionStatus: string | null
    dataCommons: string | null
    dataCommonsDisplayName: string | null
    dataType: string | null
    dbGaPID: string | null
    deletingData: boolean | null
    fileValidationStatus: string | null
    finalInactiveReminder: boolean | null
    inactiveReminder: boolean | null
    inactiveReminder_30: boolean | null
    inactiveReminder_60: boolean | null
    inactiveReminder_7: boolean | null
    intention: string | null
    metadataValidationStatus: string | null
    modelVersion: string | null
    name: string | null
    nodeCount: number | null
    reviewComment: string | null
    rootPath: string | null
    status: string | null
    studyAbbreviation: string | null
    studyID: string | null
    submitterID: string | null
    submitterName: string | null
    validationEnded: Date | null
    validationScope: string | null
    validationStarted: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubmissionCountAggregateOutputType = {
    id: number
    ORCID: number
    accessedAt: number
    archived: number
    bucketName: number
    conciergeEmail: number
    conciergeName: number
    controlledAccess: number
    crossSubmissionStatus: number
    dataCommons: number
    dataCommonsDisplayName: number
    dataType: number
    dbGaPID: number
    deletingData: number
    fileValidationStatus: number
    finalInactiveReminder: number
    inactiveReminder: number
    inactiveReminder_30: number
    inactiveReminder_60: number
    inactiveReminder_7: number
    intention: number
    metadataValidationStatus: number
    modelVersion: number
    name: number
    nodeCount: number
    reviewComment: number
    rootPath: number
    status: number
    studyAbbreviation: number
    studyID: number
    submitterID: number
    submitterName: number
    validationEnded: number
    validationScope: number
    validationStarted: number
    validationType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubmissionAvgAggregateInputType = {
    nodeCount?: true
  }

  export type SubmissionSumAggregateInputType = {
    nodeCount?: true
  }

  export type SubmissionMinAggregateInputType = {
    id?: true
    ORCID?: true
    accessedAt?: true
    archived?: true
    bucketName?: true
    conciergeEmail?: true
    conciergeName?: true
    controlledAccess?: true
    crossSubmissionStatus?: true
    dataCommons?: true
    dataCommonsDisplayName?: true
    dataType?: true
    dbGaPID?: true
    deletingData?: true
    fileValidationStatus?: true
    finalInactiveReminder?: true
    inactiveReminder?: true
    inactiveReminder_30?: true
    inactiveReminder_60?: true
    inactiveReminder_7?: true
    intention?: true
    metadataValidationStatus?: true
    modelVersion?: true
    name?: true
    nodeCount?: true
    reviewComment?: true
    rootPath?: true
    status?: true
    studyAbbreviation?: true
    studyID?: true
    submitterID?: true
    submitterName?: true
    validationEnded?: true
    validationScope?: true
    validationStarted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubmissionMaxAggregateInputType = {
    id?: true
    ORCID?: true
    accessedAt?: true
    archived?: true
    bucketName?: true
    conciergeEmail?: true
    conciergeName?: true
    controlledAccess?: true
    crossSubmissionStatus?: true
    dataCommons?: true
    dataCommonsDisplayName?: true
    dataType?: true
    dbGaPID?: true
    deletingData?: true
    fileValidationStatus?: true
    finalInactiveReminder?: true
    inactiveReminder?: true
    inactiveReminder_30?: true
    inactiveReminder_60?: true
    inactiveReminder_7?: true
    intention?: true
    metadataValidationStatus?: true
    modelVersion?: true
    name?: true
    nodeCount?: true
    reviewComment?: true
    rootPath?: true
    status?: true
    studyAbbreviation?: true
    studyID?: true
    submitterID?: true
    submitterName?: true
    validationEnded?: true
    validationScope?: true
    validationStarted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubmissionCountAggregateInputType = {
    id?: true
    ORCID?: true
    accessedAt?: true
    archived?: true
    bucketName?: true
    conciergeEmail?: true
    conciergeName?: true
    controlledAccess?: true
    crossSubmissionStatus?: true
    dataCommons?: true
    dataCommonsDisplayName?: true
    dataType?: true
    dbGaPID?: true
    deletingData?: true
    fileValidationStatus?: true
    finalInactiveReminder?: true
    inactiveReminder?: true
    inactiveReminder_30?: true
    inactiveReminder_60?: true
    inactiveReminder_7?: true
    intention?: true
    metadataValidationStatus?: true
    modelVersion?: true
    name?: true
    nodeCount?: true
    reviewComment?: true
    rootPath?: true
    status?: true
    studyAbbreviation?: true
    studyID?: true
    submitterID?: true
    submitterName?: true
    validationEnded?: true
    validationScope?: true
    validationStarted?: true
    validationType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submission to aggregate.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Submissions
    **/
    _count?: true | SubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionMaxAggregateInputType
  }

  export type GetSubmissionAggregateType<T extends SubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmission[P]>
      : GetScalarType<T[P], AggregateSubmission[P]>
  }




  export type SubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithAggregationInput | SubmissionOrderByWithAggregationInput[]
    by: SubmissionScalarFieldEnum[] | SubmissionScalarFieldEnum
    having?: SubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionCountAggregateInputType | true
    _avg?: SubmissionAvgAggregateInputType
    _sum?: SubmissionSumAggregateInputType
    _min?: SubmissionMinAggregateInputType
    _max?: SubmissionMaxAggregateInputType
  }

  export type SubmissionGroupByOutputType = {
    id: string
    ORCID: string | null
    accessedAt: Date
    archived: boolean | null
    bucketName: string
    conciergeEmail: string | null
    conciergeName: string | null
    controlledAccess: boolean | null
    crossSubmissionStatus: string | null
    dataCommons: string
    dataCommonsDisplayName: string | null
    dataType: string
    dbGaPID: string | null
    deletingData: boolean | null
    fileValidationStatus: string | null
    finalInactiveReminder: boolean | null
    inactiveReminder: boolean | null
    inactiveReminder_30: boolean | null
    inactiveReminder_60: boolean | null
    inactiveReminder_7: boolean | null
    intention: string
    metadataValidationStatus: string | null
    modelVersion: string
    name: string
    nodeCount: number | null
    reviewComment: string | null
    rootPath: string
    status: string
    studyAbbreviation: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded: Date | null
    validationScope: string | null
    validationStarted: Date | null
    validationType: string[]
    createdAt: Date
    updatedAt: Date
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  type GetSubmissionGroupByPayload<T extends SubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ORCID?: boolean
    accessedAt?: boolean
    archived?: boolean
    bucketName?: boolean
    collaborators?: boolean | CollaboratorDefaultArgs<ExtArgs>
    conciergeEmail?: boolean
    conciergeName?: boolean
    controlledAccess?: boolean
    crossSubmissionStatus?: boolean
    dataCommons?: boolean
    dataCommonsDisplayName?: boolean
    dataFileSize?: boolean | DataFileSizeDefaultArgs<ExtArgs>
    dataType?: boolean
    dbGaPID?: boolean
    deletingData?: boolean
    fileValidationStatus?: boolean
    finalInactiveReminder?: boolean
    history?: boolean | HistoryDefaultArgs<ExtArgs>
    inactiveReminder?: boolean
    inactiveReminder_30?: boolean
    inactiveReminder_60?: boolean
    inactiveReminder_7?: boolean
    intention?: boolean
    metadataValidationStatus?: boolean
    modelVersion?: boolean
    name?: boolean
    nodeCount?: boolean
    organization?: boolean | OrgInfoDefaultArgs<ExtArgs>
    reviewComment?: boolean
    rootPath?: boolean
    status?: boolean
    studyAbbreviation?: boolean
    studyID?: boolean
    submitterID?: boolean
    submitterName?: boolean
    validationEnded?: boolean
    validationScope?: boolean
    validationStarted?: boolean
    validationType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batches?: boolean | Submission$batchesArgs<ExtArgs>
    dataRecords?: boolean | Submission$dataRecordsArgs<ExtArgs>
    qcResults?: boolean | Submission$qcResultsArgs<ExtArgs>
    validations?: boolean | Submission$validationsArgs<ExtArgs>
    _count?: boolean | SubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submission"]>



  export type SubmissionSelectScalar = {
    id?: boolean
    ORCID?: boolean
    accessedAt?: boolean
    archived?: boolean
    bucketName?: boolean
    conciergeEmail?: boolean
    conciergeName?: boolean
    controlledAccess?: boolean
    crossSubmissionStatus?: boolean
    dataCommons?: boolean
    dataCommonsDisplayName?: boolean
    dataType?: boolean
    dbGaPID?: boolean
    deletingData?: boolean
    fileValidationStatus?: boolean
    finalInactiveReminder?: boolean
    inactiveReminder?: boolean
    inactiveReminder_30?: boolean
    inactiveReminder_60?: boolean
    inactiveReminder_7?: boolean
    intention?: boolean
    metadataValidationStatus?: boolean
    modelVersion?: boolean
    name?: boolean
    nodeCount?: boolean
    reviewComment?: boolean
    rootPath?: boolean
    status?: boolean
    studyAbbreviation?: boolean
    studyID?: boolean
    submitterID?: boolean
    submitterName?: boolean
    validationEnded?: boolean
    validationScope?: boolean
    validationStarted?: boolean
    validationType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ORCID" | "accessedAt" | "archived" | "bucketName" | "collaborators" | "conciergeEmail" | "conciergeName" | "controlledAccess" | "crossSubmissionStatus" | "dataCommons" | "dataCommonsDisplayName" | "dataFileSize" | "dataType" | "dbGaPID" | "deletingData" | "fileValidationStatus" | "finalInactiveReminder" | "history" | "inactiveReminder" | "inactiveReminder_30" | "inactiveReminder_60" | "inactiveReminder_7" | "intention" | "metadataValidationStatus" | "modelVersion" | "name" | "nodeCount" | "organization" | "reviewComment" | "rootPath" | "status" | "studyAbbreviation" | "studyID" | "submitterID" | "submitterName" | "validationEnded" | "validationScope" | "validationStarted" | "validationType" | "createdAt" | "updatedAt", ExtArgs["result"]["submission"]>
  export type SubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | Submission$batchesArgs<ExtArgs>
    dataRecords?: boolean | Submission$dataRecordsArgs<ExtArgs>
    qcResults?: boolean | Submission$qcResultsArgs<ExtArgs>
    validations?: boolean | Submission$validationsArgs<ExtArgs>
    _count?: boolean | SubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Submission"
    objects: {
      batches: Prisma.$BatchPayload<ExtArgs>[]
      dataRecords: Prisma.$DataRecordPayload<ExtArgs>[]
      qcResults: Prisma.$QcResultPayload<ExtArgs>[]
      validations: Prisma.$ValidationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ORCID: string | null
      accessedAt: Date
      archived: boolean | null
      bucketName: string
      conciergeEmail: string | null
      conciergeName: string | null
      controlledAccess: boolean | null
      /**
       * Multiple data types found: String: 92.9%, Boolean: 7.1% out of 375 sampled entries
       */
      crossSubmissionStatus: string | null
      dataCommons: string
      dataCommonsDisplayName: string | null
      dataType: string
      dbGaPID: string | null
      deletingData: boolean | null
      /**
       * Multiple data types found: String: 98.5%, Boolean: 1.5% out of 375 sampled entries
       */
      fileValidationStatus: string | null
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      finalInactiveReminder: boolean | null
      inactiveReminder: boolean | null
      inactiveReminder_30: boolean | null
      inactiveReminder_60: boolean | null
      inactiveReminder_7: boolean | null
      intention: string
      /**
       * Multiple data types found: String: 99.5%, Boolean: 0.5% out of 375 sampled entries
       */
      metadataValidationStatus: string | null
      modelVersion: string
      name: string
      nodeCount: number | null
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      reviewComment: string | null
      rootPath: string
      status: string
      studyAbbreviation: string | null
      studyID: string
      submitterID: string
      submitterName: string
      validationEnded: Date | null
      validationScope: string | null
      validationStarted: Date | null
      validationType: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["submission"]>
    composites: {
      collaborators: Prisma.$CollaboratorPayload[]
      dataFileSize: Prisma.$DataFileSizePayload
      history: Prisma.$HistoryPayload[]
      organization: Prisma.$OrgInfoPayload
    }
  }

  type SubmissionGetPayload<S extends boolean | null | undefined | SubmissionDefaultArgs> = $Result.GetResult<Prisma.$SubmissionPayload, S>

  type SubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubmissionCountAggregateInputType | true
    }

  export interface SubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Submission'], meta: { name: 'Submission' } }
    /**
     * Find zero or one Submission that matches the filter.
     * @param {SubmissionFindUniqueArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmissionFindUniqueArgs>(args: SelectSubset<T, SubmissionFindUniqueArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Submission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubmissionFindUniqueOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmissionFindFirstArgs>(args?: SelectSubset<T, SubmissionFindFirstArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Submission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submissions
     * const submissions = await prisma.submission.findMany()
     * 
     * // Get first 10 Submissions
     * const submissions = await prisma.submission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionWithIdOnly = await prisma.submission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubmissionFindManyArgs>(args?: SelectSubset<T, SubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Submission.
     * @param {SubmissionCreateArgs} args - Arguments to create a Submission.
     * @example
     * // Create one Submission
     * const Submission = await prisma.submission.create({
     *   data: {
     *     // ... data to create a Submission
     *   }
     * })
     * 
     */
    create<T extends SubmissionCreateArgs>(args: SelectSubset<T, SubmissionCreateArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Submissions.
     * @param {SubmissionCreateManyArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubmissionCreateManyArgs>(args?: SelectSubset<T, SubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Submission.
     * @param {SubmissionDeleteArgs} args - Arguments to delete one Submission.
     * @example
     * // Delete one Submission
     * const Submission = await prisma.submission.delete({
     *   where: {
     *     // ... filter to delete one Submission
     *   }
     * })
     * 
     */
    delete<T extends SubmissionDeleteArgs>(args: SelectSubset<T, SubmissionDeleteArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Submission.
     * @param {SubmissionUpdateArgs} args - Arguments to update one Submission.
     * @example
     * // Update one Submission
     * const submission = await prisma.submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubmissionUpdateArgs>(args: SelectSubset<T, SubmissionUpdateArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Submissions.
     * @param {SubmissionDeleteManyArgs} args - Arguments to filter Submissions to delete.
     * @example
     * // Delete a few Submissions
     * const { count } = await prisma.submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubmissionDeleteManyArgs>(args?: SelectSubset<T, SubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submissions
     * const submission = await prisma.submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubmissionUpdateManyArgs>(args: SelectSubset<T, SubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Submission.
     * @param {SubmissionUpsertArgs} args - Arguments to update or create a Submission.
     * @example
     * // Update or create a Submission
     * const submission = await prisma.submission.upsert({
     *   create: {
     *     // ... data to create a Submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submission we want to update
     *   }
     * })
     */
    upsert<T extends SubmissionUpsertArgs>(args: SelectSubset<T, SubmissionUpsertArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Submissions that matches the filter.
     * @param {SubmissionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const submission = await prisma.submission.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SubmissionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Submission.
     * @param {SubmissionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const submission = await prisma.submission.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SubmissionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionCountArgs} args - Arguments to filter Submissions to count.
     * @example
     * // Count the number of Submissions
     * const count = await prisma.submission.count({
     *   where: {
     *     // ... the filter for the Submissions we want to count
     *   }
     * })
    **/
    count<T extends SubmissionCountArgs>(
      args?: Subset<T, SubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionAggregateArgs>(args: Subset<T, SubmissionAggregateArgs>): Prisma.PrismaPromise<GetSubmissionAggregateType<T>>

    /**
     * Group by Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Submission model
   */
  readonly fields: SubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batches<T extends Submission$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Submission$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dataRecords<T extends Submission$dataRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Submission$dataRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qcResults<T extends Submission$qcResultsArgs<ExtArgs> = {}>(args?: Subset<T, Submission$qcResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QcResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    validations<T extends Submission$validationsArgs<ExtArgs> = {}>(args?: Subset<T, Submission$validationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Submission model
   */
  interface SubmissionFieldRefs {
    readonly id: FieldRef<"Submission", 'String'>
    readonly ORCID: FieldRef<"Submission", 'String'>
    readonly accessedAt: FieldRef<"Submission", 'DateTime'>
    readonly archived: FieldRef<"Submission", 'Boolean'>
    readonly bucketName: FieldRef<"Submission", 'String'>
    readonly conciergeEmail: FieldRef<"Submission", 'String'>
    readonly conciergeName: FieldRef<"Submission", 'String'>
    readonly controlledAccess: FieldRef<"Submission", 'Boolean'>
    readonly crossSubmissionStatus: FieldRef<"Submission", 'String'>
    readonly dataCommons: FieldRef<"Submission", 'String'>
    readonly dataCommonsDisplayName: FieldRef<"Submission", 'String'>
    readonly dataType: FieldRef<"Submission", 'String'>
    readonly dbGaPID: FieldRef<"Submission", 'String'>
    readonly deletingData: FieldRef<"Submission", 'Boolean'>
    readonly fileValidationStatus: FieldRef<"Submission", 'String'>
    readonly finalInactiveReminder: FieldRef<"Submission", 'Boolean'>
    readonly inactiveReminder: FieldRef<"Submission", 'Boolean'>
    readonly inactiveReminder_30: FieldRef<"Submission", 'Boolean'>
    readonly inactiveReminder_60: FieldRef<"Submission", 'Boolean'>
    readonly inactiveReminder_7: FieldRef<"Submission", 'Boolean'>
    readonly intention: FieldRef<"Submission", 'String'>
    readonly metadataValidationStatus: FieldRef<"Submission", 'String'>
    readonly modelVersion: FieldRef<"Submission", 'String'>
    readonly name: FieldRef<"Submission", 'String'>
    readonly nodeCount: FieldRef<"Submission", 'Int'>
    readonly reviewComment: FieldRef<"Submission", 'String'>
    readonly rootPath: FieldRef<"Submission", 'String'>
    readonly status: FieldRef<"Submission", 'String'>
    readonly studyAbbreviation: FieldRef<"Submission", 'String'>
    readonly studyID: FieldRef<"Submission", 'String'>
    readonly submitterID: FieldRef<"Submission", 'String'>
    readonly submitterName: FieldRef<"Submission", 'String'>
    readonly validationEnded: FieldRef<"Submission", 'DateTime'>
    readonly validationScope: FieldRef<"Submission", 'String'>
    readonly validationStarted: FieldRef<"Submission", 'DateTime'>
    readonly validationType: FieldRef<"Submission", 'String[]'>
    readonly createdAt: FieldRef<"Submission", 'DateTime'>
    readonly updatedAt: FieldRef<"Submission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Submission findUnique
   */
  export type SubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission findUniqueOrThrow
   */
  export type SubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission findFirst
   */
  export type SubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission findFirstOrThrow
   */
  export type SubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission findMany
   */
  export type SubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submissions to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission create
   */
  export type SubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Submission.
     */
    data: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
  }

  /**
   * Submission createMany
   */
  export type SubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[]
  }

  /**
   * Submission update
   */
  export type SubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Submission.
     */
    data: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
    /**
     * Choose, which Submission to update.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission updateMany
   */
  export type SubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Submissions.
     */
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyInput>
    /**
     * Filter which Submissions to update
     */
    where?: SubmissionWhereInput
    /**
     * Limit how many Submissions to update.
     */
    limit?: number
  }

  /**
   * Submission upsert
   */
  export type SubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Submission to update in case it exists.
     */
    where: SubmissionWhereUniqueInput
    /**
     * In case the Submission found by the `where` argument doesn't exist, create a new Submission with this data.
     */
    create: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
    /**
     * In case the Submission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
  }

  /**
   * Submission delete
   */
  export type SubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter which Submission to delete.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission deleteMany
   */
  export type SubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submissions to delete
     */
    where?: SubmissionWhereInput
    /**
     * Limit how many Submissions to delete.
     */
    limit?: number
  }

  /**
   * Submission findRaw
   */
  export type SubmissionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Submission aggregateRaw
   */
  export type SubmissionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Submission.batches
   */
  export type Submission$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Submission.dataRecords
   */
  export type Submission$dataRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRecord
     */
    select?: DataRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataRecord
     */
    omit?: DataRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRecordInclude<ExtArgs> | null
    where?: DataRecordWhereInput
    orderBy?: DataRecordOrderByWithRelationInput | DataRecordOrderByWithRelationInput[]
    cursor?: DataRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataRecordScalarFieldEnum | DataRecordScalarFieldEnum[]
  }

  /**
   * Submission.qcResults
   */
  export type Submission$qcResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QcResult
     */
    select?: QcResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QcResult
     */
    omit?: QcResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QcResultInclude<ExtArgs> | null
    where?: QcResultWhereInput
    orderBy?: QcResultOrderByWithRelationInput | QcResultOrderByWithRelationInput[]
    cursor?: QcResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QcResultScalarFieldEnum | QcResultScalarFieldEnum[]
  }

  /**
   * Submission.validations
   */
  export type Submission$validationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Validation
     */
    omit?: ValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    where?: ValidationWhereInput
    orderBy?: ValidationOrderByWithRelationInput | ValidationOrderByWithRelationInput[]
    cursor?: ValidationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * Submission without action
   */
  export type SubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Synonym
   */

  export type AggregateSynonym = {
    _count: SynonymCountAggregateOutputType | null
    _min: SynonymMinAggregateOutputType | null
    _max: SynonymMaxAggregateOutputType | null
  }

  export type SynonymMinAggregateOutputType = {
    id: string | null
    equivalent_term: string | null
    synonym_term: string | null
  }

  export type SynonymMaxAggregateOutputType = {
    id: string | null
    equivalent_term: string | null
    synonym_term: string | null
  }

  export type SynonymCountAggregateOutputType = {
    id: number
    equivalent_term: number
    synonym_term: number
    _all: number
  }


  export type SynonymMinAggregateInputType = {
    id?: true
    equivalent_term?: true
    synonym_term?: true
  }

  export type SynonymMaxAggregateInputType = {
    id?: true
    equivalent_term?: true
    synonym_term?: true
  }

  export type SynonymCountAggregateInputType = {
    id?: true
    equivalent_term?: true
    synonym_term?: true
    _all?: true
  }

  export type SynonymAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Synonym to aggregate.
     */
    where?: SynonymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Synonyms to fetch.
     */
    orderBy?: SynonymOrderByWithRelationInput | SynonymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SynonymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Synonyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Synonyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Synonyms
    **/
    _count?: true | SynonymCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SynonymMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SynonymMaxAggregateInputType
  }

  export type GetSynonymAggregateType<T extends SynonymAggregateArgs> = {
        [P in keyof T & keyof AggregateSynonym]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSynonym[P]>
      : GetScalarType<T[P], AggregateSynonym[P]>
  }




  export type SynonymGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SynonymWhereInput
    orderBy?: SynonymOrderByWithAggregationInput | SynonymOrderByWithAggregationInput[]
    by: SynonymScalarFieldEnum[] | SynonymScalarFieldEnum
    having?: SynonymScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SynonymCountAggregateInputType | true
    _min?: SynonymMinAggregateInputType
    _max?: SynonymMaxAggregateInputType
  }

  export type SynonymGroupByOutputType = {
    id: string
    equivalent_term: string
    synonym_term: string
    _count: SynonymCountAggregateOutputType | null
    _min: SynonymMinAggregateOutputType | null
    _max: SynonymMaxAggregateOutputType | null
  }

  type GetSynonymGroupByPayload<T extends SynonymGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SynonymGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SynonymGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SynonymGroupByOutputType[P]>
            : GetScalarType<T[P], SynonymGroupByOutputType[P]>
        }
      >
    >


  export type SynonymSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equivalent_term?: boolean
    synonym_term?: boolean
  }, ExtArgs["result"]["synonym"]>



  export type SynonymSelectScalar = {
    id?: boolean
    equivalent_term?: boolean
    synonym_term?: boolean
  }

  export type SynonymOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equivalent_term" | "synonym_term", ExtArgs["result"]["synonym"]>

  export type $SynonymPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Synonym"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      /**
       * Multiple data types found: String: 47.5%, String (ObjectId): 52.5% out of 1000 sampled entries
       */
      id: string
      equivalent_term: string
      synonym_term: string
    }, ExtArgs["result"]["synonym"]>
    composites: {}
  }

  type SynonymGetPayload<S extends boolean | null | undefined | SynonymDefaultArgs> = $Result.GetResult<Prisma.$SynonymPayload, S>

  type SynonymCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SynonymFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SynonymCountAggregateInputType | true
    }

  export interface SynonymDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Synonym'], meta: { name: 'Synonym' } }
    /**
     * Find zero or one Synonym that matches the filter.
     * @param {SynonymFindUniqueArgs} args - Arguments to find a Synonym
     * @example
     * // Get one Synonym
     * const synonym = await prisma.synonym.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SynonymFindUniqueArgs>(args: SelectSubset<T, SynonymFindUniqueArgs<ExtArgs>>): Prisma__SynonymClient<$Result.GetResult<Prisma.$SynonymPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Synonym that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SynonymFindUniqueOrThrowArgs} args - Arguments to find a Synonym
     * @example
     * // Get one Synonym
     * const synonym = await prisma.synonym.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SynonymFindUniqueOrThrowArgs>(args: SelectSubset<T, SynonymFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SynonymClient<$Result.GetResult<Prisma.$SynonymPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Synonym that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SynonymFindFirstArgs} args - Arguments to find a Synonym
     * @example
     * // Get one Synonym
     * const synonym = await prisma.synonym.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SynonymFindFirstArgs>(args?: SelectSubset<T, SynonymFindFirstArgs<ExtArgs>>): Prisma__SynonymClient<$Result.GetResult<Prisma.$SynonymPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Synonym that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SynonymFindFirstOrThrowArgs} args - Arguments to find a Synonym
     * @example
     * // Get one Synonym
     * const synonym = await prisma.synonym.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SynonymFindFirstOrThrowArgs>(args?: SelectSubset<T, SynonymFindFirstOrThrowArgs<ExtArgs>>): Prisma__SynonymClient<$Result.GetResult<Prisma.$SynonymPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Synonyms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SynonymFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Synonyms
     * const synonyms = await prisma.synonym.findMany()
     * 
     * // Get first 10 Synonyms
     * const synonyms = await prisma.synonym.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const synonymWithIdOnly = await prisma.synonym.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SynonymFindManyArgs>(args?: SelectSubset<T, SynonymFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SynonymPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Synonym.
     * @param {SynonymCreateArgs} args - Arguments to create a Synonym.
     * @example
     * // Create one Synonym
     * const Synonym = await prisma.synonym.create({
     *   data: {
     *     // ... data to create a Synonym
     *   }
     * })
     * 
     */
    create<T extends SynonymCreateArgs>(args: SelectSubset<T, SynonymCreateArgs<ExtArgs>>): Prisma__SynonymClient<$Result.GetResult<Prisma.$SynonymPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Synonyms.
     * @param {SynonymCreateManyArgs} args - Arguments to create many Synonyms.
     * @example
     * // Create many Synonyms
     * const synonym = await prisma.synonym.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SynonymCreateManyArgs>(args?: SelectSubset<T, SynonymCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Synonym.
     * @param {SynonymDeleteArgs} args - Arguments to delete one Synonym.
     * @example
     * // Delete one Synonym
     * const Synonym = await prisma.synonym.delete({
     *   where: {
     *     // ... filter to delete one Synonym
     *   }
     * })
     * 
     */
    delete<T extends SynonymDeleteArgs>(args: SelectSubset<T, SynonymDeleteArgs<ExtArgs>>): Prisma__SynonymClient<$Result.GetResult<Prisma.$SynonymPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Synonym.
     * @param {SynonymUpdateArgs} args - Arguments to update one Synonym.
     * @example
     * // Update one Synonym
     * const synonym = await prisma.synonym.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SynonymUpdateArgs>(args: SelectSubset<T, SynonymUpdateArgs<ExtArgs>>): Prisma__SynonymClient<$Result.GetResult<Prisma.$SynonymPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Synonyms.
     * @param {SynonymDeleteManyArgs} args - Arguments to filter Synonyms to delete.
     * @example
     * // Delete a few Synonyms
     * const { count } = await prisma.synonym.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SynonymDeleteManyArgs>(args?: SelectSubset<T, SynonymDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Synonyms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SynonymUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Synonyms
     * const synonym = await prisma.synonym.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SynonymUpdateManyArgs>(args: SelectSubset<T, SynonymUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Synonym.
     * @param {SynonymUpsertArgs} args - Arguments to update or create a Synonym.
     * @example
     * // Update or create a Synonym
     * const synonym = await prisma.synonym.upsert({
     *   create: {
     *     // ... data to create a Synonym
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Synonym we want to update
     *   }
     * })
     */
    upsert<T extends SynonymUpsertArgs>(args: SelectSubset<T, SynonymUpsertArgs<ExtArgs>>): Prisma__SynonymClient<$Result.GetResult<Prisma.$SynonymPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Synonyms that matches the filter.
     * @param {SynonymFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const synonym = await prisma.synonym.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SynonymFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Synonym.
     * @param {SynonymAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const synonym = await prisma.synonym.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SynonymAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Synonyms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SynonymCountArgs} args - Arguments to filter Synonyms to count.
     * @example
     * // Count the number of Synonyms
     * const count = await prisma.synonym.count({
     *   where: {
     *     // ... the filter for the Synonyms we want to count
     *   }
     * })
    **/
    count<T extends SynonymCountArgs>(
      args?: Subset<T, SynonymCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SynonymCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Synonym.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SynonymAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SynonymAggregateArgs>(args: Subset<T, SynonymAggregateArgs>): Prisma.PrismaPromise<GetSynonymAggregateType<T>>

    /**
     * Group by Synonym.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SynonymGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SynonymGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SynonymGroupByArgs['orderBy'] }
        : { orderBy?: SynonymGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SynonymGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSynonymGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Synonym model
   */
  readonly fields: SynonymFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Synonym.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SynonymClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Synonym model
   */
  interface SynonymFieldRefs {
    readonly id: FieldRef<"Synonym", 'String'>
    readonly equivalent_term: FieldRef<"Synonym", 'String'>
    readonly synonym_term: FieldRef<"Synonym", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Synonym findUnique
   */
  export type SynonymFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Synonym
     */
    select?: SynonymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Synonym
     */
    omit?: SynonymOmit<ExtArgs> | null
    /**
     * Filter, which Synonym to fetch.
     */
    where: SynonymWhereUniqueInput
  }

  /**
   * Synonym findUniqueOrThrow
   */
  export type SynonymFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Synonym
     */
    select?: SynonymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Synonym
     */
    omit?: SynonymOmit<ExtArgs> | null
    /**
     * Filter, which Synonym to fetch.
     */
    where: SynonymWhereUniqueInput
  }

  /**
   * Synonym findFirst
   */
  export type SynonymFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Synonym
     */
    select?: SynonymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Synonym
     */
    omit?: SynonymOmit<ExtArgs> | null
    /**
     * Filter, which Synonym to fetch.
     */
    where?: SynonymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Synonyms to fetch.
     */
    orderBy?: SynonymOrderByWithRelationInput | SynonymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Synonyms.
     */
    cursor?: SynonymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Synonyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Synonyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Synonyms.
     */
    distinct?: SynonymScalarFieldEnum | SynonymScalarFieldEnum[]
  }

  /**
   * Synonym findFirstOrThrow
   */
  export type SynonymFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Synonym
     */
    select?: SynonymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Synonym
     */
    omit?: SynonymOmit<ExtArgs> | null
    /**
     * Filter, which Synonym to fetch.
     */
    where?: SynonymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Synonyms to fetch.
     */
    orderBy?: SynonymOrderByWithRelationInput | SynonymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Synonyms.
     */
    cursor?: SynonymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Synonyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Synonyms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Synonyms.
     */
    distinct?: SynonymScalarFieldEnum | SynonymScalarFieldEnum[]
  }

  /**
   * Synonym findMany
   */
  export type SynonymFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Synonym
     */
    select?: SynonymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Synonym
     */
    omit?: SynonymOmit<ExtArgs> | null
    /**
     * Filter, which Synonyms to fetch.
     */
    where?: SynonymWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Synonyms to fetch.
     */
    orderBy?: SynonymOrderByWithRelationInput | SynonymOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Synonyms.
     */
    cursor?: SynonymWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Synonyms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Synonyms.
     */
    skip?: number
    distinct?: SynonymScalarFieldEnum | SynonymScalarFieldEnum[]
  }

  /**
   * Synonym create
   */
  export type SynonymCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Synonym
     */
    select?: SynonymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Synonym
     */
    omit?: SynonymOmit<ExtArgs> | null
    /**
     * The data needed to create a Synonym.
     */
    data: XOR<SynonymCreateInput, SynonymUncheckedCreateInput>
  }

  /**
   * Synonym createMany
   */
  export type SynonymCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Synonyms.
     */
    data: SynonymCreateManyInput | SynonymCreateManyInput[]
  }

  /**
   * Synonym update
   */
  export type SynonymUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Synonym
     */
    select?: SynonymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Synonym
     */
    omit?: SynonymOmit<ExtArgs> | null
    /**
     * The data needed to update a Synonym.
     */
    data: XOR<SynonymUpdateInput, SynonymUncheckedUpdateInput>
    /**
     * Choose, which Synonym to update.
     */
    where: SynonymWhereUniqueInput
  }

  /**
   * Synonym updateMany
   */
  export type SynonymUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Synonyms.
     */
    data: XOR<SynonymUpdateManyMutationInput, SynonymUncheckedUpdateManyInput>
    /**
     * Filter which Synonyms to update
     */
    where?: SynonymWhereInput
    /**
     * Limit how many Synonyms to update.
     */
    limit?: number
  }

  /**
   * Synonym upsert
   */
  export type SynonymUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Synonym
     */
    select?: SynonymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Synonym
     */
    omit?: SynonymOmit<ExtArgs> | null
    /**
     * The filter to search for the Synonym to update in case it exists.
     */
    where: SynonymWhereUniqueInput
    /**
     * In case the Synonym found by the `where` argument doesn't exist, create a new Synonym with this data.
     */
    create: XOR<SynonymCreateInput, SynonymUncheckedCreateInput>
    /**
     * In case the Synonym was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SynonymUpdateInput, SynonymUncheckedUpdateInput>
  }

  /**
   * Synonym delete
   */
  export type SynonymDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Synonym
     */
    select?: SynonymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Synonym
     */
    omit?: SynonymOmit<ExtArgs> | null
    /**
     * Filter which Synonym to delete.
     */
    where: SynonymWhereUniqueInput
  }

  /**
   * Synonym deleteMany
   */
  export type SynonymDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Synonyms to delete
     */
    where?: SynonymWhereInput
    /**
     * Limit how many Synonyms to delete.
     */
    limit?: number
  }

  /**
   * Synonym findRaw
   */
  export type SynonymFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Synonym aggregateRaw
   */
  export type SynonymAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Synonym without action
   */
  export type SynonymDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Synonym
     */
    select?: SynonymSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Synonym
     */
    omit?: SynonymOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    IDP: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    status: string | null
    userStatus: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    IDP: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    status: string | null
    userStatus: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    IDP: number
    dataCommons: number
    email: number
    firstName: number
    lastName: number
    notifications: number
    permissions: number
    role: number
    status: number
    tokens: number
    userStatus: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    IDP?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    userStatus?: true
    createdAt?: true
    updateAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    IDP?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    userStatus?: true
    createdAt?: true
    updateAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    IDP?: true
    dataCommons?: true
    email?: true
    firstName?: true
    lastName?: true
    notifications?: true
    permissions?: true
    role?: true
    status?: true
    tokens?: true
    userStatus?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    IDP: string
    dataCommons: string[]
    email: string
    firstName: string
    lastName: string
    notifications: string[]
    permissions: string[]
    role: string
    status: string | null
    tokens: string[]
    userStatus: string
    createdAt: Date
    updateAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    IDP?: boolean
    dataCommons?: boolean
    email?: boolean
    firstName?: boolean
    institution?: boolean | InstitutionInfoDefaultArgs<ExtArgs>
    lastName?: boolean
    notifications?: boolean
    organization?: boolean | OrgInfoDefaultArgs<ExtArgs>
    permissions?: boolean
    role?: boolean
    status?: boolean
    studies?: boolean | StudyByIDDefaultArgs<ExtArgs>
    tokens?: boolean
    userStatus?: boolean
    createdAt?: boolean
    updateAt?: boolean
    programs?: boolean | User$programsArgs<ExtArgs>
    approvedStudies?: boolean | User$approvedStudiesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    IDP?: boolean
    dataCommons?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    notifications?: boolean
    permissions?: boolean
    role?: boolean
    status?: boolean
    tokens?: boolean
    userStatus?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "IDP" | "dataCommons" | "email" | "firstName" | "institution" | "lastName" | "notifications" | "organization" | "permissions" | "role" | "status" | "studies" | "tokens" | "userStatus" | "createdAt" | "updateAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programs?: boolean | User$programsArgs<ExtArgs>
    approvedStudies?: boolean | User$approvedStudiesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      programs: Prisma.$ProgramPayload<ExtArgs>[]
      approvedStudies: Prisma.$ApprovedStudyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      IDP: string
      /**
       * Multiple data types found: String: 14.6%, DateTime (Date): 85.4% out of 48 sampled entries
       */
      dataCommons: string[]
      email: string
      firstName: string
      lastName: string
      notifications: string[]
      permissions: string[]
      role: string
      status: string | null
      tokens: string[]
      userStatus: string
      createdAt: Date
      /**
       * Multiple data types found: String: 2.1%, DateTime (Date): 97.9% out of 48 sampled entries
       */
      updateAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {
      institution: Prisma.$InstitutionInfoPayload | null
      organization: Prisma.$OrgInfoPayload | null
      studies: Prisma.$StudyByIDPayload[]
    }
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    programs<T extends User$programsArgs<ExtArgs> = {}>(args?: Subset<T, User$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedStudies<T extends User$approvedStudiesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedStudiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovedStudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly IDP: FieldRef<"User", 'String'>
    readonly dataCommons: FieldRef<"User", 'String[]'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly notifications: FieldRef<"User", 'String[]'>
    readonly permissions: FieldRef<"User", 'String[]'>
    readonly role: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly tokens: FieldRef<"User", 'String[]'>
    readonly userStatus: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updateAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.programs
   */
  export type User$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    cursor?: ProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * User.approvedStudies
   */
  export type User$approvedStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovedStudy
     */
    select?: ApprovedStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovedStudy
     */
    omit?: ApprovedStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovedStudyInclude<ExtArgs> | null
    where?: ApprovedStudyWhereInput
    orderBy?: ApprovedStudyOrderByWithRelationInput | ApprovedStudyOrderByWithRelationInput[]
    cursor?: ApprovedStudyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovedStudyScalarFieldEnum | ApprovedStudyScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Validation
   */

  export type AggregateValidation = {
    _count: ValidationCountAggregateOutputType | null
    _min: ValidationMinAggregateOutputType | null
    _max: ValidationMaxAggregateOutputType | null
  }

  export type ValidationMinAggregateOutputType = {
    id: string | null
    ended: Date | null
    scope: string | null
    started: Date | null
    status: string | null
    submissionID: string | null
  }

  export type ValidationMaxAggregateOutputType = {
    id: string | null
    ended: Date | null
    scope: string | null
    started: Date | null
    status: string | null
    submissionID: string | null
  }

  export type ValidationCountAggregateOutputType = {
    id: number
    ended: number
    scope: number
    started: number
    status: number
    submissionID: number
    type: number
    _all: number
  }


  export type ValidationMinAggregateInputType = {
    id?: true
    ended?: true
    scope?: true
    started?: true
    status?: true
    submissionID?: true
  }

  export type ValidationMaxAggregateInputType = {
    id?: true
    ended?: true
    scope?: true
    started?: true
    status?: true
    submissionID?: true
  }

  export type ValidationCountAggregateInputType = {
    id?: true
    ended?: true
    scope?: true
    started?: true
    status?: true
    submissionID?: true
    type?: true
    _all?: true
  }

  export type ValidationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Validation to aggregate.
     */
    where?: ValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Validations to fetch.
     */
    orderBy?: ValidationOrderByWithRelationInput | ValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Validations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Validations
    **/
    _count?: true | ValidationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ValidationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ValidationMaxAggregateInputType
  }

  export type GetValidationAggregateType<T extends ValidationAggregateArgs> = {
        [P in keyof T & keyof AggregateValidation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValidation[P]>
      : GetScalarType<T[P], AggregateValidation[P]>
  }




  export type ValidationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValidationWhereInput
    orderBy?: ValidationOrderByWithAggregationInput | ValidationOrderByWithAggregationInput[]
    by: ValidationScalarFieldEnum[] | ValidationScalarFieldEnum
    having?: ValidationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ValidationCountAggregateInputType | true
    _min?: ValidationMinAggregateInputType
    _max?: ValidationMaxAggregateInputType
  }

  export type ValidationGroupByOutputType = {
    id: string
    ended: Date | null
    scope: string | null
    started: Date
    status: string | null
    submissionID: string
    type: string[]
    _count: ValidationCountAggregateOutputType | null
    _min: ValidationMinAggregateOutputType | null
    _max: ValidationMaxAggregateOutputType | null
  }

  type GetValidationGroupByPayload<T extends ValidationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ValidationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ValidationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ValidationGroupByOutputType[P]>
            : GetScalarType<T[P], ValidationGroupByOutputType[P]>
        }
      >
    >


  export type ValidationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ended?: boolean
    scope?: boolean
    started?: boolean
    status?: boolean
    submissionID?: boolean
    type?: boolean
    submission?: boolean | SubmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["validation"]>



  export type ValidationSelectScalar = {
    id?: boolean
    ended?: boolean
    scope?: boolean
    started?: boolean
    status?: boolean
    submissionID?: boolean
    type?: boolean
  }

  export type ValidationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ended" | "scope" | "started" | "status" | "submissionID" | "type", ExtArgs["result"]["validation"]>
  export type ValidationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | SubmissionDefaultArgs<ExtArgs>
  }

  export type $ValidationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Validation"
    objects: {
      submission: Prisma.$SubmissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ended: Date | null
      scope: string | null
      started: Date
      status: string | null
      submissionID: string
      type: string[]
    }, ExtArgs["result"]["validation"]>
    composites: {}
  }

  type ValidationGetPayload<S extends boolean | null | undefined | ValidationDefaultArgs> = $Result.GetResult<Prisma.$ValidationPayload, S>

  type ValidationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ValidationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ValidationCountAggregateInputType | true
    }

  export interface ValidationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Validation'], meta: { name: 'Validation' } }
    /**
     * Find zero or one Validation that matches the filter.
     * @param {ValidationFindUniqueArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ValidationFindUniqueArgs>(args: SelectSubset<T, ValidationFindUniqueArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Validation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ValidationFindUniqueOrThrowArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ValidationFindUniqueOrThrowArgs>(args: SelectSubset<T, ValidationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Validation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationFindFirstArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ValidationFindFirstArgs>(args?: SelectSubset<T, ValidationFindFirstArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Validation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationFindFirstOrThrowArgs} args - Arguments to find a Validation
     * @example
     * // Get one Validation
     * const validation = await prisma.validation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ValidationFindFirstOrThrowArgs>(args?: SelectSubset<T, ValidationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Validations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Validations
     * const validations = await prisma.validation.findMany()
     * 
     * // Get first 10 Validations
     * const validations = await prisma.validation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const validationWithIdOnly = await prisma.validation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ValidationFindManyArgs>(args?: SelectSubset<T, ValidationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Validation.
     * @param {ValidationCreateArgs} args - Arguments to create a Validation.
     * @example
     * // Create one Validation
     * const Validation = await prisma.validation.create({
     *   data: {
     *     // ... data to create a Validation
     *   }
     * })
     * 
     */
    create<T extends ValidationCreateArgs>(args: SelectSubset<T, ValidationCreateArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Validations.
     * @param {ValidationCreateManyArgs} args - Arguments to create many Validations.
     * @example
     * // Create many Validations
     * const validation = await prisma.validation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ValidationCreateManyArgs>(args?: SelectSubset<T, ValidationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Validation.
     * @param {ValidationDeleteArgs} args - Arguments to delete one Validation.
     * @example
     * // Delete one Validation
     * const Validation = await prisma.validation.delete({
     *   where: {
     *     // ... filter to delete one Validation
     *   }
     * })
     * 
     */
    delete<T extends ValidationDeleteArgs>(args: SelectSubset<T, ValidationDeleteArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Validation.
     * @param {ValidationUpdateArgs} args - Arguments to update one Validation.
     * @example
     * // Update one Validation
     * const validation = await prisma.validation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ValidationUpdateArgs>(args: SelectSubset<T, ValidationUpdateArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Validations.
     * @param {ValidationDeleteManyArgs} args - Arguments to filter Validations to delete.
     * @example
     * // Delete a few Validations
     * const { count } = await prisma.validation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ValidationDeleteManyArgs>(args?: SelectSubset<T, ValidationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Validations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Validations
     * const validation = await prisma.validation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ValidationUpdateManyArgs>(args: SelectSubset<T, ValidationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Validation.
     * @param {ValidationUpsertArgs} args - Arguments to update or create a Validation.
     * @example
     * // Update or create a Validation
     * const validation = await prisma.validation.upsert({
     *   create: {
     *     // ... data to create a Validation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Validation we want to update
     *   }
     * })
     */
    upsert<T extends ValidationUpsertArgs>(args: SelectSubset<T, ValidationUpsertArgs<ExtArgs>>): Prisma__ValidationClient<$Result.GetResult<Prisma.$ValidationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Validations that matches the filter.
     * @param {ValidationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const validation = await prisma.validation.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ValidationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Validation.
     * @param {ValidationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const validation = await prisma.validation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ValidationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Validations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationCountArgs} args - Arguments to filter Validations to count.
     * @example
     * // Count the number of Validations
     * const count = await prisma.validation.count({
     *   where: {
     *     // ... the filter for the Validations we want to count
     *   }
     * })
    **/
    count<T extends ValidationCountArgs>(
      args?: Subset<T, ValidationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ValidationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Validation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ValidationAggregateArgs>(args: Subset<T, ValidationAggregateArgs>): Prisma.PrismaPromise<GetValidationAggregateType<T>>

    /**
     * Group by Validation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ValidationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ValidationGroupByArgs['orderBy'] }
        : { orderBy?: ValidationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ValidationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetValidationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Validation model
   */
  readonly fields: ValidationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Validation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ValidationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submission<T extends SubmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubmissionDefaultArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Validation model
   */
  interface ValidationFieldRefs {
    readonly id: FieldRef<"Validation", 'String'>
    readonly ended: FieldRef<"Validation", 'DateTime'>
    readonly scope: FieldRef<"Validation", 'String'>
    readonly started: FieldRef<"Validation", 'DateTime'>
    readonly status: FieldRef<"Validation", 'String'>
    readonly submissionID: FieldRef<"Validation", 'String'>
    readonly type: FieldRef<"Validation", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Validation findUnique
   */
  export type ValidationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Validation
     */
    omit?: ValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter, which Validation to fetch.
     */
    where: ValidationWhereUniqueInput
  }

  /**
   * Validation findUniqueOrThrow
   */
  export type ValidationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Validation
     */
    omit?: ValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter, which Validation to fetch.
     */
    where: ValidationWhereUniqueInput
  }

  /**
   * Validation findFirst
   */
  export type ValidationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Validation
     */
    omit?: ValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter, which Validation to fetch.
     */
    where?: ValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Validations to fetch.
     */
    orderBy?: ValidationOrderByWithRelationInput | ValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Validations.
     */
    cursor?: ValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Validations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Validations.
     */
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * Validation findFirstOrThrow
   */
  export type ValidationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Validation
     */
    omit?: ValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter, which Validation to fetch.
     */
    where?: ValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Validations to fetch.
     */
    orderBy?: ValidationOrderByWithRelationInput | ValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Validations.
     */
    cursor?: ValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Validations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Validations.
     */
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * Validation findMany
   */
  export type ValidationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Validation
     */
    omit?: ValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter, which Validations to fetch.
     */
    where?: ValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Validations to fetch.
     */
    orderBy?: ValidationOrderByWithRelationInput | ValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Validations.
     */
    cursor?: ValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Validations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Validations.
     */
    skip?: number
    distinct?: ValidationScalarFieldEnum | ValidationScalarFieldEnum[]
  }

  /**
   * Validation create
   */
  export type ValidationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Validation
     */
    omit?: ValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * The data needed to create a Validation.
     */
    data: XOR<ValidationCreateInput, ValidationUncheckedCreateInput>
  }

  /**
   * Validation createMany
   */
  export type ValidationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Validations.
     */
    data: ValidationCreateManyInput | ValidationCreateManyInput[]
  }

  /**
   * Validation update
   */
  export type ValidationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Validation
     */
    omit?: ValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * The data needed to update a Validation.
     */
    data: XOR<ValidationUpdateInput, ValidationUncheckedUpdateInput>
    /**
     * Choose, which Validation to update.
     */
    where: ValidationWhereUniqueInput
  }

  /**
   * Validation updateMany
   */
  export type ValidationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Validations.
     */
    data: XOR<ValidationUpdateManyMutationInput, ValidationUncheckedUpdateManyInput>
    /**
     * Filter which Validations to update
     */
    where?: ValidationWhereInput
    /**
     * Limit how many Validations to update.
     */
    limit?: number
  }

  /**
   * Validation upsert
   */
  export type ValidationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Validation
     */
    omit?: ValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * The filter to search for the Validation to update in case it exists.
     */
    where: ValidationWhereUniqueInput
    /**
     * In case the Validation found by the `where` argument doesn't exist, create a new Validation with this data.
     */
    create: XOR<ValidationCreateInput, ValidationUncheckedCreateInput>
    /**
     * In case the Validation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ValidationUpdateInput, ValidationUncheckedUpdateInput>
  }

  /**
   * Validation delete
   */
  export type ValidationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Validation
     */
    omit?: ValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
    /**
     * Filter which Validation to delete.
     */
    where: ValidationWhereUniqueInput
  }

  /**
   * Validation deleteMany
   */
  export type ValidationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Validations to delete
     */
    where?: ValidationWhereInput
    /**
     * Limit how many Validations to delete.
     */
    limit?: number
  }

  /**
   * Validation findRaw
   */
  export type ValidationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Validation aggregateRaw
   */
  export type ValidationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Validation without action
   */
  export type ValidationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Validation
     */
    select?: ValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Validation
     */
    omit?: ValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const CDEScalarFieldEnum: {
    id: 'id',
    CDECode: 'CDECode',
    CDEFullName: 'CDEFullName',
    CDEVersion: 'CDEVersion',
    PermissibleValues: 'PermissibleValues',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CDEScalarFieldEnum = (typeof CDEScalarFieldEnum)[keyof typeof CDEScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    id: 'id',
    version: 'version',
    ORCID: 'ORCID',
    PI: 'PI',
    controlledAccess: 'controlledAccess',
    inactiveReminder: 'inactiveReminder',
    openAccess: 'openAccess',
    programAbbreviation: 'programAbbreviation',
    programDescription: 'programDescription',
    programName: 'programName',
    questionnaireData: 'questionnaireData',
    reviewComment: 'reviewComment',
    status: 'status',
    studyAbbreviation: 'studyAbbreviation',
    studyName: 'studyName',
    submittedDate: 'submittedDate',
    wholeProgram: 'wholeProgram',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const ApprovedStudyScalarFieldEnum: {
    id: 'id',
    ORCID: 'ORCID',
    PI: 'PI',
    controlledAccess: 'controlledAccess',
    dbGaPID: 'dbGaPID',
    openAccess: 'openAccess',
    originalOrg: 'originalOrg',
    primaryContactID: 'primaryContactID',
    programName: 'programName',
    studyAbbreviation: 'studyAbbreviation',
    studyName: 'studyName',
    useProgramPC: 'useProgramPC',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApprovedStudyScalarFieldEnum = (typeof ApprovedStudyScalarFieldEnum)[keyof typeof ApprovedStudyScalarFieldEnum]


  export const BatchScalarFieldEnum: {
    id: 'id',
    bucketName: 'bucketName',
    displayID: 'displayID',
    errors: 'errors',
    fileCount: 'fileCount',
    filePrefix: 'filePrefix',
    status: 'status',
    submissionID: 'submissionID',
    submitterID: 'submitterID',
    submitterName: 'submitterName',
    type: 'type',
    zipFileName: 'zipFileName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchScalarFieldEnum = (typeof BatchScalarFieldEnum)[keyof typeof BatchScalarFieldEnum]


  export const ConfigurationScalarFieldEnum: {
    id: 'id',
    COMPLETED_RETENTION_DAYS: 'COMPLETED_RETENTION_DAYS',
    DASHBOARD_SESSION_TIMEOUT: 'DASHBOARD_SESSION_TIMEOUT',
    EMAIL_URL: 'EMAIL_URL',
    INACTIVE_APPLICATION_DAYS: 'INACTIVE_APPLICATION_DAYS',
    INACTIVE_SUBMISSION_DAYS_DELETE: 'INACTIVE_SUBMISSION_DAYS_DELETE',
    INACTIVE_USER_DAYS: 'INACTIVE_USER_DAYS',
    OFFICIAL_EMAIL: 'OFFICIAL_EMAIL',
    PRESIGN_EXPIRATION: 'PRESIGN_EXPIRATION',
    PROD_URL: 'PROD_URL',
    REMIND_APPLICATION_DAYS: 'REMIND_APPLICATION_DAYS',
    REVIEW_COMMITTEE_EMAIL: 'REVIEW_COMMITTEE_EMAIL',
    ROLE_TIMEOUT: 'ROLE_TIMEOUT',
    SCHEDULED_JOBS: 'SCHEDULED_JOBS',
    SUBMISSION_BUCKET: 'SUBMISSION_BUCKET',
    SUBMISSION_HELPDESK: 'SUBMISSION_HELPDESK',
    SUBMISSION_REQUEST_CONTACT_EMAIL: 'SUBMISSION_REQUEST_CONTACT_EMAIL',
    SUBMISSION_SYSTEM_PORTAL: 'SUBMISSION_SYSTEM_PORTAL',
    TECH_SUPPORT_EMAIL: 'TECH_SUPPORT_EMAIL',
    age: 'age',
    bucketName: 'bucketName',
    current: 'current',
    current_version: 'current_version',
    dashboardID: 'dashboardID',
    dataCommons: 'dataCommons',
    days: 'days',
    interval: 'interval',
    key: 'key',
    keys: 'keys',
    new: 'new',
    prefix: 'prefix',
    timeout: 'timeout',
    type: 'type',
    version: 'version'
  };

  export type ConfigurationScalarFieldEnum = (typeof ConfigurationScalarFieldEnum)[keyof typeof ConfigurationScalarFieldEnum]


  export const DataRecordScalarFieldEnum: {
    id: 'id',
    CRDC_ID: 'CRDC_ID',
    IDPropName: 'IDPropName',
    batchIDs: 'batchIDs',
    dataCommons: 'dataCommons',
    entityType: 'entityType',
    latestBatchDisplayID: 'latestBatchDisplayID',
    latestBatchID: 'latestBatchID',
    lineNumber: 'lineNumber',
    nodeID: 'nodeID',
    nodeType: 'nodeType',
    orginalFileName: 'orginalFileName',
    props: 'props',
    qcResultID: 'qcResultID',
    rawData: 'rawData',
    status: 'status',
    studyID: 'studyID',
    submissionID: 'submissionID',
    uploadedDate: 'uploadedDate',
    validatedAt: 'validatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataRecordScalarFieldEnum = (typeof DataRecordScalarFieldEnum)[keyof typeof DataRecordScalarFieldEnum]


  export const DataRecordsArchivedScalarFieldEnum: {
    id: 'id',
    CRDC_ID: 'CRDC_ID',
    IDPropName: 'IDPropName',
    batchIDs: 'batchIDs',
    dataCommons: 'dataCommons',
    entityType: 'entityType',
    latestBatchDisplayID: 'latestBatchDisplayID',
    latestBatchID: 'latestBatchID',
    lineNumber: 'lineNumber',
    nodeID: 'nodeID',
    nodeType: 'nodeType',
    orginalFileName: 'orginalFileName',
    props: 'props',
    qcResultID: 'qcResultID',
    rawData: 'rawData',
    status: 'status',
    studyID: 'studyID',
    submissionID: 'submissionID',
    uploadedDate: 'uploadedDate',
    validatedAt: 'validatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataRecordsArchivedScalarFieldEnum = (typeof DataRecordsArchivedScalarFieldEnum)[keyof typeof DataRecordsArchivedScalarFieldEnum]


  export const FileMD5ScalarFieldEnum: {
    id: 'id',
    LastModified: 'LastModified',
    fileName: 'fileName',
    md5: 'md5',
    submissionID: 'submissionID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FileMD5ScalarFieldEnum = (typeof FileMD5ScalarFieldEnum)[keyof typeof FileMD5ScalarFieldEnum]


  export const InstitutionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    submitterCount: 'submitterCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstitutionScalarFieldEnum = (typeof InstitutionScalarFieldEnum)[keyof typeof InstitutionScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    applicationID: 'applicationID',
    eventType: 'eventType',
    localtime: 'localtime',
    newProfile: 'newProfile',
    newState: 'newState',
    prevProfile: 'prevProfile',
    prevState: 'prevState',
    submissionID: 'submissionID',
    timestamp: 'timestamp',
    userEmail: 'userEmail',
    userID: 'userID',
    userIDP: 'userIDP',
    userName: 'userName'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    abbreviation: 'abbreviation',
    bucketName: 'bucketName',
    conciergeEmail: 'conciergeEmail',
    conciergeID: 'conciergeID',
    conciergeName: 'conciergeName',
    description: 'description',
    name: 'name',
    rootPath: 'rootPath',
    status: 'status',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const QcResultScalarFieldEnum: {
    id: 'id',
    batchIDs: 'batchIDs',
    dataRecordID: 'dataRecordID',
    displayID: 'displayID',
    latestBatchID: 'latestBatchID',
    origin: 'origin',
    severity: 'severity',
    submissionID: 'submissionID',
    submittedID: 'submittedID',
    type: 'type',
    uploadedDate: 'uploadedDate',
    validatedDate: 'validatedDate',
    validationType: 'validationType'
  };

  export type QcResultScalarFieldEnum = (typeof QcResultScalarFieldEnum)[keyof typeof QcResultScalarFieldEnum]


  export const ReleaseScalarFieldEnum: {
    id: 'id',
    CRDC_ID: 'CRDC_ID',
    dataCommons: 'dataCommons',
    entityType: 'entityType',
    nodeID: 'nodeID',
    nodeType: 'nodeType',
    props: 'props',
    status: 'status',
    studyID: 'studyID',
    submissionID: 'submissionID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReleaseScalarFieldEnum = (typeof ReleaseScalarFieldEnum)[keyof typeof ReleaseScalarFieldEnum]


  export const SubmissionScalarFieldEnum: {
    id: 'id',
    ORCID: 'ORCID',
    accessedAt: 'accessedAt',
    archived: 'archived',
    bucketName: 'bucketName',
    conciergeEmail: 'conciergeEmail',
    conciergeName: 'conciergeName',
    controlledAccess: 'controlledAccess',
    crossSubmissionStatus: 'crossSubmissionStatus',
    dataCommons: 'dataCommons',
    dataCommonsDisplayName: 'dataCommonsDisplayName',
    dataType: 'dataType',
    dbGaPID: 'dbGaPID',
    deletingData: 'deletingData',
    fileValidationStatus: 'fileValidationStatus',
    finalInactiveReminder: 'finalInactiveReminder',
    inactiveReminder: 'inactiveReminder',
    inactiveReminder_30: 'inactiveReminder_30',
    inactiveReminder_60: 'inactiveReminder_60',
    inactiveReminder_7: 'inactiveReminder_7',
    intention: 'intention',
    metadataValidationStatus: 'metadataValidationStatus',
    modelVersion: 'modelVersion',
    name: 'name',
    nodeCount: 'nodeCount',
    reviewComment: 'reviewComment',
    rootPath: 'rootPath',
    status: 'status',
    studyAbbreviation: 'studyAbbreviation',
    studyID: 'studyID',
    submitterID: 'submitterID',
    submitterName: 'submitterName',
    validationEnded: 'validationEnded',
    validationScope: 'validationScope',
    validationStarted: 'validationStarted',
    validationType: 'validationType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubmissionScalarFieldEnum = (typeof SubmissionScalarFieldEnum)[keyof typeof SubmissionScalarFieldEnum]


  export const SynonymScalarFieldEnum: {
    id: 'id',
    equivalent_term: 'equivalent_term',
    synonym_term: 'synonym_term'
  };

  export type SynonymScalarFieldEnum = (typeof SynonymScalarFieldEnum)[keyof typeof SynonymScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    IDP: 'IDP',
    dataCommons: 'dataCommons',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    notifications: 'notifications',
    permissions: 'permissions',
    role: 'role',
    status: 'status',
    tokens: 'tokens',
    userStatus: 'userStatus',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ValidationScalarFieldEnum: {
    id: 'id',
    ended: 'ended',
    scope: 'scope',
    started: 'started',
    status: 'status',
    submissionID: 'submissionID',
    type: 'type'
  };

  export type ValidationScalarFieldEnum = (typeof ValidationScalarFieldEnum)[keyof typeof ValidationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CDEWhereInput = {
    AND?: CDEWhereInput | CDEWhereInput[]
    OR?: CDEWhereInput[]
    NOT?: CDEWhereInput | CDEWhereInput[]
    id?: StringFilter<"CDE"> | string
    CDECode?: StringFilter<"CDE"> | string
    CDEFullName?: StringFilter<"CDE"> | string
    CDEVersion?: StringNullableFilter<"CDE"> | string | null
    PermissibleValues?: StringNullableListFilter<"CDE">
    createdAt?: DateTimeFilter<"CDE"> | Date | string
    updatedAt?: DateTimeFilter<"CDE"> | Date | string
  }

  export type CDEOrderByWithRelationInput = {
    id?: SortOrder
    CDECode?: SortOrder
    CDEFullName?: SortOrder
    CDEVersion?: SortOrder
    PermissibleValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CDEWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CDEWhereInput | CDEWhereInput[]
    OR?: CDEWhereInput[]
    NOT?: CDEWhereInput | CDEWhereInput[]
    CDECode?: StringFilter<"CDE"> | string
    CDEFullName?: StringFilter<"CDE"> | string
    CDEVersion?: StringNullableFilter<"CDE"> | string | null
    PermissibleValues?: StringNullableListFilter<"CDE">
    createdAt?: DateTimeFilter<"CDE"> | Date | string
    updatedAt?: DateTimeFilter<"CDE"> | Date | string
  }, "id">

  export type CDEOrderByWithAggregationInput = {
    id?: SortOrder
    CDECode?: SortOrder
    CDEFullName?: SortOrder
    CDEVersion?: SortOrder
    PermissibleValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CDECountOrderByAggregateInput
    _max?: CDEMaxOrderByAggregateInput
    _min?: CDEMinOrderByAggregateInput
  }

  export type CDEScalarWhereWithAggregatesInput = {
    AND?: CDEScalarWhereWithAggregatesInput | CDEScalarWhereWithAggregatesInput[]
    OR?: CDEScalarWhereWithAggregatesInput[]
    NOT?: CDEScalarWhereWithAggregatesInput | CDEScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CDE"> | string
    CDECode?: StringWithAggregatesFilter<"CDE"> | string
    CDEFullName?: StringWithAggregatesFilter<"CDE"> | string
    CDEVersion?: StringNullableWithAggregatesFilter<"CDE"> | string | null
    PermissibleValues?: StringNullableListFilter<"CDE">
    createdAt?: DateTimeWithAggregatesFilter<"CDE"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CDE"> | Date | string
  }

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    id?: StringFilter<"Application"> | string
    version?: StringFilter<"Application"> | string
    ORCID?: StringNullableFilter<"Application"> | string | null
    PI?: StringNullableFilter<"Application"> | string | null
    applicant?: XOR<ApplicantCompositeFilter, ApplicantObjectEqualityInput>
    controlledAccess?: BoolNullableFilter<"Application"> | boolean | null
    history?: HistoryCompositeListFilter | HistoryObjectEqualityInput[]
    inactiveReminder?: BoolNullableFilter<"Application"> | boolean | null
    openAccess?: BoolNullableFilter<"Application"> | boolean | null
    organization?: XOR<OrgInfoCompositeFilter, OrgInfoObjectEqualityInput>
    programAbbreviation?: StringNullableFilter<"Application"> | string | null
    programDescription?: StringNullableFilter<"Application"> | string | null
    programName?: StringFilter<"Application"> | string
    questionnaireData?: StringFilter<"Application"> | string
    reviewComment?: StringNullableFilter<"Application"> | string | null
    status?: StringFilter<"Application"> | string
    studyAbbreviation?: StringFilter<"Application"> | string
    studyName?: StringFilter<"Application"> | string
    submittedDate?: DateTimeNullableFilter<"Application"> | Date | string | null
    wholeProgram?: BoolNullableFilter<"Application"> | boolean | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
  }

  export type ApplicationOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    applicant?: ApplicantOrderByInput
    controlledAccess?: SortOrder
    history?: HistoryOrderByCompositeAggregateInput
    inactiveReminder?: SortOrder
    openAccess?: SortOrder
    organization?: OrgInfoOrderByInput
    programAbbreviation?: SortOrder
    programDescription?: SortOrder
    programName?: SortOrder
    questionnaireData?: SortOrder
    reviewComment?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    submittedDate?: SortOrder
    wholeProgram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    version?: StringFilter<"Application"> | string
    ORCID?: StringNullableFilter<"Application"> | string | null
    PI?: StringNullableFilter<"Application"> | string | null
    applicant?: XOR<ApplicantCompositeFilter, ApplicantObjectEqualityInput>
    controlledAccess?: BoolNullableFilter<"Application"> | boolean | null
    history?: HistoryCompositeListFilter | HistoryObjectEqualityInput[]
    inactiveReminder?: BoolNullableFilter<"Application"> | boolean | null
    openAccess?: BoolNullableFilter<"Application"> | boolean | null
    organization?: XOR<OrgInfoCompositeFilter, OrgInfoObjectEqualityInput>
    programAbbreviation?: StringNullableFilter<"Application"> | string | null
    programDescription?: StringNullableFilter<"Application"> | string | null
    programName?: StringFilter<"Application"> | string
    questionnaireData?: StringFilter<"Application"> | string
    reviewComment?: StringNullableFilter<"Application"> | string | null
    status?: StringFilter<"Application"> | string
    studyAbbreviation?: StringFilter<"Application"> | string
    studyName?: StringFilter<"Application"> | string
    submittedDate?: DateTimeNullableFilter<"Application"> | Date | string | null
    wholeProgram?: BoolNullableFilter<"Application"> | boolean | null
    createdAt?: DateTimeFilter<"Application"> | Date | string
    updatedAt?: DateTimeFilter<"Application"> | Date | string
  }, "id">

  export type ApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    inactiveReminder?: SortOrder
    openAccess?: SortOrder
    programAbbreviation?: SortOrder
    programDescription?: SortOrder
    programName?: SortOrder
    questionnaireData?: SortOrder
    reviewComment?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    submittedDate?: SortOrder
    wholeProgram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApplicationCountOrderByAggregateInput
    _max?: ApplicationMaxOrderByAggregateInput
    _min?: ApplicationMinOrderByAggregateInput
  }

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    OR?: ApplicationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Application"> | string
    version?: StringWithAggregatesFilter<"Application"> | string
    ORCID?: StringNullableWithAggregatesFilter<"Application"> | string | null
    PI?: StringNullableWithAggregatesFilter<"Application"> | string | null
    controlledAccess?: BoolNullableWithAggregatesFilter<"Application"> | boolean | null
    inactiveReminder?: BoolNullableWithAggregatesFilter<"Application"> | boolean | null
    openAccess?: BoolNullableWithAggregatesFilter<"Application"> | boolean | null
    programAbbreviation?: StringNullableWithAggregatesFilter<"Application"> | string | null
    programDescription?: StringNullableWithAggregatesFilter<"Application"> | string | null
    programName?: StringWithAggregatesFilter<"Application"> | string
    questionnaireData?: StringWithAggregatesFilter<"Application"> | string
    reviewComment?: StringNullableWithAggregatesFilter<"Application"> | string | null
    status?: StringWithAggregatesFilter<"Application"> | string
    studyAbbreviation?: StringWithAggregatesFilter<"Application"> | string
    studyName?: StringWithAggregatesFilter<"Application"> | string
    submittedDate?: DateTimeNullableWithAggregatesFilter<"Application"> | Date | string | null
    wholeProgram?: BoolNullableWithAggregatesFilter<"Application"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Application"> | Date | string
  }

  export type ApprovedStudyWhereInput = {
    AND?: ApprovedStudyWhereInput | ApprovedStudyWhereInput[]
    OR?: ApprovedStudyWhereInput[]
    NOT?: ApprovedStudyWhereInput | ApprovedStudyWhereInput[]
    id?: StringFilter<"ApprovedStudy"> | string
    ORCID?: StringNullableFilter<"ApprovedStudy"> | string | null
    PI?: StringNullableFilter<"ApprovedStudy"> | string | null
    controlledAccess?: BoolFilter<"ApprovedStudy"> | boolean
    dbGaPID?: StringNullableFilter<"ApprovedStudy"> | string | null
    openAccess?: BoolNullableFilter<"ApprovedStudy"> | boolean | null
    originalOrg?: StringNullableFilter<"ApprovedStudy"> | string | null
    primaryContactID?: StringNullableFilter<"ApprovedStudy"> | string | null
    programName?: StringNullableFilter<"ApprovedStudy"> | string | null
    studyAbbreviation?: StringFilter<"ApprovedStudy"> | string
    studyName?: StringFilter<"ApprovedStudy"> | string
    useProgramPC?: BoolNullableFilter<"ApprovedStudy"> | boolean | null
    createdAt?: DateTimeFilter<"ApprovedStudy"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovedStudy"> | Date | string
    Concierge?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ApprovedStudyOrderByWithRelationInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    dbGaPID?: SortOrder
    openAccess?: SortOrder
    originalOrg?: SortOrder
    primaryContactID?: SortOrder
    programName?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    useProgramPC?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Concierge?: UserOrderByWithRelationInput
  }

  export type ApprovedStudyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApprovedStudyWhereInput | ApprovedStudyWhereInput[]
    OR?: ApprovedStudyWhereInput[]
    NOT?: ApprovedStudyWhereInput | ApprovedStudyWhereInput[]
    ORCID?: StringNullableFilter<"ApprovedStudy"> | string | null
    PI?: StringNullableFilter<"ApprovedStudy"> | string | null
    controlledAccess?: BoolFilter<"ApprovedStudy"> | boolean
    dbGaPID?: StringNullableFilter<"ApprovedStudy"> | string | null
    openAccess?: BoolNullableFilter<"ApprovedStudy"> | boolean | null
    originalOrg?: StringNullableFilter<"ApprovedStudy"> | string | null
    primaryContactID?: StringNullableFilter<"ApprovedStudy"> | string | null
    programName?: StringNullableFilter<"ApprovedStudy"> | string | null
    studyAbbreviation?: StringFilter<"ApprovedStudy"> | string
    studyName?: StringFilter<"ApprovedStudy"> | string
    useProgramPC?: BoolNullableFilter<"ApprovedStudy"> | boolean | null
    createdAt?: DateTimeFilter<"ApprovedStudy"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovedStudy"> | Date | string
    Concierge?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ApprovedStudyOrderByWithAggregationInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    dbGaPID?: SortOrder
    openAccess?: SortOrder
    originalOrg?: SortOrder
    primaryContactID?: SortOrder
    programName?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    useProgramPC?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApprovedStudyCountOrderByAggregateInput
    _max?: ApprovedStudyMaxOrderByAggregateInput
    _min?: ApprovedStudyMinOrderByAggregateInput
  }

  export type ApprovedStudyScalarWhereWithAggregatesInput = {
    AND?: ApprovedStudyScalarWhereWithAggregatesInput | ApprovedStudyScalarWhereWithAggregatesInput[]
    OR?: ApprovedStudyScalarWhereWithAggregatesInput[]
    NOT?: ApprovedStudyScalarWhereWithAggregatesInput | ApprovedStudyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovedStudy"> | string
    ORCID?: StringNullableWithAggregatesFilter<"ApprovedStudy"> | string | null
    PI?: StringNullableWithAggregatesFilter<"ApprovedStudy"> | string | null
    controlledAccess?: BoolWithAggregatesFilter<"ApprovedStudy"> | boolean
    dbGaPID?: StringNullableWithAggregatesFilter<"ApprovedStudy"> | string | null
    openAccess?: BoolNullableWithAggregatesFilter<"ApprovedStudy"> | boolean | null
    originalOrg?: StringNullableWithAggregatesFilter<"ApprovedStudy"> | string | null
    primaryContactID?: StringNullableWithAggregatesFilter<"ApprovedStudy"> | string | null
    programName?: StringNullableWithAggregatesFilter<"ApprovedStudy"> | string | null
    studyAbbreviation?: StringWithAggregatesFilter<"ApprovedStudy"> | string
    studyName?: StringWithAggregatesFilter<"ApprovedStudy"> | string
    useProgramPC?: BoolNullableWithAggregatesFilter<"ApprovedStudy"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"ApprovedStudy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApprovedStudy"> | Date | string
  }

  export type BatchWhereInput = {
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    id?: StringFilter<"Batch"> | string
    bucketName?: StringFilter<"Batch"> | string
    displayID?: IntFilter<"Batch"> | number
    errors?: StringNullableListFilter<"Batch">
    fileCount?: IntFilter<"Batch"> | number
    filePrefix?: StringFilter<"Batch"> | string
    files?: BatchFilesCompositeListFilter | BatchFilesObjectEqualityInput[]
    status?: StringFilter<"Batch"> | string
    submissionID?: StringFilter<"Batch"> | string
    submitterID?: StringNullableFilter<"Batch"> | string | null
    submitterName?: StringNullableFilter<"Batch"> | string | null
    type?: StringFilter<"Batch"> | string
    zipFileName?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    submission?: XOR<SubmissionScalarRelationFilter, SubmissionWhereInput>
  }

  export type BatchOrderByWithRelationInput = {
    id?: SortOrder
    bucketName?: SortOrder
    displayID?: SortOrder
    errors?: SortOrder
    fileCount?: SortOrder
    filePrefix?: SortOrder
    files?: BatchFilesOrderByCompositeAggregateInput
    status?: SortOrder
    submissionID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    type?: SortOrder
    zipFileName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submission?: SubmissionOrderByWithRelationInput
  }

  export type BatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    bucketName?: StringFilter<"Batch"> | string
    displayID?: IntFilter<"Batch"> | number
    errors?: StringNullableListFilter<"Batch">
    fileCount?: IntFilter<"Batch"> | number
    filePrefix?: StringFilter<"Batch"> | string
    files?: BatchFilesCompositeListFilter | BatchFilesObjectEqualityInput[]
    status?: StringFilter<"Batch"> | string
    submissionID?: StringFilter<"Batch"> | string
    submitterID?: StringNullableFilter<"Batch"> | string | null
    submitterName?: StringNullableFilter<"Batch"> | string | null
    type?: StringFilter<"Batch"> | string
    zipFileName?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    submission?: XOR<SubmissionScalarRelationFilter, SubmissionWhereInput>
  }, "id">

  export type BatchOrderByWithAggregationInput = {
    id?: SortOrder
    bucketName?: SortOrder
    displayID?: SortOrder
    errors?: SortOrder
    fileCount?: SortOrder
    filePrefix?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    type?: SortOrder
    zipFileName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BatchCountOrderByAggregateInput
    _avg?: BatchAvgOrderByAggregateInput
    _max?: BatchMaxOrderByAggregateInput
    _min?: BatchMinOrderByAggregateInput
    _sum?: BatchSumOrderByAggregateInput
  }

  export type BatchScalarWhereWithAggregatesInput = {
    AND?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    OR?: BatchScalarWhereWithAggregatesInput[]
    NOT?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Batch"> | string
    bucketName?: StringWithAggregatesFilter<"Batch"> | string
    displayID?: IntWithAggregatesFilter<"Batch"> | number
    errors?: StringNullableListFilter<"Batch">
    fileCount?: IntWithAggregatesFilter<"Batch"> | number
    filePrefix?: StringWithAggregatesFilter<"Batch"> | string
    status?: StringWithAggregatesFilter<"Batch"> | string
    submissionID?: StringWithAggregatesFilter<"Batch"> | string
    submitterID?: StringNullableWithAggregatesFilter<"Batch"> | string | null
    submitterName?: StringNullableWithAggregatesFilter<"Batch"> | string | null
    type?: StringWithAggregatesFilter<"Batch"> | string
    zipFileName?: StringNullableWithAggregatesFilter<"Batch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
  }

  export type ConfigurationWhereInput = {
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    id?: StringFilter<"Configuration"> | string
    COMPLETED_RETENTION_DAYS?: IntNullableFilter<"Configuration"> | number | null
    DASHBOARD_SESSION_TIMEOUT?: IntNullableFilter<"Configuration"> | number | null
    Defaults?: PBACDefaultsCompositeListFilter | PBACDefaultsObjectEqualityInput[]
    EMAIL_URL?: StringNullableFilter<"Configuration"> | string | null
    INACTIVE_APPLICATION_DAYS?: IntNullableFilter<"Configuration"> | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: IntNullableFilter<"Configuration"> | number | null
    INACTIVE_USER_DAYS?: IntNullableFilter<"Configuration"> | number | null
    OFFICIAL_EMAIL?: StringNullableFilter<"Configuration"> | string | null
    PRESIGN_EXPIRATION?: IntNullableFilter<"Configuration"> | number | null
    PROD_URL?: StringNullableFilter<"Configuration"> | string | null
    REMIND_APPLICATION_DAYS?: IntNullableFilter<"Configuration"> | number | null
    REVIEW_COMMITTEE_EMAIL?: StringNullableListFilter<"Configuration">
    ROLE_TIMEOUT?: IntNullableFilter<"Configuration"> | number | null
    SCHEDULED_JOBS?: StringNullableFilter<"Configuration"> | string | null
    SUBMISSION_BUCKET?: StringNullableFilter<"Configuration"> | string | null
    SUBMISSION_HELPDESK?: StringNullableFilter<"Configuration"> | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: StringNullableFilter<"Configuration"> | string | null
    SUBMISSION_SYSTEM_PORTAL?: StringNullableFilter<"Configuration"> | string | null
    TECH_SUPPORT_EMAIL?: StringNullableFilter<"Configuration"> | string | null
    age?: IntNullableFilter<"Configuration"> | number | null
    bucketName?: StringNullableFilter<"Configuration"> | string | null
    current?: StringNullableFilter<"Configuration"> | string | null
    current_version?: StringNullableFilter<"Configuration"> | string | null
    dashboardID?: StringNullableFilter<"Configuration"> | string | null
    dataCommons?: StringNullableFilter<"Configuration"> | string | null
    days?: IntNullableFilter<"Configuration"> | number | null
    interval?: IntNullableFilter<"Configuration"> | number | null
    key?: StringNullableListFilter<"Configuration">
    keys?: JsonNullableFilter<"Configuration">
    new?: StringNullableFilter<"Configuration"> | string | null
    prefix?: StringNullableFilter<"Configuration"> | string | null
    tag?: XOR<ConfigurationTagNullableCompositeFilter, ConfigurationTagObjectEqualityInput> | null
    timeout?: IntNullableFilter<"Configuration"> | number | null
    type?: StringFilter<"Configuration"> | string
    version?: StringNullableFilter<"Configuration"> | string | null
  }

  export type ConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    Defaults?: PBACDefaultsOrderByCompositeAggregateInput
    EMAIL_URL?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    OFFICIAL_EMAIL?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    PROD_URL?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    REVIEW_COMMITTEE_EMAIL?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    SCHEDULED_JOBS?: SortOrder
    SUBMISSION_BUCKET?: SortOrder
    SUBMISSION_HELPDESK?: SortOrder
    SUBMISSION_REQUEST_CONTACT_EMAIL?: SortOrder
    SUBMISSION_SYSTEM_PORTAL?: SortOrder
    TECH_SUPPORT_EMAIL?: SortOrder
    age?: SortOrder
    bucketName?: SortOrder
    current?: SortOrder
    current_version?: SortOrder
    dashboardID?: SortOrder
    dataCommons?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    key?: SortOrder
    keys?: SortOrder
    new?: SortOrder
    prefix?: SortOrder
    tag?: ConfigurationTagOrderByInput
    timeout?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type ConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    COMPLETED_RETENTION_DAYS?: IntNullableFilter<"Configuration"> | number | null
    DASHBOARD_SESSION_TIMEOUT?: IntNullableFilter<"Configuration"> | number | null
    Defaults?: PBACDefaultsCompositeListFilter | PBACDefaultsObjectEqualityInput[]
    EMAIL_URL?: StringNullableFilter<"Configuration"> | string | null
    INACTIVE_APPLICATION_DAYS?: IntNullableFilter<"Configuration"> | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: IntNullableFilter<"Configuration"> | number | null
    INACTIVE_USER_DAYS?: IntNullableFilter<"Configuration"> | number | null
    OFFICIAL_EMAIL?: StringNullableFilter<"Configuration"> | string | null
    PRESIGN_EXPIRATION?: IntNullableFilter<"Configuration"> | number | null
    PROD_URL?: StringNullableFilter<"Configuration"> | string | null
    REMIND_APPLICATION_DAYS?: IntNullableFilter<"Configuration"> | number | null
    REVIEW_COMMITTEE_EMAIL?: StringNullableListFilter<"Configuration">
    ROLE_TIMEOUT?: IntNullableFilter<"Configuration"> | number | null
    SCHEDULED_JOBS?: StringNullableFilter<"Configuration"> | string | null
    SUBMISSION_BUCKET?: StringNullableFilter<"Configuration"> | string | null
    SUBMISSION_HELPDESK?: StringNullableFilter<"Configuration"> | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: StringNullableFilter<"Configuration"> | string | null
    SUBMISSION_SYSTEM_PORTAL?: StringNullableFilter<"Configuration"> | string | null
    TECH_SUPPORT_EMAIL?: StringNullableFilter<"Configuration"> | string | null
    age?: IntNullableFilter<"Configuration"> | number | null
    bucketName?: StringNullableFilter<"Configuration"> | string | null
    current?: StringNullableFilter<"Configuration"> | string | null
    current_version?: StringNullableFilter<"Configuration"> | string | null
    dashboardID?: StringNullableFilter<"Configuration"> | string | null
    dataCommons?: StringNullableFilter<"Configuration"> | string | null
    days?: IntNullableFilter<"Configuration"> | number | null
    interval?: IntNullableFilter<"Configuration"> | number | null
    key?: StringNullableListFilter<"Configuration">
    keys?: JsonNullableFilter<"Configuration">
    new?: StringNullableFilter<"Configuration"> | string | null
    prefix?: StringNullableFilter<"Configuration"> | string | null
    tag?: XOR<ConfigurationTagNullableCompositeFilter, ConfigurationTagObjectEqualityInput> | null
    timeout?: IntNullableFilter<"Configuration"> | number | null
    type?: StringFilter<"Configuration"> | string
    version?: StringNullableFilter<"Configuration"> | string | null
  }, "id">

  export type ConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    EMAIL_URL?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    OFFICIAL_EMAIL?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    PROD_URL?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    REVIEW_COMMITTEE_EMAIL?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    SCHEDULED_JOBS?: SortOrder
    SUBMISSION_BUCKET?: SortOrder
    SUBMISSION_HELPDESK?: SortOrder
    SUBMISSION_REQUEST_CONTACT_EMAIL?: SortOrder
    SUBMISSION_SYSTEM_PORTAL?: SortOrder
    TECH_SUPPORT_EMAIL?: SortOrder
    age?: SortOrder
    bucketName?: SortOrder
    current?: SortOrder
    current_version?: SortOrder
    dashboardID?: SortOrder
    dataCommons?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    key?: SortOrder
    keys?: SortOrder
    new?: SortOrder
    prefix?: SortOrder
    timeout?: SortOrder
    type?: SortOrder
    version?: SortOrder
    _count?: ConfigurationCountOrderByAggregateInput
    _avg?: ConfigurationAvgOrderByAggregateInput
    _max?: ConfigurationMaxOrderByAggregateInput
    _min?: ConfigurationMinOrderByAggregateInput
    _sum?: ConfigurationSumOrderByAggregateInput
  }

  export type ConfigurationScalarWhereWithAggregatesInput = {
    AND?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    OR?: ConfigurationScalarWhereWithAggregatesInput[]
    NOT?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Configuration"> | string
    COMPLETED_RETENTION_DAYS?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    DASHBOARD_SESSION_TIMEOUT?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    EMAIL_URL?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    INACTIVE_APPLICATION_DAYS?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    INACTIVE_USER_DAYS?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    OFFICIAL_EMAIL?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    PRESIGN_EXPIRATION?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    PROD_URL?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    REMIND_APPLICATION_DAYS?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    REVIEW_COMMITTEE_EMAIL?: StringNullableListFilter<"Configuration">
    ROLE_TIMEOUT?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    SCHEDULED_JOBS?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    SUBMISSION_BUCKET?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    SUBMISSION_HELPDESK?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    SUBMISSION_SYSTEM_PORTAL?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    TECH_SUPPORT_EMAIL?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    age?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    bucketName?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    current?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    current_version?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    dashboardID?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    dataCommons?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    days?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    interval?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    key?: StringNullableListFilter<"Configuration">
    keys?: JsonNullableWithAggregatesFilter<"Configuration">
    new?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    prefix?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    timeout?: IntNullableWithAggregatesFilter<"Configuration"> | number | null
    type?: StringWithAggregatesFilter<"Configuration"> | string
    version?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
  }

  export type DataRecordWhereInput = {
    AND?: DataRecordWhereInput | DataRecordWhereInput[]
    OR?: DataRecordWhereInput[]
    NOT?: DataRecordWhereInput | DataRecordWhereInput[]
    id?: StringFilter<"DataRecord"> | string
    CRDC_ID?: StringNullableFilter<"DataRecord"> | string | null
    IDPropName?: StringFilter<"DataRecord"> | string
    additionalErrors?: AdditionalErrorCompositeListFilter | AdditionalErrorObjectEqualityInput[]
    batchIDs?: StringNullableListFilter<"DataRecord">
    dataCommons?: StringFilter<"DataRecord"> | string
    entityType?: StringNullableFilter<"DataRecord"> | string | null
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchDisplayID?: IntFilter<"DataRecord"> | number
    latestBatchID?: StringFilter<"DataRecord"> | string
    lineNumber?: IntFilter<"DataRecord"> | number
    nodeID?: StringFilter<"DataRecord"> | string
    nodeType?: StringFilter<"DataRecord"> | string
    orginalFileName?: StringFilter<"DataRecord"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"DataRecord">
    qcResultID?: StringNullableFilter<"DataRecord"> | string | null
    rawData?: JsonFilter<"DataRecord">
    s3FileInfo?: XOR<S3FileInfoNullableCompositeFilter, S3FileInfoObjectEqualityInput> | null
    status?: StringFilter<"DataRecord"> | string
    studyID?: StringFilter<"DataRecord"> | string
    submissionID?: StringFilter<"DataRecord"> | string
    uploadedDate?: DateTimeFilter<"DataRecord"> | Date | string
    validatedAt?: DateTimeNullableFilter<"DataRecord"> | Date | string | null
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    createdAt?: DateTimeFilter<"DataRecord"> | Date | string
    updatedAt?: DateTimeFilter<"DataRecord"> | Date | string
    submission?: XOR<SubmissionScalarRelationFilter, SubmissionWhereInput>
  }

  export type DataRecordOrderByWithRelationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    additionalErrors?: AdditionalErrorOrderByCompositeAggregateInput
    batchIDs?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    errors?: ErrorOrderByCompositeAggregateInput
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    parents?: ParentOrderByCompositeAggregateInput
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    s3FileInfo?: S3FileInfoOrderByInput
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    warnings?: ErrorOrderByCompositeAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submission?: SubmissionOrderByWithRelationInput
  }

  export type DataRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DataRecordWhereInput | DataRecordWhereInput[]
    OR?: DataRecordWhereInput[]
    NOT?: DataRecordWhereInput | DataRecordWhereInput[]
    CRDC_ID?: StringNullableFilter<"DataRecord"> | string | null
    IDPropName?: StringFilter<"DataRecord"> | string
    additionalErrors?: AdditionalErrorCompositeListFilter | AdditionalErrorObjectEqualityInput[]
    batchIDs?: StringNullableListFilter<"DataRecord">
    dataCommons?: StringFilter<"DataRecord"> | string
    entityType?: StringNullableFilter<"DataRecord"> | string | null
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchDisplayID?: IntFilter<"DataRecord"> | number
    latestBatchID?: StringFilter<"DataRecord"> | string
    lineNumber?: IntFilter<"DataRecord"> | number
    nodeID?: StringFilter<"DataRecord"> | string
    nodeType?: StringFilter<"DataRecord"> | string
    orginalFileName?: StringFilter<"DataRecord"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"DataRecord">
    qcResultID?: StringNullableFilter<"DataRecord"> | string | null
    rawData?: JsonFilter<"DataRecord">
    s3FileInfo?: XOR<S3FileInfoNullableCompositeFilter, S3FileInfoObjectEqualityInput> | null
    status?: StringFilter<"DataRecord"> | string
    studyID?: StringFilter<"DataRecord"> | string
    submissionID?: StringFilter<"DataRecord"> | string
    uploadedDate?: DateTimeFilter<"DataRecord"> | Date | string
    validatedAt?: DateTimeNullableFilter<"DataRecord"> | Date | string | null
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    createdAt?: DateTimeFilter<"DataRecord"> | Date | string
    updatedAt?: DateTimeFilter<"DataRecord"> | Date | string
    submission?: XOR<SubmissionScalarRelationFilter, SubmissionWhereInput>
  }, "id">

  export type DataRecordOrderByWithAggregationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    batchIDs?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataRecordCountOrderByAggregateInput
    _avg?: DataRecordAvgOrderByAggregateInput
    _max?: DataRecordMaxOrderByAggregateInput
    _min?: DataRecordMinOrderByAggregateInput
    _sum?: DataRecordSumOrderByAggregateInput
  }

  export type DataRecordScalarWhereWithAggregatesInput = {
    AND?: DataRecordScalarWhereWithAggregatesInput | DataRecordScalarWhereWithAggregatesInput[]
    OR?: DataRecordScalarWhereWithAggregatesInput[]
    NOT?: DataRecordScalarWhereWithAggregatesInput | DataRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataRecord"> | string
    CRDC_ID?: StringNullableWithAggregatesFilter<"DataRecord"> | string | null
    IDPropName?: StringWithAggregatesFilter<"DataRecord"> | string
    batchIDs?: StringNullableListFilter<"DataRecord">
    dataCommons?: StringWithAggregatesFilter<"DataRecord"> | string
    entityType?: StringNullableWithAggregatesFilter<"DataRecord"> | string | null
    latestBatchDisplayID?: IntWithAggregatesFilter<"DataRecord"> | number
    latestBatchID?: StringWithAggregatesFilter<"DataRecord"> | string
    lineNumber?: IntWithAggregatesFilter<"DataRecord"> | number
    nodeID?: StringWithAggregatesFilter<"DataRecord"> | string
    nodeType?: StringWithAggregatesFilter<"DataRecord"> | string
    orginalFileName?: StringWithAggregatesFilter<"DataRecord"> | string
    props?: JsonWithAggregatesFilter<"DataRecord">
    qcResultID?: StringNullableWithAggregatesFilter<"DataRecord"> | string | null
    rawData?: JsonWithAggregatesFilter<"DataRecord">
    status?: StringWithAggregatesFilter<"DataRecord"> | string
    studyID?: StringWithAggregatesFilter<"DataRecord"> | string
    submissionID?: StringWithAggregatesFilter<"DataRecord"> | string
    uploadedDate?: DateTimeWithAggregatesFilter<"DataRecord"> | Date | string
    validatedAt?: DateTimeNullableWithAggregatesFilter<"DataRecord"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DataRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DataRecord"> | Date | string
  }

  export type DataRecordsArchivedWhereInput = {
    AND?: DataRecordsArchivedWhereInput | DataRecordsArchivedWhereInput[]
    OR?: DataRecordsArchivedWhereInput[]
    NOT?: DataRecordsArchivedWhereInput | DataRecordsArchivedWhereInput[]
    id?: StringFilter<"DataRecordsArchived"> | string
    CRDC_ID?: StringNullableFilter<"DataRecordsArchived"> | string | null
    IDPropName?: StringFilter<"DataRecordsArchived"> | string
    additionalErrors?: AdditionalErrorCompositeListFilter | AdditionalErrorObjectEqualityInput[]
    batchIDs?: StringNullableListFilter<"DataRecordsArchived">
    dataCommons?: StringFilter<"DataRecordsArchived"> | string
    entityType?: StringNullableFilter<"DataRecordsArchived"> | string | null
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchDisplayID?: IntFilter<"DataRecordsArchived"> | number
    latestBatchID?: StringFilter<"DataRecordsArchived"> | string
    lineNumber?: IntFilter<"DataRecordsArchived"> | number
    nodeID?: StringFilter<"DataRecordsArchived"> | string
    nodeType?: StringFilter<"DataRecordsArchived"> | string
    orginalFileName?: StringFilter<"DataRecordsArchived"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"DataRecordsArchived">
    qcResultID?: StringNullableFilter<"DataRecordsArchived"> | string | null
    rawData?: JsonFilter<"DataRecordsArchived">
    s3FileInfo?: XOR<S3FileInfoNullableCompositeFilter, S3FileInfoObjectEqualityInput> | null
    status?: StringFilter<"DataRecordsArchived"> | string
    studyID?: StringNullableFilter<"DataRecordsArchived"> | string | null
    submissionID?: StringFilter<"DataRecordsArchived"> | string
    uploadedDate?: DateTimeFilter<"DataRecordsArchived"> | Date | string
    validatedAt?: DateTimeNullableFilter<"DataRecordsArchived"> | Date | string | null
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    createdAt?: DateTimeFilter<"DataRecordsArchived"> | Date | string
    updatedAt?: DateTimeFilter<"DataRecordsArchived"> | Date | string
  }

  export type DataRecordsArchivedOrderByWithRelationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    additionalErrors?: AdditionalErrorOrderByCompositeAggregateInput
    batchIDs?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    errors?: ErrorOrderByCompositeAggregateInput
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    parents?: ParentOrderByCompositeAggregateInput
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    s3FileInfo?: S3FileInfoOrderByInput
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    warnings?: ErrorOrderByCompositeAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataRecordsArchivedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DataRecordsArchivedWhereInput | DataRecordsArchivedWhereInput[]
    OR?: DataRecordsArchivedWhereInput[]
    NOT?: DataRecordsArchivedWhereInput | DataRecordsArchivedWhereInput[]
    CRDC_ID?: StringNullableFilter<"DataRecordsArchived"> | string | null
    IDPropName?: StringFilter<"DataRecordsArchived"> | string
    additionalErrors?: AdditionalErrorCompositeListFilter | AdditionalErrorObjectEqualityInput[]
    batchIDs?: StringNullableListFilter<"DataRecordsArchived">
    dataCommons?: StringFilter<"DataRecordsArchived"> | string
    entityType?: StringNullableFilter<"DataRecordsArchived"> | string | null
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchDisplayID?: IntFilter<"DataRecordsArchived"> | number
    latestBatchID?: StringFilter<"DataRecordsArchived"> | string
    lineNumber?: IntFilter<"DataRecordsArchived"> | number
    nodeID?: StringFilter<"DataRecordsArchived"> | string
    nodeType?: StringFilter<"DataRecordsArchived"> | string
    orginalFileName?: StringFilter<"DataRecordsArchived"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"DataRecordsArchived">
    qcResultID?: StringNullableFilter<"DataRecordsArchived"> | string | null
    rawData?: JsonFilter<"DataRecordsArchived">
    s3FileInfo?: XOR<S3FileInfoNullableCompositeFilter, S3FileInfoObjectEqualityInput> | null
    status?: StringFilter<"DataRecordsArchived"> | string
    studyID?: StringNullableFilter<"DataRecordsArchived"> | string | null
    submissionID?: StringFilter<"DataRecordsArchived"> | string
    uploadedDate?: DateTimeFilter<"DataRecordsArchived"> | Date | string
    validatedAt?: DateTimeNullableFilter<"DataRecordsArchived"> | Date | string | null
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    createdAt?: DateTimeFilter<"DataRecordsArchived"> | Date | string
    updatedAt?: DateTimeFilter<"DataRecordsArchived"> | Date | string
  }, "id">

  export type DataRecordsArchivedOrderByWithAggregationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    batchIDs?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataRecordsArchivedCountOrderByAggregateInput
    _avg?: DataRecordsArchivedAvgOrderByAggregateInput
    _max?: DataRecordsArchivedMaxOrderByAggregateInput
    _min?: DataRecordsArchivedMinOrderByAggregateInput
    _sum?: DataRecordsArchivedSumOrderByAggregateInput
  }

  export type DataRecordsArchivedScalarWhereWithAggregatesInput = {
    AND?: DataRecordsArchivedScalarWhereWithAggregatesInput | DataRecordsArchivedScalarWhereWithAggregatesInput[]
    OR?: DataRecordsArchivedScalarWhereWithAggregatesInput[]
    NOT?: DataRecordsArchivedScalarWhereWithAggregatesInput | DataRecordsArchivedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataRecordsArchived"> | string
    CRDC_ID?: StringNullableWithAggregatesFilter<"DataRecordsArchived"> | string | null
    IDPropName?: StringWithAggregatesFilter<"DataRecordsArchived"> | string
    batchIDs?: StringNullableListFilter<"DataRecordsArchived">
    dataCommons?: StringWithAggregatesFilter<"DataRecordsArchived"> | string
    entityType?: StringNullableWithAggregatesFilter<"DataRecordsArchived"> | string | null
    latestBatchDisplayID?: IntWithAggregatesFilter<"DataRecordsArchived"> | number
    latestBatchID?: StringWithAggregatesFilter<"DataRecordsArchived"> | string
    lineNumber?: IntWithAggregatesFilter<"DataRecordsArchived"> | number
    nodeID?: StringWithAggregatesFilter<"DataRecordsArchived"> | string
    nodeType?: StringWithAggregatesFilter<"DataRecordsArchived"> | string
    orginalFileName?: StringWithAggregatesFilter<"DataRecordsArchived"> | string
    props?: JsonWithAggregatesFilter<"DataRecordsArchived">
    qcResultID?: StringNullableWithAggregatesFilter<"DataRecordsArchived"> | string | null
    rawData?: JsonWithAggregatesFilter<"DataRecordsArchived">
    status?: StringWithAggregatesFilter<"DataRecordsArchived"> | string
    studyID?: StringNullableWithAggregatesFilter<"DataRecordsArchived"> | string | null
    submissionID?: StringWithAggregatesFilter<"DataRecordsArchived"> | string
    uploadedDate?: DateTimeWithAggregatesFilter<"DataRecordsArchived"> | Date | string
    validatedAt?: DateTimeNullableWithAggregatesFilter<"DataRecordsArchived"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DataRecordsArchived"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DataRecordsArchived"> | Date | string
  }

  export type FileMD5WhereInput = {
    AND?: FileMD5WhereInput | FileMD5WhereInput[]
    OR?: FileMD5WhereInput[]
    NOT?: FileMD5WhereInput | FileMD5WhereInput[]
    id?: StringFilter<"FileMD5"> | string
    LastModified?: DateTimeFilter<"FileMD5"> | Date | string
    fileName?: StringFilter<"FileMD5"> | string
    md5?: StringFilter<"FileMD5"> | string
    submissionID?: StringFilter<"FileMD5"> | string
    createdAt?: DateTimeFilter<"FileMD5"> | Date | string
    updatedAt?: DateTimeFilter<"FileMD5"> | Date | string
  }

  export type FileMD5OrderByWithRelationInput = {
    id?: SortOrder
    LastModified?: SortOrder
    fileName?: SortOrder
    md5?: SortOrder
    submissionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileMD5WhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileMD5WhereInput | FileMD5WhereInput[]
    OR?: FileMD5WhereInput[]
    NOT?: FileMD5WhereInput | FileMD5WhereInput[]
    LastModified?: DateTimeFilter<"FileMD5"> | Date | string
    fileName?: StringFilter<"FileMD5"> | string
    md5?: StringFilter<"FileMD5"> | string
    submissionID?: StringFilter<"FileMD5"> | string
    createdAt?: DateTimeFilter<"FileMD5"> | Date | string
    updatedAt?: DateTimeFilter<"FileMD5"> | Date | string
  }, "id">

  export type FileMD5OrderByWithAggregationInput = {
    id?: SortOrder
    LastModified?: SortOrder
    fileName?: SortOrder
    md5?: SortOrder
    submissionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FileMD5CountOrderByAggregateInput
    _max?: FileMD5MaxOrderByAggregateInput
    _min?: FileMD5MinOrderByAggregateInput
  }

  export type FileMD5ScalarWhereWithAggregatesInput = {
    AND?: FileMD5ScalarWhereWithAggregatesInput | FileMD5ScalarWhereWithAggregatesInput[]
    OR?: FileMD5ScalarWhereWithAggregatesInput[]
    NOT?: FileMD5ScalarWhereWithAggregatesInput | FileMD5ScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileMD5"> | string
    LastModified?: DateTimeWithAggregatesFilter<"FileMD5"> | Date | string
    fileName?: StringWithAggregatesFilter<"FileMD5"> | string
    md5?: StringWithAggregatesFilter<"FileMD5"> | string
    submissionID?: StringWithAggregatesFilter<"FileMD5"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FileMD5"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FileMD5"> | Date | string
  }

  export type InstitutionWhereInput = {
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    id?: StringFilter<"Institution"> | string
    name?: StringFilter<"Institution"> | string
    status?: StringFilter<"Institution"> | string
    submitterCount?: IntNullableFilter<"Institution"> | number | null
    createdAt?: DateTimeNullableFilter<"Institution"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Institution"> | Date | string | null
  }

  export type InstitutionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    submitterCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstitutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    name?: StringFilter<"Institution"> | string
    status?: StringFilter<"Institution"> | string
    submitterCount?: IntNullableFilter<"Institution"> | number | null
    createdAt?: DateTimeNullableFilter<"Institution"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Institution"> | Date | string | null
  }, "id">

  export type InstitutionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    submitterCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstitutionCountOrderByAggregateInput
    _avg?: InstitutionAvgOrderByAggregateInput
    _max?: InstitutionMaxOrderByAggregateInput
    _min?: InstitutionMinOrderByAggregateInput
    _sum?: InstitutionSumOrderByAggregateInput
  }

  export type InstitutionScalarWhereWithAggregatesInput = {
    AND?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    OR?: InstitutionScalarWhereWithAggregatesInput[]
    NOT?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Institution"> | string
    name?: StringWithAggregatesFilter<"Institution"> | string
    status?: StringWithAggregatesFilter<"Institution"> | string
    submitterCount?: IntNullableWithAggregatesFilter<"Institution"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Institution"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Institution"> | Date | string | null
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: StringFilter<"Log"> | string
    action?: StringNullableFilter<"Log"> | string | null
    applicationID?: StringNullableFilter<"Log"> | string | null
    eventDetail?: XOR<LogsEventDetailNullableCompositeFilter, LogsEventDetailObjectEqualityInput> | null
    eventType?: StringFilter<"Log"> | string
    localtime?: DateTimeFilter<"Log"> | Date | string
    newProfile?: JsonNullableFilter<"Log">
    newState?: StringNullableFilter<"Log"> | string | null
    prevProfile?: JsonNullableFilter<"Log">
    prevState?: StringNullableFilter<"Log"> | string | null
    submissionID?: StringNullableFilter<"Log"> | string | null
    timestamp?: FloatFilter<"Log"> | number
    userEmail?: StringFilter<"Log"> | string
    userID?: StringFilter<"Log"> | string
    userIDP?: StringNullableFilter<"Log"> | string | null
    userName?: StringNullableFilter<"Log"> | string | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    applicationID?: SortOrder
    eventDetail?: LogsEventDetailOrderByInput
    eventType?: SortOrder
    localtime?: SortOrder
    newProfile?: SortOrder
    newState?: SortOrder
    prevProfile?: SortOrder
    prevState?: SortOrder
    submissionID?: SortOrder
    timestamp?: SortOrder
    userEmail?: SortOrder
    userID?: SortOrder
    userIDP?: SortOrder
    userName?: SortOrder
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    action?: StringNullableFilter<"Log"> | string | null
    applicationID?: StringNullableFilter<"Log"> | string | null
    eventDetail?: XOR<LogsEventDetailNullableCompositeFilter, LogsEventDetailObjectEqualityInput> | null
    eventType?: StringFilter<"Log"> | string
    localtime?: DateTimeFilter<"Log"> | Date | string
    newProfile?: JsonNullableFilter<"Log">
    newState?: StringNullableFilter<"Log"> | string | null
    prevProfile?: JsonNullableFilter<"Log">
    prevState?: StringNullableFilter<"Log"> | string | null
    submissionID?: StringNullableFilter<"Log"> | string | null
    timestamp?: FloatFilter<"Log"> | number
    userEmail?: StringFilter<"Log"> | string
    userID?: StringFilter<"Log"> | string
    userIDP?: StringNullableFilter<"Log"> | string | null
    userName?: StringNullableFilter<"Log"> | string | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    applicationID?: SortOrder
    eventType?: SortOrder
    localtime?: SortOrder
    newProfile?: SortOrder
    newState?: SortOrder
    prevProfile?: SortOrder
    prevState?: SortOrder
    submissionID?: SortOrder
    timestamp?: SortOrder
    userEmail?: SortOrder
    userID?: SortOrder
    userIDP?: SortOrder
    userName?: SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Log"> | string
    action?: StringNullableWithAggregatesFilter<"Log"> | string | null
    applicationID?: StringNullableWithAggregatesFilter<"Log"> | string | null
    eventType?: StringWithAggregatesFilter<"Log"> | string
    localtime?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    newProfile?: JsonNullableWithAggregatesFilter<"Log">
    newState?: StringNullableWithAggregatesFilter<"Log"> | string | null
    prevProfile?: JsonNullableWithAggregatesFilter<"Log">
    prevState?: StringNullableWithAggregatesFilter<"Log"> | string | null
    submissionID?: StringNullableWithAggregatesFilter<"Log"> | string | null
    timestamp?: FloatWithAggregatesFilter<"Log"> | number
    userEmail?: StringWithAggregatesFilter<"Log"> | string
    userID?: StringWithAggregatesFilter<"Log"> | string
    userIDP?: StringNullableWithAggregatesFilter<"Log"> | string | null
    userName?: StringNullableWithAggregatesFilter<"Log"> | string | null
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: StringFilter<"Program"> | string
    abbreviation?: StringNullableFilter<"Program"> | string | null
    bucketName?: StringNullableFilter<"Program"> | string | null
    conciergeEmail?: StringNullableFilter<"Program"> | string | null
    conciergeID?: StringNullableFilter<"Program"> | string | null
    conciergeName?: StringNullableFilter<"Program"> | string | null
    description?: StringNullableFilter<"Program"> | string | null
    name?: StringFilter<"Program"> | string
    rootPath?: StringNullableFilter<"Program"> | string | null
    status?: StringFilter<"Program"> | string
    studies?: StudyByIDCompositeListFilter | StudyByIDObjectEqualityInput[]
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updateAt?: DateTimeFilter<"Program"> | Date | string
    Concierge?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    abbreviation?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeID?: SortOrder
    conciergeName?: SortOrder
    description?: SortOrder
    name?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studies?: StudyByIDOrderByCompositeAggregateInput
    createdAt?: SortOrder
    updateAt?: SortOrder
    Concierge?: UserOrderByWithRelationInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    abbreviation?: StringNullableFilter<"Program"> | string | null
    bucketName?: StringNullableFilter<"Program"> | string | null
    conciergeEmail?: StringNullableFilter<"Program"> | string | null
    conciergeID?: StringNullableFilter<"Program"> | string | null
    conciergeName?: StringNullableFilter<"Program"> | string | null
    description?: StringNullableFilter<"Program"> | string | null
    name?: StringFilter<"Program"> | string
    rootPath?: StringNullableFilter<"Program"> | string | null
    status?: StringFilter<"Program"> | string
    studies?: StudyByIDCompositeListFilter | StudyByIDObjectEqualityInput[]
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updateAt?: DateTimeFilter<"Program"> | Date | string
    Concierge?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    abbreviation?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeID?: SortOrder
    conciergeName?: SortOrder
    description?: SortOrder
    name?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Program"> | string
    abbreviation?: StringNullableWithAggregatesFilter<"Program"> | string | null
    bucketName?: StringNullableWithAggregatesFilter<"Program"> | string | null
    conciergeEmail?: StringNullableWithAggregatesFilter<"Program"> | string | null
    conciergeID?: StringNullableWithAggregatesFilter<"Program"> | string | null
    conciergeName?: StringNullableWithAggregatesFilter<"Program"> | string | null
    description?: StringNullableWithAggregatesFilter<"Program"> | string | null
    name?: StringWithAggregatesFilter<"Program"> | string
    rootPath?: StringNullableWithAggregatesFilter<"Program"> | string | null
    status?: StringWithAggregatesFilter<"Program"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
  }

  export type QcResultWhereInput = {
    AND?: QcResultWhereInput | QcResultWhereInput[]
    OR?: QcResultWhereInput[]
    NOT?: QcResultWhereInput | QcResultWhereInput[]
    id?: StringFilter<"QcResult"> | string
    batchIDs?: StringNullableListFilter<"QcResult">
    dataRecordID?: StringFilter<"QcResult"> | string
    displayID?: IntFilter<"QcResult"> | number
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchID?: StringFilter<"QcResult"> | string
    origin?: StringNullableFilter<"QcResult"> | string | null
    severity?: StringFilter<"QcResult"> | string
    submissionID?: StringFilter<"QcResult"> | string
    submittedID?: StringFilter<"QcResult"> | string
    type?: StringFilter<"QcResult"> | string
    uploadedDate?: DateTimeFilter<"QcResult"> | Date | string
    validatedDate?: DateTimeFilter<"QcResult"> | Date | string
    validationType?: StringFilter<"QcResult"> | string
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    submission?: XOR<SubmissionScalarRelationFilter, SubmissionWhereInput>
  }

  export type QcResultOrderByWithRelationInput = {
    id?: SortOrder
    batchIDs?: SortOrder
    dataRecordID?: SortOrder
    displayID?: SortOrder
    errors?: ErrorOrderByCompositeAggregateInput
    latestBatchID?: SortOrder
    origin?: SortOrder
    severity?: SortOrder
    submissionID?: SortOrder
    submittedID?: SortOrder
    type?: SortOrder
    uploadedDate?: SortOrder
    validatedDate?: SortOrder
    validationType?: SortOrder
    warnings?: ErrorOrderByCompositeAggregateInput
    submission?: SubmissionOrderByWithRelationInput
  }

  export type QcResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QcResultWhereInput | QcResultWhereInput[]
    OR?: QcResultWhereInput[]
    NOT?: QcResultWhereInput | QcResultWhereInput[]
    batchIDs?: StringNullableListFilter<"QcResult">
    dataRecordID?: StringFilter<"QcResult"> | string
    displayID?: IntFilter<"QcResult"> | number
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    latestBatchID?: StringFilter<"QcResult"> | string
    origin?: StringNullableFilter<"QcResult"> | string | null
    severity?: StringFilter<"QcResult"> | string
    submissionID?: StringFilter<"QcResult"> | string
    submittedID?: StringFilter<"QcResult"> | string
    type?: StringFilter<"QcResult"> | string
    uploadedDate?: DateTimeFilter<"QcResult"> | Date | string
    validatedDate?: DateTimeFilter<"QcResult"> | Date | string
    validationType?: StringFilter<"QcResult"> | string
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    submission?: XOR<SubmissionScalarRelationFilter, SubmissionWhereInput>
  }, "id">

  export type QcResultOrderByWithAggregationInput = {
    id?: SortOrder
    batchIDs?: SortOrder
    dataRecordID?: SortOrder
    displayID?: SortOrder
    latestBatchID?: SortOrder
    origin?: SortOrder
    severity?: SortOrder
    submissionID?: SortOrder
    submittedID?: SortOrder
    type?: SortOrder
    uploadedDate?: SortOrder
    validatedDate?: SortOrder
    validationType?: SortOrder
    _count?: QcResultCountOrderByAggregateInput
    _avg?: QcResultAvgOrderByAggregateInput
    _max?: QcResultMaxOrderByAggregateInput
    _min?: QcResultMinOrderByAggregateInput
    _sum?: QcResultSumOrderByAggregateInput
  }

  export type QcResultScalarWhereWithAggregatesInput = {
    AND?: QcResultScalarWhereWithAggregatesInput | QcResultScalarWhereWithAggregatesInput[]
    OR?: QcResultScalarWhereWithAggregatesInput[]
    NOT?: QcResultScalarWhereWithAggregatesInput | QcResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QcResult"> | string
    batchIDs?: StringNullableListFilter<"QcResult">
    dataRecordID?: StringWithAggregatesFilter<"QcResult"> | string
    displayID?: IntWithAggregatesFilter<"QcResult"> | number
    latestBatchID?: StringWithAggregatesFilter<"QcResult"> | string
    origin?: StringNullableWithAggregatesFilter<"QcResult"> | string | null
    severity?: StringWithAggregatesFilter<"QcResult"> | string
    submissionID?: StringWithAggregatesFilter<"QcResult"> | string
    submittedID?: StringWithAggregatesFilter<"QcResult"> | string
    type?: StringWithAggregatesFilter<"QcResult"> | string
    uploadedDate?: DateTimeWithAggregatesFilter<"QcResult"> | Date | string
    validatedDate?: DateTimeWithAggregatesFilter<"QcResult"> | Date | string
    validationType?: StringWithAggregatesFilter<"QcResult"> | string
  }

  export type ReleaseWhereInput = {
    AND?: ReleaseWhereInput | ReleaseWhereInput[]
    OR?: ReleaseWhereInput[]
    NOT?: ReleaseWhereInput | ReleaseWhereInput[]
    id?: StringFilter<"Release"> | string
    CRDC_ID?: StringNullableFilter<"Release"> | string | null
    dataCommons?: StringFilter<"Release"> | string
    entityType?: StringNullableFilter<"Release"> | string | null
    nodeID?: StringFilter<"Release"> | string
    nodeType?: StringFilter<"Release"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"Release">
    status?: StringFilter<"Release"> | string
    studyID?: StringNullableFilter<"Release"> | string | null
    submissionID?: StringFilter<"Release"> | string
    createdAt?: DateTimeFilter<"Release"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Release"> | Date | string | null
  }

  export type ReleaseOrderByWithRelationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    parents?: ParentOrderByCompositeAggregateInput
    props?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReleaseWhereInput | ReleaseWhereInput[]
    OR?: ReleaseWhereInput[]
    NOT?: ReleaseWhereInput | ReleaseWhereInput[]
    CRDC_ID?: StringNullableFilter<"Release"> | string | null
    dataCommons?: StringFilter<"Release"> | string
    entityType?: StringNullableFilter<"Release"> | string | null
    nodeID?: StringFilter<"Release"> | string
    nodeType?: StringFilter<"Release"> | string
    parents?: ParentCompositeListFilter | ParentObjectEqualityInput[]
    props?: JsonFilter<"Release">
    status?: StringFilter<"Release"> | string
    studyID?: StringNullableFilter<"Release"> | string | null
    submissionID?: StringFilter<"Release"> | string
    createdAt?: DateTimeFilter<"Release"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Release"> | Date | string | null
  }, "id">

  export type ReleaseOrderByWithAggregationInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    props?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReleaseCountOrderByAggregateInput
    _max?: ReleaseMaxOrderByAggregateInput
    _min?: ReleaseMinOrderByAggregateInput
  }

  export type ReleaseScalarWhereWithAggregatesInput = {
    AND?: ReleaseScalarWhereWithAggregatesInput | ReleaseScalarWhereWithAggregatesInput[]
    OR?: ReleaseScalarWhereWithAggregatesInput[]
    NOT?: ReleaseScalarWhereWithAggregatesInput | ReleaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Release"> | string
    CRDC_ID?: StringNullableWithAggregatesFilter<"Release"> | string | null
    dataCommons?: StringWithAggregatesFilter<"Release"> | string
    entityType?: StringNullableWithAggregatesFilter<"Release"> | string | null
    nodeID?: StringWithAggregatesFilter<"Release"> | string
    nodeType?: StringWithAggregatesFilter<"Release"> | string
    props?: JsonWithAggregatesFilter<"Release">
    status?: StringWithAggregatesFilter<"Release"> | string
    studyID?: StringNullableWithAggregatesFilter<"Release"> | string | null
    submissionID?: StringWithAggregatesFilter<"Release"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Release"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Release"> | Date | string | null
  }

  export type SubmissionWhereInput = {
    AND?: SubmissionWhereInput | SubmissionWhereInput[]
    OR?: SubmissionWhereInput[]
    NOT?: SubmissionWhereInput | SubmissionWhereInput[]
    id?: StringFilter<"Submission"> | string
    ORCID?: StringNullableFilter<"Submission"> | string | null
    accessedAt?: DateTimeFilter<"Submission"> | Date | string
    archived?: BoolNullableFilter<"Submission"> | boolean | null
    bucketName?: StringFilter<"Submission"> | string
    collaborators?: CollaboratorCompositeListFilter | CollaboratorObjectEqualityInput[]
    conciergeEmail?: StringNullableFilter<"Submission"> | string | null
    conciergeName?: StringNullableFilter<"Submission"> | string | null
    controlledAccess?: BoolNullableFilter<"Submission"> | boolean | null
    crossSubmissionStatus?: StringNullableFilter<"Submission"> | string | null
    dataCommons?: StringFilter<"Submission"> | string
    dataCommonsDisplayName?: StringNullableFilter<"Submission"> | string | null
    dataFileSize?: XOR<DataFileSizeCompositeFilter, DataFileSizeObjectEqualityInput>
    dataType?: StringFilter<"Submission"> | string
    dbGaPID?: StringNullableFilter<"Submission"> | string | null
    deletingData?: BoolNullableFilter<"Submission"> | boolean | null
    fileValidationStatus?: StringNullableFilter<"Submission"> | string | null
    finalInactiveReminder?: BoolNullableFilter<"Submission"> | boolean | null
    history?: HistoryCompositeListFilter | HistoryObjectEqualityInput[]
    inactiveReminder?: BoolNullableFilter<"Submission"> | boolean | null
    inactiveReminder_30?: BoolNullableFilter<"Submission"> | boolean | null
    inactiveReminder_60?: BoolNullableFilter<"Submission"> | boolean | null
    inactiveReminder_7?: BoolNullableFilter<"Submission"> | boolean | null
    intention?: StringFilter<"Submission"> | string
    metadataValidationStatus?: StringNullableFilter<"Submission"> | string | null
    modelVersion?: StringFilter<"Submission"> | string
    name?: StringFilter<"Submission"> | string
    nodeCount?: IntNullableFilter<"Submission"> | number | null
    organization?: XOR<OrgInfoCompositeFilter, OrgInfoObjectEqualityInput>
    reviewComment?: StringNullableFilter<"Submission"> | string | null
    rootPath?: StringFilter<"Submission"> | string
    status?: StringFilter<"Submission"> | string
    studyAbbreviation?: StringNullableFilter<"Submission"> | string | null
    studyID?: StringFilter<"Submission"> | string
    submitterID?: StringFilter<"Submission"> | string
    submitterName?: StringFilter<"Submission"> | string
    validationEnded?: DateTimeNullableFilter<"Submission"> | Date | string | null
    validationScope?: StringNullableFilter<"Submission"> | string | null
    validationStarted?: DateTimeNullableFilter<"Submission"> | Date | string | null
    validationType?: StringNullableListFilter<"Submission">
    createdAt?: DateTimeFilter<"Submission"> | Date | string
    updatedAt?: DateTimeFilter<"Submission"> | Date | string
    batches?: BatchListRelationFilter
    dataRecords?: DataRecordListRelationFilter
    qcResults?: QcResultListRelationFilter
    validations?: ValidationListRelationFilter
  }

  export type SubmissionOrderByWithRelationInput = {
    id?: SortOrder
    ORCID?: SortOrder
    accessedAt?: SortOrder
    archived?: SortOrder
    bucketName?: SortOrder
    collaborators?: CollaboratorOrderByCompositeAggregateInput
    conciergeEmail?: SortOrder
    conciergeName?: SortOrder
    controlledAccess?: SortOrder
    crossSubmissionStatus?: SortOrder
    dataCommons?: SortOrder
    dataCommonsDisplayName?: SortOrder
    dataFileSize?: DataFileSizeOrderByInput
    dataType?: SortOrder
    dbGaPID?: SortOrder
    deletingData?: SortOrder
    fileValidationStatus?: SortOrder
    finalInactiveReminder?: SortOrder
    history?: HistoryOrderByCompositeAggregateInput
    inactiveReminder?: SortOrder
    inactiveReminder_30?: SortOrder
    inactiveReminder_60?: SortOrder
    inactiveReminder_7?: SortOrder
    intention?: SortOrder
    metadataValidationStatus?: SortOrder
    modelVersion?: SortOrder
    name?: SortOrder
    nodeCount?: SortOrder
    organization?: OrgInfoOrderByInput
    reviewComment?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    validationEnded?: SortOrder
    validationScope?: SortOrder
    validationStarted?: SortOrder
    validationType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    batches?: BatchOrderByRelationAggregateInput
    dataRecords?: DataRecordOrderByRelationAggregateInput
    qcResults?: QcResultOrderByRelationAggregateInput
    validations?: ValidationOrderByRelationAggregateInput
  }

  export type SubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubmissionWhereInput | SubmissionWhereInput[]
    OR?: SubmissionWhereInput[]
    NOT?: SubmissionWhereInput | SubmissionWhereInput[]
    ORCID?: StringNullableFilter<"Submission"> | string | null
    accessedAt?: DateTimeFilter<"Submission"> | Date | string
    archived?: BoolNullableFilter<"Submission"> | boolean | null
    bucketName?: StringFilter<"Submission"> | string
    collaborators?: CollaboratorCompositeListFilter | CollaboratorObjectEqualityInput[]
    conciergeEmail?: StringNullableFilter<"Submission"> | string | null
    conciergeName?: StringNullableFilter<"Submission"> | string | null
    controlledAccess?: BoolNullableFilter<"Submission"> | boolean | null
    crossSubmissionStatus?: StringNullableFilter<"Submission"> | string | null
    dataCommons?: StringFilter<"Submission"> | string
    dataCommonsDisplayName?: StringNullableFilter<"Submission"> | string | null
    dataFileSize?: XOR<DataFileSizeCompositeFilter, DataFileSizeObjectEqualityInput>
    dataType?: StringFilter<"Submission"> | string
    dbGaPID?: StringNullableFilter<"Submission"> | string | null
    deletingData?: BoolNullableFilter<"Submission"> | boolean | null
    fileValidationStatus?: StringNullableFilter<"Submission"> | string | null
    finalInactiveReminder?: BoolNullableFilter<"Submission"> | boolean | null
    history?: HistoryCompositeListFilter | HistoryObjectEqualityInput[]
    inactiveReminder?: BoolNullableFilter<"Submission"> | boolean | null
    inactiveReminder_30?: BoolNullableFilter<"Submission"> | boolean | null
    inactiveReminder_60?: BoolNullableFilter<"Submission"> | boolean | null
    inactiveReminder_7?: BoolNullableFilter<"Submission"> | boolean | null
    intention?: StringFilter<"Submission"> | string
    metadataValidationStatus?: StringNullableFilter<"Submission"> | string | null
    modelVersion?: StringFilter<"Submission"> | string
    name?: StringFilter<"Submission"> | string
    nodeCount?: IntNullableFilter<"Submission"> | number | null
    organization?: XOR<OrgInfoCompositeFilter, OrgInfoObjectEqualityInput>
    reviewComment?: StringNullableFilter<"Submission"> | string | null
    rootPath?: StringFilter<"Submission"> | string
    status?: StringFilter<"Submission"> | string
    studyAbbreviation?: StringNullableFilter<"Submission"> | string | null
    studyID?: StringFilter<"Submission"> | string
    submitterID?: StringFilter<"Submission"> | string
    submitterName?: StringFilter<"Submission"> | string
    validationEnded?: DateTimeNullableFilter<"Submission"> | Date | string | null
    validationScope?: StringNullableFilter<"Submission"> | string | null
    validationStarted?: DateTimeNullableFilter<"Submission"> | Date | string | null
    validationType?: StringNullableListFilter<"Submission">
    createdAt?: DateTimeFilter<"Submission"> | Date | string
    updatedAt?: DateTimeFilter<"Submission"> | Date | string
    batches?: BatchListRelationFilter
    dataRecords?: DataRecordListRelationFilter
    qcResults?: QcResultListRelationFilter
    validations?: ValidationListRelationFilter
  }, "id">

  export type SubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    ORCID?: SortOrder
    accessedAt?: SortOrder
    archived?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeName?: SortOrder
    controlledAccess?: SortOrder
    crossSubmissionStatus?: SortOrder
    dataCommons?: SortOrder
    dataCommonsDisplayName?: SortOrder
    dataType?: SortOrder
    dbGaPID?: SortOrder
    deletingData?: SortOrder
    fileValidationStatus?: SortOrder
    finalInactiveReminder?: SortOrder
    inactiveReminder?: SortOrder
    inactiveReminder_30?: SortOrder
    inactiveReminder_60?: SortOrder
    inactiveReminder_7?: SortOrder
    intention?: SortOrder
    metadataValidationStatus?: SortOrder
    modelVersion?: SortOrder
    name?: SortOrder
    nodeCount?: SortOrder
    reviewComment?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    validationEnded?: SortOrder
    validationScope?: SortOrder
    validationStarted?: SortOrder
    validationType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubmissionCountOrderByAggregateInput
    _avg?: SubmissionAvgOrderByAggregateInput
    _max?: SubmissionMaxOrderByAggregateInput
    _min?: SubmissionMinOrderByAggregateInput
    _sum?: SubmissionSumOrderByAggregateInput
  }

  export type SubmissionScalarWhereWithAggregatesInput = {
    AND?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[]
    OR?: SubmissionScalarWhereWithAggregatesInput[]
    NOT?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Submission"> | string
    ORCID?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    accessedAt?: DateTimeWithAggregatesFilter<"Submission"> | Date | string
    archived?: BoolNullableWithAggregatesFilter<"Submission"> | boolean | null
    bucketName?: StringWithAggregatesFilter<"Submission"> | string
    conciergeEmail?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    conciergeName?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    controlledAccess?: BoolNullableWithAggregatesFilter<"Submission"> | boolean | null
    crossSubmissionStatus?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    dataCommons?: StringWithAggregatesFilter<"Submission"> | string
    dataCommonsDisplayName?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    dataType?: StringWithAggregatesFilter<"Submission"> | string
    dbGaPID?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    deletingData?: BoolNullableWithAggregatesFilter<"Submission"> | boolean | null
    fileValidationStatus?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    finalInactiveReminder?: BoolNullableWithAggregatesFilter<"Submission"> | boolean | null
    inactiveReminder?: BoolNullableWithAggregatesFilter<"Submission"> | boolean | null
    inactiveReminder_30?: BoolNullableWithAggregatesFilter<"Submission"> | boolean | null
    inactiveReminder_60?: BoolNullableWithAggregatesFilter<"Submission"> | boolean | null
    inactiveReminder_7?: BoolNullableWithAggregatesFilter<"Submission"> | boolean | null
    intention?: StringWithAggregatesFilter<"Submission"> | string
    metadataValidationStatus?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    modelVersion?: StringWithAggregatesFilter<"Submission"> | string
    name?: StringWithAggregatesFilter<"Submission"> | string
    nodeCount?: IntNullableWithAggregatesFilter<"Submission"> | number | null
    reviewComment?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    rootPath?: StringWithAggregatesFilter<"Submission"> | string
    status?: StringWithAggregatesFilter<"Submission"> | string
    studyAbbreviation?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    studyID?: StringWithAggregatesFilter<"Submission"> | string
    submitterID?: StringWithAggregatesFilter<"Submission"> | string
    submitterName?: StringWithAggregatesFilter<"Submission"> | string
    validationEnded?: DateTimeNullableWithAggregatesFilter<"Submission"> | Date | string | null
    validationScope?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    validationStarted?: DateTimeNullableWithAggregatesFilter<"Submission"> | Date | string | null
    validationType?: StringNullableListFilter<"Submission">
    createdAt?: DateTimeWithAggregatesFilter<"Submission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Submission"> | Date | string
  }

  export type SynonymWhereInput = {
    AND?: SynonymWhereInput | SynonymWhereInput[]
    OR?: SynonymWhereInput[]
    NOT?: SynonymWhereInput | SynonymWhereInput[]
    id?: StringFilter<"Synonym"> | string
    equivalent_term?: StringFilter<"Synonym"> | string
    synonym_term?: StringFilter<"Synonym"> | string
  }

  export type SynonymOrderByWithRelationInput = {
    id?: SortOrder
    equivalent_term?: SortOrder
    synonym_term?: SortOrder
  }

  export type SynonymWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SynonymWhereInput | SynonymWhereInput[]
    OR?: SynonymWhereInput[]
    NOT?: SynonymWhereInput | SynonymWhereInput[]
    equivalent_term?: StringFilter<"Synonym"> | string
    synonym_term?: StringFilter<"Synonym"> | string
  }, "id">

  export type SynonymOrderByWithAggregationInput = {
    id?: SortOrder
    equivalent_term?: SortOrder
    synonym_term?: SortOrder
    _count?: SynonymCountOrderByAggregateInput
    _max?: SynonymMaxOrderByAggregateInput
    _min?: SynonymMinOrderByAggregateInput
  }

  export type SynonymScalarWhereWithAggregatesInput = {
    AND?: SynonymScalarWhereWithAggregatesInput | SynonymScalarWhereWithAggregatesInput[]
    OR?: SynonymScalarWhereWithAggregatesInput[]
    NOT?: SynonymScalarWhereWithAggregatesInput | SynonymScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Synonym"> | string
    equivalent_term?: StringWithAggregatesFilter<"Synonym"> | string
    synonym_term?: StringWithAggregatesFilter<"Synonym"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    IDP?: StringFilter<"User"> | string
    dataCommons?: StringNullableListFilter<"User">
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    institution?: XOR<InstitutionInfoNullableCompositeFilter, InstitutionInfoObjectEqualityInput> | null
    lastName?: StringFilter<"User"> | string
    notifications?: StringNullableListFilter<"User">
    organization?: XOR<OrgInfoNullableCompositeFilter, OrgInfoObjectEqualityInput> | null
    permissions?: StringNullableListFilter<"User">
    role?: StringFilter<"User"> | string
    status?: StringNullableFilter<"User"> | string | null
    studies?: StudyByIDCompositeListFilter | StudyByIDObjectEqualityInput[]
    tokens?: StringNullableListFilter<"User">
    userStatus?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updateAt?: DateTimeFilter<"User"> | Date | string
    programs?: ProgramListRelationFilter
    approvedStudies?: ApprovedStudyListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    IDP?: SortOrder
    dataCommons?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    institution?: InstitutionInfoOrderByInput
    lastName?: SortOrder
    notifications?: SortOrder
    organization?: OrgInfoOrderByInput
    permissions?: SortOrder
    role?: SortOrder
    status?: SortOrder
    studies?: StudyByIDOrderByCompositeAggregateInput
    tokens?: SortOrder
    userStatus?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    programs?: ProgramOrderByRelationAggregateInput
    approvedStudies?: ApprovedStudyOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    IDP?: StringFilter<"User"> | string
    dataCommons?: StringNullableListFilter<"User">
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    institution?: XOR<InstitutionInfoNullableCompositeFilter, InstitutionInfoObjectEqualityInput> | null
    lastName?: StringFilter<"User"> | string
    notifications?: StringNullableListFilter<"User">
    organization?: XOR<OrgInfoNullableCompositeFilter, OrgInfoObjectEqualityInput> | null
    permissions?: StringNullableListFilter<"User">
    role?: StringFilter<"User"> | string
    status?: StringNullableFilter<"User"> | string | null
    studies?: StudyByIDCompositeListFilter | StudyByIDObjectEqualityInput[]
    tokens?: StringNullableListFilter<"User">
    userStatus?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updateAt?: DateTimeFilter<"User"> | Date | string
    programs?: ProgramListRelationFilter
    approvedStudies?: ApprovedStudyListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    IDP?: SortOrder
    dataCommons?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    notifications?: SortOrder
    permissions?: SortOrder
    role?: SortOrder
    status?: SortOrder
    tokens?: SortOrder
    userStatus?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    IDP?: StringWithAggregatesFilter<"User"> | string
    dataCommons?: StringNullableListFilter<"User">
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    notifications?: StringNullableListFilter<"User">
    permissions?: StringNullableListFilter<"User">
    role?: StringWithAggregatesFilter<"User"> | string
    status?: StringNullableWithAggregatesFilter<"User"> | string | null
    tokens?: StringNullableListFilter<"User">
    userStatus?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ValidationWhereInput = {
    AND?: ValidationWhereInput | ValidationWhereInput[]
    OR?: ValidationWhereInput[]
    NOT?: ValidationWhereInput | ValidationWhereInput[]
    id?: StringFilter<"Validation"> | string
    ended?: DateTimeNullableFilter<"Validation"> | Date | string | null
    scope?: StringNullableFilter<"Validation"> | string | null
    started?: DateTimeFilter<"Validation"> | Date | string
    status?: StringNullableFilter<"Validation"> | string | null
    submissionID?: StringFilter<"Validation"> | string
    type?: StringNullableListFilter<"Validation">
    submission?: XOR<SubmissionScalarRelationFilter, SubmissionWhereInput>
  }

  export type ValidationOrderByWithRelationInput = {
    id?: SortOrder
    ended?: SortOrder
    scope?: SortOrder
    started?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    type?: SortOrder
    submission?: SubmissionOrderByWithRelationInput
  }

  export type ValidationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ValidationWhereInput | ValidationWhereInput[]
    OR?: ValidationWhereInput[]
    NOT?: ValidationWhereInput | ValidationWhereInput[]
    ended?: DateTimeNullableFilter<"Validation"> | Date | string | null
    scope?: StringNullableFilter<"Validation"> | string | null
    started?: DateTimeFilter<"Validation"> | Date | string
    status?: StringNullableFilter<"Validation"> | string | null
    submissionID?: StringFilter<"Validation"> | string
    type?: StringNullableListFilter<"Validation">
    submission?: XOR<SubmissionScalarRelationFilter, SubmissionWhereInput>
  }, "id">

  export type ValidationOrderByWithAggregationInput = {
    id?: SortOrder
    ended?: SortOrder
    scope?: SortOrder
    started?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    type?: SortOrder
    _count?: ValidationCountOrderByAggregateInput
    _max?: ValidationMaxOrderByAggregateInput
    _min?: ValidationMinOrderByAggregateInput
  }

  export type ValidationScalarWhereWithAggregatesInput = {
    AND?: ValidationScalarWhereWithAggregatesInput | ValidationScalarWhereWithAggregatesInput[]
    OR?: ValidationScalarWhereWithAggregatesInput[]
    NOT?: ValidationScalarWhereWithAggregatesInput | ValidationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Validation"> | string
    ended?: DateTimeNullableWithAggregatesFilter<"Validation"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Validation"> | string | null
    started?: DateTimeWithAggregatesFilter<"Validation"> | Date | string
    status?: StringNullableWithAggregatesFilter<"Validation"> | string | null
    submissionID?: StringWithAggregatesFilter<"Validation"> | string
    type?: StringNullableListFilter<"Validation">
  }

  export type CDECreateInput = {
    id?: string
    CDECode: string
    CDEFullName: string
    CDEVersion?: string | null
    PermissibleValues?: CDECreatePermissibleValuesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CDEUncheckedCreateInput = {
    id?: string
    CDECode: string
    CDEFullName: string
    CDEVersion?: string | null
    PermissibleValues?: CDECreatePermissibleValuesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CDEUpdateInput = {
    CDECode?: StringFieldUpdateOperationsInput | string
    CDEFullName?: StringFieldUpdateOperationsInput | string
    CDEVersion?: NullableStringFieldUpdateOperationsInput | string | null
    PermissibleValues?: CDEUpdatePermissibleValuesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CDEUncheckedUpdateInput = {
    CDECode?: StringFieldUpdateOperationsInput | string
    CDEFullName?: StringFieldUpdateOperationsInput | string
    CDEVersion?: NullableStringFieldUpdateOperationsInput | string | null
    PermissibleValues?: CDEUpdatePermissibleValuesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CDECreateManyInput = {
    id?: string
    CDECode: string
    CDEFullName: string
    CDEVersion?: string | null
    PermissibleValues?: CDECreatePermissibleValuesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CDEUpdateManyMutationInput = {
    CDECode?: StringFieldUpdateOperationsInput | string
    CDEFullName?: StringFieldUpdateOperationsInput | string
    CDEVersion?: NullableStringFieldUpdateOperationsInput | string | null
    PermissibleValues?: CDEUpdatePermissibleValuesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CDEUncheckedUpdateManyInput = {
    CDECode?: StringFieldUpdateOperationsInput | string
    CDEFullName?: StringFieldUpdateOperationsInput | string
    CDEVersion?: NullableStringFieldUpdateOperationsInput | string | null
    PermissibleValues?: CDEUpdatePermissibleValuesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateInput = {
    id?: string
    version: string
    ORCID?: string | null
    PI?: string | null
    applicant: XOR<ApplicantCreateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    openAccess?: boolean | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: string | null
    programDescription?: string | null
    programName: string
    questionnaireData: string
    reviewComment?: string | null
    status: string
    studyAbbreviation: string
    studyName: string
    submittedDate?: Date | string | null
    wholeProgram?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUncheckedCreateInput = {
    id?: string
    version: string
    ORCID?: string | null
    PI?: string | null
    applicant: XOR<ApplicantCreateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    openAccess?: boolean | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: string | null
    programDescription?: string | null
    programName: string
    questionnaireData: string
    reviewComment?: string | null
    status: string
    studyAbbreviation: string
    studyName: string
    submittedDate?: Date | string | null
    wholeProgram?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    applicant?: XOR<ApplicantUpdateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    programDescription?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: StringFieldUpdateOperationsInput | string
    questionnaireData?: StringFieldUpdateOperationsInput | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    submittedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeProgram?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    applicant?: XOR<ApplicantUpdateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    programDescription?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: StringFieldUpdateOperationsInput | string
    questionnaireData?: StringFieldUpdateOperationsInput | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    submittedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeProgram?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateManyInput = {
    id?: string
    version: string
    ORCID?: string | null
    PI?: string | null
    applicant: XOR<ApplicantCreateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    openAccess?: boolean | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: string | null
    programDescription?: string | null
    programName: string
    questionnaireData: string
    reviewComment?: string | null
    status: string
    studyAbbreviation: string
    studyName: string
    submittedDate?: Date | string | null
    wholeProgram?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApplicationUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    applicant?: XOR<ApplicantUpdateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    programDescription?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: StringFieldUpdateOperationsInput | string
    questionnaireData?: StringFieldUpdateOperationsInput | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    submittedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeProgram?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    applicant?: XOR<ApplicantUpdateEnvelopeInput, ApplicantCreateInput>
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    programAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    programDescription?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: StringFieldUpdateOperationsInput | string
    questionnaireData?: StringFieldUpdateOperationsInput | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    submittedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wholeProgram?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovedStudyCreateInput = {
    id?: string
    ORCID?: string | null
    PI?: string | null
    controlledAccess: boolean
    dbGaPID?: string | null
    openAccess?: boolean | null
    originalOrg?: string | null
    programName?: string | null
    studyAbbreviation: string
    studyName: string
    useProgramPC?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Concierge?: UserCreateNestedOneWithoutApprovedStudiesInput
  }

  export type ApprovedStudyUncheckedCreateInput = {
    id?: string
    ORCID?: string | null
    PI?: string | null
    controlledAccess: boolean
    dbGaPID?: string | null
    openAccess?: boolean | null
    originalOrg?: string | null
    primaryContactID?: string | null
    programName?: string | null
    studyAbbreviation: string
    studyName: string
    useProgramPC?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovedStudyUpdateInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: BoolFieldUpdateOperationsInput | boolean
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalOrg?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: NullableStringFieldUpdateOperationsInput | string | null
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    useProgramPC?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Concierge?: UserUpdateOneWithoutApprovedStudiesNestedInput
  }

  export type ApprovedStudyUncheckedUpdateInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: BoolFieldUpdateOperationsInput | boolean
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalOrg?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactID?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: NullableStringFieldUpdateOperationsInput | string | null
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    useProgramPC?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovedStudyCreateManyInput = {
    id?: string
    ORCID?: string | null
    PI?: string | null
    controlledAccess: boolean
    dbGaPID?: string | null
    openAccess?: boolean | null
    originalOrg?: string | null
    primaryContactID?: string | null
    programName?: string | null
    studyAbbreviation: string
    studyName: string
    useProgramPC?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovedStudyUpdateManyMutationInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: BoolFieldUpdateOperationsInput | boolean
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalOrg?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: NullableStringFieldUpdateOperationsInput | string | null
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    useProgramPC?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovedStudyUncheckedUpdateManyInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: BoolFieldUpdateOperationsInput | boolean
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalOrg?: NullableStringFieldUpdateOperationsInput | string | null
    primaryContactID?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: NullableStringFieldUpdateOperationsInput | string | null
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    useProgramPC?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateInput = {
    id?: string
    bucketName: string
    displayID: number
    errors?: BatchCreateerrorsInput | string[]
    fileCount: number
    filePrefix: string
    files?: XOR<BatchFilesListCreateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status: string
    submitterID?: string | null
    submitterName?: string | null
    type: string
    zipFileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submission: SubmissionCreateNestedOneWithoutBatchesInput
  }

  export type BatchUncheckedCreateInput = {
    id?: string
    bucketName: string
    displayID: number
    errors?: BatchCreateerrorsInput | string[]
    fileCount: number
    filePrefix: string
    files?: XOR<BatchFilesListCreateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status: string
    submissionID: string
    submitterID?: string | null
    submitterName?: string | null
    type: string
    zipFileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUpdateInput = {
    bucketName?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: BatchUpdateerrorsInput | string[]
    fileCount?: IntFieldUpdateOperationsInput | number
    filePrefix?: StringFieldUpdateOperationsInput | string
    files?: XOR<BatchFilesListUpdateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status?: StringFieldUpdateOperationsInput | string
    submitterID?: NullableStringFieldUpdateOperationsInput | string | null
    submitterName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    zipFileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submission?: SubmissionUpdateOneRequiredWithoutBatchesNestedInput
  }

  export type BatchUncheckedUpdateInput = {
    bucketName?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: BatchUpdateerrorsInput | string[]
    fileCount?: IntFieldUpdateOperationsInput | number
    filePrefix?: StringFieldUpdateOperationsInput | string
    files?: XOR<BatchFilesListUpdateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submitterID?: NullableStringFieldUpdateOperationsInput | string | null
    submitterName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    zipFileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateManyInput = {
    id?: string
    bucketName: string
    displayID: number
    errors?: BatchCreateerrorsInput | string[]
    fileCount: number
    filePrefix: string
    files?: XOR<BatchFilesListCreateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status: string
    submissionID: string
    submitterID?: string | null
    submitterName?: string | null
    type: string
    zipFileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUpdateManyMutationInput = {
    bucketName?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: BatchUpdateerrorsInput | string[]
    fileCount?: IntFieldUpdateOperationsInput | number
    filePrefix?: StringFieldUpdateOperationsInput | string
    files?: XOR<BatchFilesListUpdateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status?: StringFieldUpdateOperationsInput | string
    submitterID?: NullableStringFieldUpdateOperationsInput | string | null
    submitterName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    zipFileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUncheckedUpdateManyInput = {
    bucketName?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: BatchUpdateerrorsInput | string[]
    fileCount?: IntFieldUpdateOperationsInput | number
    filePrefix?: StringFieldUpdateOperationsInput | string
    files?: XOR<BatchFilesListUpdateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submitterID?: NullableStringFieldUpdateOperationsInput | string | null
    submitterName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    zipFileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationCreateInput = {
    id?: string
    COMPLETED_RETENTION_DAYS?: number | null
    DASHBOARD_SESSION_TIMEOUT?: number | null
    Defaults?: XOR<PBACDefaultsListCreateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: string | null
    INACTIVE_APPLICATION_DAYS?: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: number | null
    INACTIVE_USER_DAYS?: number | null
    OFFICIAL_EMAIL?: string | null
    PRESIGN_EXPIRATION?: number | null
    PROD_URL?: string | null
    REMIND_APPLICATION_DAYS?: number | null
    REVIEW_COMMITTEE_EMAIL?: ConfigurationCreateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: number | null
    SCHEDULED_JOBS?: string | null
    SUBMISSION_BUCKET?: string | null
    SUBMISSION_HELPDESK?: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: string | null
    SUBMISSION_SYSTEM_PORTAL?: string | null
    TECH_SUPPORT_EMAIL?: string | null
    age?: number | null
    bucketName?: string | null
    current?: string | null
    current_version?: string | null
    dashboardID?: string | null
    dataCommons?: string | null
    days?: number | null
    interval?: number | null
    key?: ConfigurationCreatekeyInput | string[]
    keys?: InputJsonValue | null
    new?: string | null
    prefix?: string | null
    tag?: XOR<ConfigurationTagNullableCreateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: number | null
    type: string
    version?: string | null
  }

  export type ConfigurationUncheckedCreateInput = {
    id?: string
    COMPLETED_RETENTION_DAYS?: number | null
    DASHBOARD_SESSION_TIMEOUT?: number | null
    Defaults?: XOR<PBACDefaultsListCreateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: string | null
    INACTIVE_APPLICATION_DAYS?: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: number | null
    INACTIVE_USER_DAYS?: number | null
    OFFICIAL_EMAIL?: string | null
    PRESIGN_EXPIRATION?: number | null
    PROD_URL?: string | null
    REMIND_APPLICATION_DAYS?: number | null
    REVIEW_COMMITTEE_EMAIL?: ConfigurationCreateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: number | null
    SCHEDULED_JOBS?: string | null
    SUBMISSION_BUCKET?: string | null
    SUBMISSION_HELPDESK?: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: string | null
    SUBMISSION_SYSTEM_PORTAL?: string | null
    TECH_SUPPORT_EMAIL?: string | null
    age?: number | null
    bucketName?: string | null
    current?: string | null
    current_version?: string | null
    dashboardID?: string | null
    dataCommons?: string | null
    days?: number | null
    interval?: number | null
    key?: ConfigurationCreatekeyInput | string[]
    keys?: InputJsonValue | null
    new?: string | null
    prefix?: string | null
    tag?: XOR<ConfigurationTagNullableCreateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: number | null
    type: string
    version?: string | null
  }

  export type ConfigurationUpdateInput = {
    COMPLETED_RETENTION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    DASHBOARD_SESSION_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    Defaults?: XOR<PBACDefaultsListUpdateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: NullableStringFieldUpdateOperationsInput | string | null
    INACTIVE_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_USER_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    OFFICIAL_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PRESIGN_EXPIRATION?: NullableIntFieldUpdateOperationsInput | number | null
    PROD_URL?: NullableStringFieldUpdateOperationsInput | string | null
    REMIND_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    REVIEW_COMMITTEE_EMAIL?: ConfigurationUpdateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    SCHEDULED_JOBS?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_BUCKET?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_HELPDESK?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_SYSTEM_PORTAL?: NullableStringFieldUpdateOperationsInput | string | null
    TECH_SUPPORT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    current?: NullableStringFieldUpdateOperationsInput | string | null
    current_version?: NullableStringFieldUpdateOperationsInput | string | null
    dashboardID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: NullableStringFieldUpdateOperationsInput | string | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    key?: ConfigurationUpdatekeyInput | string[]
    keys?: InputJsonValue | InputJsonValue | null
    new?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: XOR<ConfigurationTagNullableUpdateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigurationUncheckedUpdateInput = {
    COMPLETED_RETENTION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    DASHBOARD_SESSION_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    Defaults?: XOR<PBACDefaultsListUpdateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: NullableStringFieldUpdateOperationsInput | string | null
    INACTIVE_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_USER_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    OFFICIAL_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PRESIGN_EXPIRATION?: NullableIntFieldUpdateOperationsInput | number | null
    PROD_URL?: NullableStringFieldUpdateOperationsInput | string | null
    REMIND_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    REVIEW_COMMITTEE_EMAIL?: ConfigurationUpdateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    SCHEDULED_JOBS?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_BUCKET?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_HELPDESK?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_SYSTEM_PORTAL?: NullableStringFieldUpdateOperationsInput | string | null
    TECH_SUPPORT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    current?: NullableStringFieldUpdateOperationsInput | string | null
    current_version?: NullableStringFieldUpdateOperationsInput | string | null
    dashboardID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: NullableStringFieldUpdateOperationsInput | string | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    key?: ConfigurationUpdatekeyInput | string[]
    keys?: InputJsonValue | InputJsonValue | null
    new?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: XOR<ConfigurationTagNullableUpdateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigurationCreateManyInput = {
    id?: string
    COMPLETED_RETENTION_DAYS?: number | null
    DASHBOARD_SESSION_TIMEOUT?: number | null
    Defaults?: XOR<PBACDefaultsListCreateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: string | null
    INACTIVE_APPLICATION_DAYS?: number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: number | null
    INACTIVE_USER_DAYS?: number | null
    OFFICIAL_EMAIL?: string | null
    PRESIGN_EXPIRATION?: number | null
    PROD_URL?: string | null
    REMIND_APPLICATION_DAYS?: number | null
    REVIEW_COMMITTEE_EMAIL?: ConfigurationCreateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: number | null
    SCHEDULED_JOBS?: string | null
    SUBMISSION_BUCKET?: string | null
    SUBMISSION_HELPDESK?: string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: string | null
    SUBMISSION_SYSTEM_PORTAL?: string | null
    TECH_SUPPORT_EMAIL?: string | null
    age?: number | null
    bucketName?: string | null
    current?: string | null
    current_version?: string | null
    dashboardID?: string | null
    dataCommons?: string | null
    days?: number | null
    interval?: number | null
    key?: ConfigurationCreatekeyInput | string[]
    keys?: InputJsonValue | null
    new?: string | null
    prefix?: string | null
    tag?: XOR<ConfigurationTagNullableCreateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: number | null
    type: string
    version?: string | null
  }

  export type ConfigurationUpdateManyMutationInput = {
    COMPLETED_RETENTION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    DASHBOARD_SESSION_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    Defaults?: XOR<PBACDefaultsListUpdateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: NullableStringFieldUpdateOperationsInput | string | null
    INACTIVE_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_USER_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    OFFICIAL_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PRESIGN_EXPIRATION?: NullableIntFieldUpdateOperationsInput | number | null
    PROD_URL?: NullableStringFieldUpdateOperationsInput | string | null
    REMIND_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    REVIEW_COMMITTEE_EMAIL?: ConfigurationUpdateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    SCHEDULED_JOBS?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_BUCKET?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_HELPDESK?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_SYSTEM_PORTAL?: NullableStringFieldUpdateOperationsInput | string | null
    TECH_SUPPORT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    current?: NullableStringFieldUpdateOperationsInput | string | null
    current_version?: NullableStringFieldUpdateOperationsInput | string | null
    dashboardID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: NullableStringFieldUpdateOperationsInput | string | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    key?: ConfigurationUpdatekeyInput | string[]
    keys?: InputJsonValue | InputJsonValue | null
    new?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: XOR<ConfigurationTagNullableUpdateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigurationUncheckedUpdateManyInput = {
    COMPLETED_RETENTION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    DASHBOARD_SESSION_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    Defaults?: XOR<PBACDefaultsListUpdateEnvelopeInput, PBACDefaultsCreateInput> | PBACDefaultsCreateInput[]
    EMAIL_URL?: NullableStringFieldUpdateOperationsInput | string | null
    INACTIVE_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_SUBMISSION_DAYS_DELETE?: NullableIntFieldUpdateOperationsInput | number | null
    INACTIVE_USER_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    OFFICIAL_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    PRESIGN_EXPIRATION?: NullableIntFieldUpdateOperationsInput | number | null
    PROD_URL?: NullableStringFieldUpdateOperationsInput | string | null
    REMIND_APPLICATION_DAYS?: NullableIntFieldUpdateOperationsInput | number | null
    REVIEW_COMMITTEE_EMAIL?: ConfigurationUpdateREVIEW_COMMITTEE_EMAILInput | string[]
    ROLE_TIMEOUT?: NullableIntFieldUpdateOperationsInput | number | null
    SCHEDULED_JOBS?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_BUCKET?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_HELPDESK?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_REQUEST_CONTACT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    SUBMISSION_SYSTEM_PORTAL?: NullableStringFieldUpdateOperationsInput | string | null
    TECH_SUPPORT_EMAIL?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    current?: NullableStringFieldUpdateOperationsInput | string | null
    current_version?: NullableStringFieldUpdateOperationsInput | string | null
    dashboardID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: NullableStringFieldUpdateOperationsInput | string | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    interval?: NullableIntFieldUpdateOperationsInput | number | null
    key?: ConfigurationUpdatekeyInput | string[]
    keys?: InputJsonValue | InputJsonValue | null
    new?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: XOR<ConfigurationTagNullableUpdateEnvelopeInput, ConfigurationTagCreateInput> | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    type?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataRecordCreateInput = {
    id?: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordCreatebatchIDsInput | string[]
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID: string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
    submission: SubmissionCreateNestedOneWithoutDataRecordsInput
  }

  export type DataRecordUncheckedCreateInput = {
    id?: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordCreatebatchIDsInput | string[]
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID: string
    submissionID: string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRecordUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordUpdatebatchIDsInput | string[]
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submission?: SubmissionUpdateOneRequiredWithoutDataRecordsNestedInput
  }

  export type DataRecordUncheckedUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordUpdatebatchIDsInput | string[]
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRecordCreateManyInput = {
    id?: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordCreatebatchIDsInput | string[]
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID: string
    submissionID: string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRecordUpdateManyMutationInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordUpdatebatchIDsInput | string[]
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRecordUncheckedUpdateManyInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordUpdatebatchIDsInput | string[]
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRecordsArchivedCreateInput = {
    id?: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordsArchivedCreatebatchIDsInput | string[]
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID?: string | null
    submissionID: string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRecordsArchivedUncheckedCreateInput = {
    id?: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordsArchivedCreatebatchIDsInput | string[]
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID?: string | null
    submissionID: string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRecordsArchivedUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordsArchivedUpdatebatchIDsInput | string[]
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRecordsArchivedUncheckedUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordsArchivedUpdatebatchIDsInput | string[]
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRecordsArchivedCreateManyInput = {
    id?: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordsArchivedCreatebatchIDsInput | string[]
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID?: string | null
    submissionID: string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRecordsArchivedUpdateManyMutationInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordsArchivedUpdatebatchIDsInput | string[]
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRecordsArchivedUncheckedUpdateManyInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordsArchivedUpdatebatchIDsInput | string[]
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileMD5CreateInput = {
    id?: string
    LastModified: Date | string
    fileName: string
    md5: string
    submissionID: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileMD5UncheckedCreateInput = {
    id?: string
    LastModified: Date | string
    fileName: string
    md5: string
    submissionID: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileMD5UpdateInput = {
    LastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    md5?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileMD5UncheckedUpdateInput = {
    LastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    md5?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileMD5CreateManyInput = {
    id?: string
    LastModified: Date | string
    fileName: string
    md5: string
    submissionID: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileMD5UpdateManyMutationInput = {
    LastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    md5?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileMD5UncheckedUpdateManyInput = {
    LastModified?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    md5?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionCreateInput = {
    id?: string
    name: string
    status: string
    submitterCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type InstitutionUncheckedCreateInput = {
    id?: string
    name: string
    status: string
    submitterCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type InstitutionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submitterCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstitutionUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submitterCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstitutionCreateManyInput = {
    id?: string
    name: string
    status: string
    submitterCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type InstitutionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submitterCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstitutionUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    submitterCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogCreateInput = {
    id?: string
    action?: string | null
    applicationID?: string | null
    eventDetail?: XOR<LogsEventDetailNullableCreateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType: string
    localtime: Date | string
    newProfile?: InputJsonValue | null
    newState?: string | null
    prevProfile?: InputJsonValue | null
    prevState?: string | null
    submissionID?: string | null
    timestamp: number
    userEmail: string
    userID: string
    userIDP?: string | null
    userName?: string | null
  }

  export type LogUncheckedCreateInput = {
    id?: string
    action?: string | null
    applicationID?: string | null
    eventDetail?: XOR<LogsEventDetailNullableCreateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType: string
    localtime: Date | string
    newProfile?: InputJsonValue | null
    newState?: string | null
    prevProfile?: InputJsonValue | null
    prevState?: string | null
    submissionID?: string | null
    timestamp: number
    userEmail: string
    userID: string
    userIDP?: string | null
    userName?: string | null
  }

  export type LogUpdateInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    applicationID?: NullableStringFieldUpdateOperationsInput | string | null
    eventDetail?: XOR<LogsEventDetailNullableUpdateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType?: StringFieldUpdateOperationsInput | string
    localtime?: DateTimeFieldUpdateOperationsInput | Date | string
    newProfile?: InputJsonValue | InputJsonValue | null
    newState?: NullableStringFieldUpdateOperationsInput | string | null
    prevProfile?: InputJsonValue | InputJsonValue | null
    prevState?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: FloatFieldUpdateOperationsInput | number
    userEmail?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    userIDP?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    applicationID?: NullableStringFieldUpdateOperationsInput | string | null
    eventDetail?: XOR<LogsEventDetailNullableUpdateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType?: StringFieldUpdateOperationsInput | string
    localtime?: DateTimeFieldUpdateOperationsInput | Date | string
    newProfile?: InputJsonValue | InputJsonValue | null
    newState?: NullableStringFieldUpdateOperationsInput | string | null
    prevProfile?: InputJsonValue | InputJsonValue | null
    prevState?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: FloatFieldUpdateOperationsInput | number
    userEmail?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    userIDP?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogCreateManyInput = {
    id?: string
    action?: string | null
    applicationID?: string | null
    eventDetail?: XOR<LogsEventDetailNullableCreateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType: string
    localtime: Date | string
    newProfile?: InputJsonValue | null
    newState?: string | null
    prevProfile?: InputJsonValue | null
    prevState?: string | null
    submissionID?: string | null
    timestamp: number
    userEmail: string
    userID: string
    userIDP?: string | null
    userName?: string | null
  }

  export type LogUpdateManyMutationInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    applicationID?: NullableStringFieldUpdateOperationsInput | string | null
    eventDetail?: XOR<LogsEventDetailNullableUpdateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType?: StringFieldUpdateOperationsInput | string
    localtime?: DateTimeFieldUpdateOperationsInput | Date | string
    newProfile?: InputJsonValue | InputJsonValue | null
    newState?: NullableStringFieldUpdateOperationsInput | string | null
    prevProfile?: InputJsonValue | InputJsonValue | null
    prevState?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: FloatFieldUpdateOperationsInput | number
    userEmail?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    userIDP?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    applicationID?: NullableStringFieldUpdateOperationsInput | string | null
    eventDetail?: XOR<LogsEventDetailNullableUpdateEnvelopeInput, LogsEventDetailCreateInput> | null
    eventType?: StringFieldUpdateOperationsInput | string
    localtime?: DateTimeFieldUpdateOperationsInput | Date | string
    newProfile?: InputJsonValue | InputJsonValue | null
    newState?: NullableStringFieldUpdateOperationsInput | string | null
    prevProfile?: InputJsonValue | InputJsonValue | null
    prevState?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: FloatFieldUpdateOperationsInput | number
    userEmail?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    userIDP?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramCreateInput = {
    id?: string
    abbreviation?: string | null
    bucketName?: string | null
    conciergeEmail?: string | null
    conciergeName?: string | null
    description?: string | null
    name: string
    rootPath?: string | null
    status: string
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: Date | string
    updateAt?: Date | string
    Concierge?: UserCreateNestedOneWithoutProgramsInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: string
    abbreviation?: string | null
    bucketName?: string | null
    conciergeEmail?: string | null
    conciergeID?: string | null
    conciergeName?: string | null
    description?: string | null
    name: string
    rootPath?: string | null
    status: string
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramUpdateInput = {
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rootPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Concierge?: UserUpdateOneWithoutProgramsNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeID?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rootPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateManyInput = {
    id?: string
    abbreviation?: string | null
    bucketName?: string | null
    conciergeEmail?: string | null
    conciergeID?: string | null
    conciergeName?: string | null
    description?: string | null
    name: string
    rootPath?: string | null
    status: string
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramUpdateManyMutationInput = {
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rootPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateManyInput = {
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeID?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rootPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QcResultCreateInput = {
    id?: string
    batchIDs?: QcResultCreatebatchIDsInput | string[]
    dataRecordID: string
    displayID: number
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID: string
    origin?: string | null
    severity: string
    submittedID: string
    type: string
    uploadedDate: Date | string
    validatedDate: Date | string
    validationType: string
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    submission: SubmissionCreateNestedOneWithoutQcResultsInput
  }

  export type QcResultUncheckedCreateInput = {
    id?: string
    batchIDs?: QcResultCreatebatchIDsInput | string[]
    dataRecordID: string
    displayID: number
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID: string
    origin?: string | null
    severity: string
    submissionID: string
    submittedID: string
    type: string
    uploadedDate: Date | string
    validatedDate: Date | string
    validationType: string
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type QcResultUpdateInput = {
    batchIDs?: QcResultUpdatebatchIDsInput | string[]
    dataRecordID?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    submittedID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validationType?: StringFieldUpdateOperationsInput | string
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    submission?: SubmissionUpdateOneRequiredWithoutQcResultsNestedInput
  }

  export type QcResultUncheckedUpdateInput = {
    batchIDs?: QcResultUpdatebatchIDsInput | string[]
    dataRecordID?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submittedID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validationType?: StringFieldUpdateOperationsInput | string
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type QcResultCreateManyInput = {
    id?: string
    batchIDs?: QcResultCreatebatchIDsInput | string[]
    dataRecordID: string
    displayID: number
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID: string
    origin?: string | null
    severity: string
    submissionID: string
    submittedID: string
    type: string
    uploadedDate: Date | string
    validatedDate: Date | string
    validationType: string
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type QcResultUpdateManyMutationInput = {
    batchIDs?: QcResultUpdatebatchIDsInput | string[]
    dataRecordID?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    submittedID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validationType?: StringFieldUpdateOperationsInput | string
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type QcResultUncheckedUpdateManyInput = {
    batchIDs?: QcResultUpdatebatchIDsInput | string[]
    dataRecordID?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
    submittedID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validationType?: StringFieldUpdateOperationsInput | string
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type ReleaseCreateInput = {
    id?: string
    CRDC_ID?: string | null
    dataCommons: string
    entityType?: string | null
    nodeID: string
    nodeType: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    status: string
    studyID?: string | null
    submissionID: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ReleaseUncheckedCreateInput = {
    id?: string
    CRDC_ID?: string | null
    dataCommons: string
    entityType?: string | null
    nodeID: string
    nodeType: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    status: string
    studyID?: string | null
    submissionID: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ReleaseUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReleaseUncheckedUpdateInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReleaseCreateManyInput = {
    id?: string
    CRDC_ID?: string | null
    dataCommons: string
    entityType?: string | null
    nodeID: string
    nodeType: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    status: string
    studyID?: string | null
    submissionID: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ReleaseUpdateManyMutationInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReleaseUncheckedUpdateManyInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    studyID?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubmissionCreateInput = {
    id?: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: SubmissionCreatevalidationTypeInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchCreateNestedManyWithoutSubmissionInput
    dataRecords?: DataRecordCreateNestedManyWithoutSubmissionInput
    qcResults?: QcResultCreateNestedManyWithoutSubmissionInput
    validations?: ValidationCreateNestedManyWithoutSubmissionInput
  }

  export type SubmissionUncheckedCreateInput = {
    id?: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: SubmissionCreatevalidationTypeInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutSubmissionInput
    dataRecords?: DataRecordUncheckedCreateNestedManyWithoutSubmissionInput
    qcResults?: QcResultUncheckedCreateNestedManyWithoutSubmissionInput
    validations?: ValidationUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type SubmissionUpdateInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUpdateManyWithoutSubmissionNestedInput
    dataRecords?: DataRecordUpdateManyWithoutSubmissionNestedInput
    qcResults?: QcResultUpdateManyWithoutSubmissionNestedInput
    validations?: ValidationUpdateManyWithoutSubmissionNestedInput
  }

  export type SubmissionUncheckedUpdateInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutSubmissionNestedInput
    dataRecords?: DataRecordUncheckedUpdateManyWithoutSubmissionNestedInput
    qcResults?: QcResultUncheckedUpdateManyWithoutSubmissionNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type SubmissionCreateManyInput = {
    id?: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: SubmissionCreatevalidationTypeInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubmissionUpdateManyMutationInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUncheckedUpdateManyInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SynonymCreateInput = {
    id?: string
    equivalent_term: string
    synonym_term: string
  }

  export type SynonymUncheckedCreateInput = {
    id?: string
    equivalent_term: string
    synonym_term: string
  }

  export type SynonymUpdateInput = {
    equivalent_term?: StringFieldUpdateOperationsInput | string
    synonym_term?: StringFieldUpdateOperationsInput | string
  }

  export type SynonymUncheckedUpdateInput = {
    equivalent_term?: StringFieldUpdateOperationsInput | string
    synonym_term?: StringFieldUpdateOperationsInput | string
  }

  export type SynonymCreateManyInput = {
    id?: string
    equivalent_term: string
    synonym_term: string
  }

  export type SynonymUpdateManyMutationInput = {
    equivalent_term?: StringFieldUpdateOperationsInput | string
    synonym_term?: StringFieldUpdateOperationsInput | string
  }

  export type SynonymUncheckedUpdateManyInput = {
    equivalent_term?: StringFieldUpdateOperationsInput | string
    synonym_term?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    IDP: string
    dataCommons?: UserCreatedataCommonsInput | string[]
    email: string
    firstName: string
    institution?: XOR<InstitutionInfoNullableCreateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName: string
    notifications?: UserCreatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableCreateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserCreatepermissionsInput | string[]
    role: string
    status?: string | null
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserCreatetokensInput | string[]
    userStatus: string
    createdAt?: Date | string
    updateAt?: Date | string
    programs?: ProgramCreateNestedManyWithoutConciergeInput
    approvedStudies?: ApprovedStudyCreateNestedManyWithoutConciergeInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    IDP: string
    dataCommons?: UserCreatedataCommonsInput | string[]
    email: string
    firstName: string
    institution?: XOR<InstitutionInfoNullableCreateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName: string
    notifications?: UserCreatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableCreateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserCreatepermissionsInput | string[]
    role: string
    status?: string | null
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserCreatetokensInput | string[]
    userStatus: string
    createdAt?: Date | string
    updateAt?: Date | string
    programs?: ProgramUncheckedCreateNestedManyWithoutConciergeInput
    approvedStudies?: ApprovedStudyUncheckedCreateNestedManyWithoutConciergeInput
  }

  export type UserUpdateInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    dataCommons?: UserUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionInfoNullableUpdateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: UserUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserUpdatetokensInput | string[]
    userStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUpdateManyWithoutConciergeNestedInput
    approvedStudies?: ApprovedStudyUpdateManyWithoutConciergeNestedInput
  }

  export type UserUncheckedUpdateInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    dataCommons?: UserUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionInfoNullableUpdateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: UserUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserUpdatetokensInput | string[]
    userStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUncheckedUpdateManyWithoutConciergeNestedInput
    approvedStudies?: ApprovedStudyUncheckedUpdateManyWithoutConciergeNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    IDP: string
    dataCommons?: UserCreatedataCommonsInput | string[]
    email: string
    firstName: string
    institution?: XOR<InstitutionInfoNullableCreateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName: string
    notifications?: UserCreatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableCreateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserCreatepermissionsInput | string[]
    role: string
    status?: string | null
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserCreatetokensInput | string[]
    userStatus: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    dataCommons?: UserUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionInfoNullableUpdateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: UserUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserUpdatetokensInput | string[]
    userStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    dataCommons?: UserUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionInfoNullableUpdateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: UserUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserUpdatetokensInput | string[]
    userStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationCreateInput = {
    id?: string
    ended?: Date | string | null
    scope?: string | null
    started: Date | string
    status?: string | null
    type?: ValidationCreatetypeInput | string[]
    submission: SubmissionCreateNestedOneWithoutValidationsInput
  }

  export type ValidationUncheckedCreateInput = {
    id?: string
    ended?: Date | string | null
    scope?: string | null
    started: Date | string
    status?: string | null
    submissionID: string
    type?: ValidationCreatetypeInput | string[]
  }

  export type ValidationUpdateInput = {
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: ValidationUpdatetypeInput | string[]
    submission?: SubmissionUpdateOneRequiredWithoutValidationsNestedInput
  }

  export type ValidationUncheckedUpdateInput = {
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    type?: ValidationUpdatetypeInput | string[]
  }

  export type ValidationCreateManyInput = {
    id?: string
    ended?: Date | string | null
    scope?: string | null
    started: Date | string
    status?: string | null
    submissionID: string
    type?: ValidationCreatetypeInput | string[]
  }

  export type ValidationUpdateManyMutationInput = {
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: ValidationUpdatetypeInput | string[]
  }

  export type ValidationUncheckedUpdateManyInput = {
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submissionID?: StringFieldUpdateOperationsInput | string
    type?: ValidationUpdatetypeInput | string[]
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CDECountOrderByAggregateInput = {
    id?: SortOrder
    CDECode?: SortOrder
    CDEFullName?: SortOrder
    CDEVersion?: SortOrder
    PermissibleValues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CDEMaxOrderByAggregateInput = {
    id?: SortOrder
    CDECode?: SortOrder
    CDEFullName?: SortOrder
    CDEVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CDEMinOrderByAggregateInput = {
    id?: SortOrder
    CDECode?: SortOrder
    CDEFullName?: SortOrder
    CDEVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ApplicantCompositeFilter = {
    equals?: ApplicantObjectEqualityInput
    is?: ApplicantWhereInput
    isNot?: ApplicantWhereInput
  }

  export type ApplicantObjectEqualityInput = {
    applicantEmail: string
    applicantID: string
    applicantName: string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type HistoryCompositeListFilter = {
    equals?: HistoryObjectEqualityInput[]
    every?: HistoryWhereInput
    some?: HistoryWhereInput
    none?: HistoryWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type HistoryObjectEqualityInput = {
    dateTime: Date | string
    reviewComment?: string | null
    status: string
    userID: string
    userName?: string | null
  }

  export type OrgInfoCompositeFilter = {
    equals?: OrgInfoObjectEqualityInput
    is?: OrgInfoWhereInput
    isNot?: OrgInfoWhereInput
  }

  export type OrgInfoObjectEqualityInput = {
    id: string
    name: string
    status?: string | null
    createdAt?: Date | string | null
    updateAt?: Date | string | null
    orgID?: string | null
    orgName?: string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type ApplicantOrderByInput = {
    applicantEmail?: SortOrder
    applicantID?: SortOrder
    applicantName?: SortOrder
  }

  export type HistoryOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type OrgInfoOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    orgID?: SortOrder
    orgName?: SortOrder
  }

  export type ApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    inactiveReminder?: SortOrder
    openAccess?: SortOrder
    programAbbreviation?: SortOrder
    programDescription?: SortOrder
    programName?: SortOrder
    questionnaireData?: SortOrder
    reviewComment?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    submittedDate?: SortOrder
    wholeProgram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    inactiveReminder?: SortOrder
    openAccess?: SortOrder
    programAbbreviation?: SortOrder
    programDescription?: SortOrder
    programName?: SortOrder
    questionnaireData?: SortOrder
    reviewComment?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    submittedDate?: SortOrder
    wholeProgram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    inactiveReminder?: SortOrder
    openAccess?: SortOrder
    programAbbreviation?: SortOrder
    programDescription?: SortOrder
    programName?: SortOrder
    questionnaireData?: SortOrder
    reviewComment?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    submittedDate?: SortOrder
    wholeProgram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ApprovedStudyCountOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    dbGaPID?: SortOrder
    openAccess?: SortOrder
    originalOrg?: SortOrder
    primaryContactID?: SortOrder
    programName?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    useProgramPC?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovedStudyMaxOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    dbGaPID?: SortOrder
    openAccess?: SortOrder
    originalOrg?: SortOrder
    primaryContactID?: SortOrder
    programName?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    useProgramPC?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovedStudyMinOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    PI?: SortOrder
    controlledAccess?: SortOrder
    dbGaPID?: SortOrder
    openAccess?: SortOrder
    originalOrg?: SortOrder
    primaryContactID?: SortOrder
    programName?: SortOrder
    studyAbbreviation?: SortOrder
    studyName?: SortOrder
    useProgramPC?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BatchFilesCompositeListFilter = {
    equals?: BatchFilesObjectEqualityInput[]
    every?: BatchFilesWhereInput
    some?: BatchFilesWhereInput
    none?: BatchFilesWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type BatchFilesObjectEqualityInput = {
    createdAt: Date | string
    errors?: string[]
    fileID?: string | null
    fileName: string
    filePrefix: string
    nodeType?: string | null
    signedURL?: string | null
    size?: number | null
    status: string
    updatedAt: Date | string
  }

  export type SubmissionScalarRelationFilter = {
    is?: SubmissionWhereInput
    isNot?: SubmissionWhereInput
  }

  export type BatchFilesOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type BatchCountOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    displayID?: SortOrder
    errors?: SortOrder
    fileCount?: SortOrder
    filePrefix?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    type?: SortOrder
    zipFileName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchAvgOrderByAggregateInput = {
    displayID?: SortOrder
    fileCount?: SortOrder
  }

  export type BatchMaxOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    displayID?: SortOrder
    fileCount?: SortOrder
    filePrefix?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    type?: SortOrder
    zipFileName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchMinOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    displayID?: SortOrder
    fileCount?: SortOrder
    filePrefix?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    type?: SortOrder
    zipFileName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchSumOrderByAggregateInput = {
    displayID?: SortOrder
    fileCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type PBACDefaultsCompositeListFilter = {
    equals?: PBACDefaultsObjectEqualityInput[]
    every?: PBACDefaultsWhereInput
    some?: PBACDefaultsWhereInput
    none?: PBACDefaultsWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type PBACDefaultsObjectEqualityInput = {
    notifications?: NotificationObjectEqualityInput[]
    permissions?: PermissionObjectEqualityInput[]
    role: string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type ConfigurationTagNullableCompositeFilter = {
    equals?: ConfigurationTagObjectEqualityInput | null
    is?: ConfigurationTagWhereInput | null
    isNot?: ConfigurationTagWhereInput | null
    isSet?: boolean
  }

  export type ConfigurationTagObjectEqualityInput = {
    Key: string
    Value: string
  }

  export type PBACDefaultsOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ConfigurationTagOrderByInput = {
    Key?: SortOrder
    Value?: SortOrder
  }

  export type ConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    EMAIL_URL?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    OFFICIAL_EMAIL?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    PROD_URL?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    REVIEW_COMMITTEE_EMAIL?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    SCHEDULED_JOBS?: SortOrder
    SUBMISSION_BUCKET?: SortOrder
    SUBMISSION_HELPDESK?: SortOrder
    SUBMISSION_REQUEST_CONTACT_EMAIL?: SortOrder
    SUBMISSION_SYSTEM_PORTAL?: SortOrder
    TECH_SUPPORT_EMAIL?: SortOrder
    age?: SortOrder
    bucketName?: SortOrder
    current?: SortOrder
    current_version?: SortOrder
    dashboardID?: SortOrder
    dataCommons?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    key?: SortOrder
    keys?: SortOrder
    new?: SortOrder
    prefix?: SortOrder
    timeout?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type ConfigurationAvgOrderByAggregateInput = {
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    age?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    timeout?: SortOrder
  }

  export type ConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    EMAIL_URL?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    OFFICIAL_EMAIL?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    PROD_URL?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    SCHEDULED_JOBS?: SortOrder
    SUBMISSION_BUCKET?: SortOrder
    SUBMISSION_HELPDESK?: SortOrder
    SUBMISSION_REQUEST_CONTACT_EMAIL?: SortOrder
    SUBMISSION_SYSTEM_PORTAL?: SortOrder
    TECH_SUPPORT_EMAIL?: SortOrder
    age?: SortOrder
    bucketName?: SortOrder
    current?: SortOrder
    current_version?: SortOrder
    dashboardID?: SortOrder
    dataCommons?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    new?: SortOrder
    prefix?: SortOrder
    timeout?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type ConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    EMAIL_URL?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    OFFICIAL_EMAIL?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    PROD_URL?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    SCHEDULED_JOBS?: SortOrder
    SUBMISSION_BUCKET?: SortOrder
    SUBMISSION_HELPDESK?: SortOrder
    SUBMISSION_REQUEST_CONTACT_EMAIL?: SortOrder
    SUBMISSION_SYSTEM_PORTAL?: SortOrder
    TECH_SUPPORT_EMAIL?: SortOrder
    age?: SortOrder
    bucketName?: SortOrder
    current?: SortOrder
    current_version?: SortOrder
    dashboardID?: SortOrder
    dataCommons?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    new?: SortOrder
    prefix?: SortOrder
    timeout?: SortOrder
    type?: SortOrder
    version?: SortOrder
  }

  export type ConfigurationSumOrderByAggregateInput = {
    COMPLETED_RETENTION_DAYS?: SortOrder
    DASHBOARD_SESSION_TIMEOUT?: SortOrder
    INACTIVE_APPLICATION_DAYS?: SortOrder
    INACTIVE_SUBMISSION_DAYS_DELETE?: SortOrder
    INACTIVE_USER_DAYS?: SortOrder
    PRESIGN_EXPIRATION?: SortOrder
    REMIND_APPLICATION_DAYS?: SortOrder
    ROLE_TIMEOUT?: SortOrder
    age?: SortOrder
    days?: SortOrder
    interval?: SortOrder
    timeout?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type AdditionalErrorCompositeListFilter = {
    equals?: AdditionalErrorObjectEqualityInput[]
    every?: AdditionalErrorWhereInput
    some?: AdditionalErrorWhereInput
    none?: AdditionalErrorWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type AdditionalErrorObjectEqualityInput = {
    conflictingSubmissions?: string[]
    description: string
    title: string
  }

  export type ErrorCompositeListFilter = {
    equals?: ErrorObjectEqualityInput[]
    every?: ErrorWhereInput
    some?: ErrorWhereInput
    none?: ErrorWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ErrorObjectEqualityInput = {
    title: string
    description: string
    code?: string | null
    offendingProperty?: string | null
    offendingValue?: string | null
    severity?: string | null
  }

  export type ParentCompositeListFilter = {
    equals?: ParentObjectEqualityInput[]
    every?: ParentWhereInput
    some?: ParentWhereInput
    none?: ParentWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ParentObjectEqualityInput = {
    parentIDPropName: string
    parentIDValue: string
    parentType: string
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type S3FileInfoNullableCompositeFilter = {
    equals?: S3FileInfoObjectEqualityInput | null
    is?: S3FileInfoWhereInput | null
    isNot?: S3FileInfoWhereInput | null
    isSet?: boolean
  }

  export type S3FileInfoObjectEqualityInput = {
    createdAt?: Date | string | null
    errors?: ErrorObjectEqualityInput[]
    fileName: string
    md5?: string | null
    size?: string | null
    status: string
    updatedAt?: Date | string | null
    warnings?: ErrorObjectEqualityInput[]
  }

  export type AdditionalErrorOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ErrorOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ParentOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type S3FileInfoOrderByInput = {
    createdAt?: SortOrder
    errors?: ErrorOrderByCompositeAggregateInput
    fileName?: SortOrder
    md5?: SortOrder
    size?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    warnings?: ErrorOrderByCompositeAggregateInput
  }

  export type DataRecordCountOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    batchIDs?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataRecordAvgOrderByAggregateInput = {
    latestBatchDisplayID?: SortOrder
    lineNumber?: SortOrder
  }

  export type DataRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    qcResultID?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataRecordMinOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    qcResultID?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataRecordSumOrderByAggregateInput = {
    latestBatchDisplayID?: SortOrder
    lineNumber?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DataRecordsArchivedCountOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    batchIDs?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    props?: SortOrder
    qcResultID?: SortOrder
    rawData?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataRecordsArchivedAvgOrderByAggregateInput = {
    latestBatchDisplayID?: SortOrder
    lineNumber?: SortOrder
  }

  export type DataRecordsArchivedMaxOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    qcResultID?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataRecordsArchivedMinOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    IDPropName?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    latestBatchDisplayID?: SortOrder
    latestBatchID?: SortOrder
    lineNumber?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    orginalFileName?: SortOrder
    qcResultID?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    uploadedDate?: SortOrder
    validatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataRecordsArchivedSumOrderByAggregateInput = {
    latestBatchDisplayID?: SortOrder
    lineNumber?: SortOrder
  }

  export type FileMD5CountOrderByAggregateInput = {
    id?: SortOrder
    LastModified?: SortOrder
    fileName?: SortOrder
    md5?: SortOrder
    submissionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileMD5MaxOrderByAggregateInput = {
    id?: SortOrder
    LastModified?: SortOrder
    fileName?: SortOrder
    md5?: SortOrder
    submissionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileMD5MinOrderByAggregateInput = {
    id?: SortOrder
    LastModified?: SortOrder
    fileName?: SortOrder
    md5?: SortOrder
    submissionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstitutionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    submitterCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstitutionAvgOrderByAggregateInput = {
    submitterCount?: SortOrder
  }

  export type InstitutionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    submitterCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstitutionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    submitterCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstitutionSumOrderByAggregateInput = {
    submitterCount?: SortOrder
  }

  export type LogsEventDetailNullableCompositeFilter = {
    equals?: LogsEventDetailObjectEqualityInput | null
    is?: LogsEventDetailWhereInput | null
    isNot?: LogsEventDetailWhereInput | null
    isSet?: boolean
  }

  export type LogsEventDetailObjectEqualityInput = {
    nodeIDs?: string[]
    nodeType: string
    submissionID: string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type LogsEventDetailOrderByInput = {
    nodeIDs?: SortOrder
    nodeType?: SortOrder
    submissionID?: SortOrder
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    applicationID?: SortOrder
    eventType?: SortOrder
    localtime?: SortOrder
    newProfile?: SortOrder
    newState?: SortOrder
    prevProfile?: SortOrder
    prevState?: SortOrder
    submissionID?: SortOrder
    timestamp?: SortOrder
    userEmail?: SortOrder
    userID?: SortOrder
    userIDP?: SortOrder
    userName?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    applicationID?: SortOrder
    eventType?: SortOrder
    localtime?: SortOrder
    newState?: SortOrder
    prevState?: SortOrder
    submissionID?: SortOrder
    timestamp?: SortOrder
    userEmail?: SortOrder
    userID?: SortOrder
    userIDP?: SortOrder
    userName?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    applicationID?: SortOrder
    eventType?: SortOrder
    localtime?: SortOrder
    newState?: SortOrder
    prevState?: SortOrder
    submissionID?: SortOrder
    timestamp?: SortOrder
    userEmail?: SortOrder
    userID?: SortOrder
    userIDP?: SortOrder
    userName?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StudyByIDCompositeListFilter = {
    equals?: StudyByIDObjectEqualityInput[]
    every?: StudyByIDWhereInput
    some?: StudyByIDWhereInput
    none?: StudyByIDWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type StudyByIDObjectEqualityInput = {
    id: string
  }

  export type StudyByIDOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    abbreviation?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeID?: SortOrder
    conciergeName?: SortOrder
    description?: SortOrder
    name?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    abbreviation?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeID?: SortOrder
    conciergeName?: SortOrder
    description?: SortOrder
    name?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    abbreviation?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeID?: SortOrder
    conciergeName?: SortOrder
    description?: SortOrder
    name?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QcResultCountOrderByAggregateInput = {
    id?: SortOrder
    batchIDs?: SortOrder
    dataRecordID?: SortOrder
    displayID?: SortOrder
    latestBatchID?: SortOrder
    origin?: SortOrder
    severity?: SortOrder
    submissionID?: SortOrder
    submittedID?: SortOrder
    type?: SortOrder
    uploadedDate?: SortOrder
    validatedDate?: SortOrder
    validationType?: SortOrder
  }

  export type QcResultAvgOrderByAggregateInput = {
    displayID?: SortOrder
  }

  export type QcResultMaxOrderByAggregateInput = {
    id?: SortOrder
    dataRecordID?: SortOrder
    displayID?: SortOrder
    latestBatchID?: SortOrder
    origin?: SortOrder
    severity?: SortOrder
    submissionID?: SortOrder
    submittedID?: SortOrder
    type?: SortOrder
    uploadedDate?: SortOrder
    validatedDate?: SortOrder
    validationType?: SortOrder
  }

  export type QcResultMinOrderByAggregateInput = {
    id?: SortOrder
    dataRecordID?: SortOrder
    displayID?: SortOrder
    latestBatchID?: SortOrder
    origin?: SortOrder
    severity?: SortOrder
    submissionID?: SortOrder
    submittedID?: SortOrder
    type?: SortOrder
    uploadedDate?: SortOrder
    validatedDate?: SortOrder
    validationType?: SortOrder
  }

  export type QcResultSumOrderByAggregateInput = {
    displayID?: SortOrder
  }

  export type ReleaseCountOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    props?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseMaxOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseMinOrderByAggregateInput = {
    id?: SortOrder
    CRDC_ID?: SortOrder
    dataCommons?: SortOrder
    entityType?: SortOrder
    nodeID?: SortOrder
    nodeType?: SortOrder
    status?: SortOrder
    studyID?: SortOrder
    submissionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollaboratorCompositeListFilter = {
    equals?: CollaboratorObjectEqualityInput[]
    every?: CollaboratorWhereInput
    some?: CollaboratorWhereInput
    none?: CollaboratorWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type CollaboratorObjectEqualityInput = {
    Organization?: OrgInfoObjectEqualityInput | null
    collaboratorID: string
    collaboratorName?: string | null
    permission: InputJsonValue
  }

  export type DataFileSizeCompositeFilter = {
    equals?: DataFileSizeObjectEqualityInput
    is?: DataFileSizeWhereInput
    isNot?: DataFileSizeWhereInput
  }

  export type DataFileSizeObjectEqualityInput = {
    formatted: string
    size: number
  }

  export type BatchListRelationFilter = {
    every?: BatchWhereInput
    some?: BatchWhereInput
    none?: BatchWhereInput
  }

  export type DataRecordListRelationFilter = {
    every?: DataRecordWhereInput
    some?: DataRecordWhereInput
    none?: DataRecordWhereInput
  }

  export type QcResultListRelationFilter = {
    every?: QcResultWhereInput
    some?: QcResultWhereInput
    none?: QcResultWhereInput
  }

  export type ValidationListRelationFilter = {
    every?: ValidationWhereInput
    some?: ValidationWhereInput
    none?: ValidationWhereInput
  }

  export type CollaboratorOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type DataFileSizeOrderByInput = {
    formatted?: SortOrder
    size?: SortOrder
  }

  export type BatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QcResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ValidationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    accessedAt?: SortOrder
    archived?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeName?: SortOrder
    controlledAccess?: SortOrder
    crossSubmissionStatus?: SortOrder
    dataCommons?: SortOrder
    dataCommonsDisplayName?: SortOrder
    dataType?: SortOrder
    dbGaPID?: SortOrder
    deletingData?: SortOrder
    fileValidationStatus?: SortOrder
    finalInactiveReminder?: SortOrder
    inactiveReminder?: SortOrder
    inactiveReminder_30?: SortOrder
    inactiveReminder_60?: SortOrder
    inactiveReminder_7?: SortOrder
    intention?: SortOrder
    metadataValidationStatus?: SortOrder
    modelVersion?: SortOrder
    name?: SortOrder
    nodeCount?: SortOrder
    reviewComment?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    validationEnded?: SortOrder
    validationScope?: SortOrder
    validationStarted?: SortOrder
    validationType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubmissionAvgOrderByAggregateInput = {
    nodeCount?: SortOrder
  }

  export type SubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    accessedAt?: SortOrder
    archived?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeName?: SortOrder
    controlledAccess?: SortOrder
    crossSubmissionStatus?: SortOrder
    dataCommons?: SortOrder
    dataCommonsDisplayName?: SortOrder
    dataType?: SortOrder
    dbGaPID?: SortOrder
    deletingData?: SortOrder
    fileValidationStatus?: SortOrder
    finalInactiveReminder?: SortOrder
    inactiveReminder?: SortOrder
    inactiveReminder_30?: SortOrder
    inactiveReminder_60?: SortOrder
    inactiveReminder_7?: SortOrder
    intention?: SortOrder
    metadataValidationStatus?: SortOrder
    modelVersion?: SortOrder
    name?: SortOrder
    nodeCount?: SortOrder
    reviewComment?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    validationEnded?: SortOrder
    validationScope?: SortOrder
    validationStarted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    ORCID?: SortOrder
    accessedAt?: SortOrder
    archived?: SortOrder
    bucketName?: SortOrder
    conciergeEmail?: SortOrder
    conciergeName?: SortOrder
    controlledAccess?: SortOrder
    crossSubmissionStatus?: SortOrder
    dataCommons?: SortOrder
    dataCommonsDisplayName?: SortOrder
    dataType?: SortOrder
    dbGaPID?: SortOrder
    deletingData?: SortOrder
    fileValidationStatus?: SortOrder
    finalInactiveReminder?: SortOrder
    inactiveReminder?: SortOrder
    inactiveReminder_30?: SortOrder
    inactiveReminder_60?: SortOrder
    inactiveReminder_7?: SortOrder
    intention?: SortOrder
    metadataValidationStatus?: SortOrder
    modelVersion?: SortOrder
    name?: SortOrder
    nodeCount?: SortOrder
    reviewComment?: SortOrder
    rootPath?: SortOrder
    status?: SortOrder
    studyAbbreviation?: SortOrder
    studyID?: SortOrder
    submitterID?: SortOrder
    submitterName?: SortOrder
    validationEnded?: SortOrder
    validationScope?: SortOrder
    validationStarted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubmissionSumOrderByAggregateInput = {
    nodeCount?: SortOrder
  }

  export type SynonymCountOrderByAggregateInput = {
    id?: SortOrder
    equivalent_term?: SortOrder
    synonym_term?: SortOrder
  }

  export type SynonymMaxOrderByAggregateInput = {
    id?: SortOrder
    equivalent_term?: SortOrder
    synonym_term?: SortOrder
  }

  export type SynonymMinOrderByAggregateInput = {
    id?: SortOrder
    equivalent_term?: SortOrder
    synonym_term?: SortOrder
  }

  export type InstitutionInfoNullableCompositeFilter = {
    equals?: InstitutionInfoObjectEqualityInput | null
    is?: InstitutionInfoWhereInput | null
    isNot?: InstitutionInfoWhereInput | null
    isSet?: boolean
  }

  export type InstitutionInfoObjectEqualityInput = {
    id: string
    name: string
    status: string
  }

  export type OrgInfoNullableCompositeFilter = {
    equals?: OrgInfoObjectEqualityInput | null
    is?: OrgInfoWhereInput | null
    isNot?: OrgInfoWhereInput | null
    isSet?: boolean
  }

  export type ProgramListRelationFilter = {
    every?: ProgramWhereInput
    some?: ProgramWhereInput
    none?: ProgramWhereInput
  }

  export type ApprovedStudyListRelationFilter = {
    every?: ApprovedStudyWhereInput
    some?: ApprovedStudyWhereInput
    none?: ApprovedStudyWhereInput
  }

  export type InstitutionInfoOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
  }

  export type ProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovedStudyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    IDP?: SortOrder
    dataCommons?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    notifications?: SortOrder
    permissions?: SortOrder
    role?: SortOrder
    status?: SortOrder
    tokens?: SortOrder
    userStatus?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    IDP?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    userStatus?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    IDP?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    userStatus?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ValidationCountOrderByAggregateInput = {
    id?: SortOrder
    ended?: SortOrder
    scope?: SortOrder
    started?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
    type?: SortOrder
  }

  export type ValidationMaxOrderByAggregateInput = {
    id?: SortOrder
    ended?: SortOrder
    scope?: SortOrder
    started?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
  }

  export type ValidationMinOrderByAggregateInput = {
    id?: SortOrder
    ended?: SortOrder
    scope?: SortOrder
    started?: SortOrder
    status?: SortOrder
    submissionID?: SortOrder
  }

  export type CDECreatePermissibleValuesInput = {
    set: string[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type CDEUpdatePermissibleValuesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ApplicantCreateEnvelopeInput = {
    set?: ApplicantCreateInput
  }

  export type ApplicantCreateInput = {
    applicantEmail: string
    applicantID: string
    applicantName: string
  }

  export type HistoryListCreateEnvelopeInput = {
    set?: HistoryCreateInput | HistoryCreateInput[]
  }

  export type HistoryCreateInput = {
    dateTime: Date | string
    reviewComment?: string | null
    status: string
    userID: string
    userName?: string | null
  }

  export type OrgInfoCreateEnvelopeInput = {
    set?: OrgInfoCreateInput
  }

  export type OrgInfoCreateInput = {
    id: string
    name: string
    status?: string | null
    createdAt?: Date | string | null
    updateAt?: Date | string | null
    orgID?: string | null
    orgName?: string | null
  }

  export type ApplicantUpdateEnvelopeInput = {
    set?: ApplicantCreateInput
    update?: ApplicantUpdateInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type HistoryListUpdateEnvelopeInput = {
    set?: HistoryCreateInput | HistoryCreateInput[]
    push?: HistoryCreateInput | HistoryCreateInput[]
    updateMany?: HistoryUpdateManyInput
    deleteMany?: HistoryDeleteManyInput
  }

  export type OrgInfoUpdateEnvelopeInput = {
    set?: OrgInfoCreateInput
    update?: OrgInfoUpdateInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type UserCreateNestedOneWithoutApprovedStudiesInput = {
    create?: XOR<UserCreateWithoutApprovedStudiesInput, UserUncheckedCreateWithoutApprovedStudiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedStudiesInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutApprovedStudiesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedStudiesInput, UserUncheckedCreateWithoutApprovedStudiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedStudiesInput
    upsert?: UserUpsertWithoutApprovedStudiesInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedStudiesInput, UserUpdateWithoutApprovedStudiesInput>, UserUncheckedUpdateWithoutApprovedStudiesInput>
  }

  export type BatchCreateerrorsInput = {
    set: string[]
  }

  export type BatchFilesListCreateEnvelopeInput = {
    set?: BatchFilesCreateInput | BatchFilesCreateInput[]
  }

  export type BatchFilesCreateInput = {
    createdAt: Date | string
    errors?: BatchFilesCreateerrorsInput | string[]
    fileID?: string | null
    fileName: string
    filePrefix: string
    nodeType?: string | null
    signedURL?: string | null
    size?: number | null
    status: string
    updatedAt: Date | string
  }

  export type SubmissionCreateNestedOneWithoutBatchesInput = {
    create?: XOR<SubmissionCreateWithoutBatchesInput, SubmissionUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: SubmissionCreateOrConnectWithoutBatchesInput
    connect?: SubmissionWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BatchUpdateerrorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BatchFilesListUpdateEnvelopeInput = {
    set?: BatchFilesCreateInput | BatchFilesCreateInput[]
    push?: BatchFilesCreateInput | BatchFilesCreateInput[]
    updateMany?: BatchFilesUpdateManyInput
    deleteMany?: BatchFilesDeleteManyInput
  }

  export type SubmissionUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<SubmissionCreateWithoutBatchesInput, SubmissionUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: SubmissionCreateOrConnectWithoutBatchesInput
    upsert?: SubmissionUpsertWithoutBatchesInput
    connect?: SubmissionWhereUniqueInput
    update?: XOR<XOR<SubmissionUpdateToOneWithWhereWithoutBatchesInput, SubmissionUpdateWithoutBatchesInput>, SubmissionUncheckedUpdateWithoutBatchesInput>
  }

  export type PBACDefaultsListCreateEnvelopeInput = {
    set?: PBACDefaultsCreateInput | PBACDefaultsCreateInput[]
  }

  export type PBACDefaultsCreateInput = {
    notifications?: NotificationCreateInput | NotificationCreateInput[]
    permissions?: PermissionCreateInput | PermissionCreateInput[]
    role: string
  }

  export type ConfigurationCreateREVIEW_COMMITTEE_EMAILInput = {
    set: string[]
  }

  export type ConfigurationCreatekeyInput = {
    set: string[]
  }

  export type ConfigurationTagNullableCreateEnvelopeInput = {
    set?: ConfigurationTagCreateInput | null
  }

  export type ConfigurationTagCreateInput = {
    Key: string
    Value: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type PBACDefaultsListUpdateEnvelopeInput = {
    set?: PBACDefaultsCreateInput | PBACDefaultsCreateInput[]
    push?: PBACDefaultsCreateInput | PBACDefaultsCreateInput[]
    updateMany?: PBACDefaultsUpdateManyInput
    deleteMany?: PBACDefaultsDeleteManyInput
  }

  export type ConfigurationUpdateREVIEW_COMMITTEE_EMAILInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ConfigurationUpdatekeyInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ConfigurationTagNullableUpdateEnvelopeInput = {
    set?: ConfigurationTagCreateInput | null
    upsert?: ConfigurationTagUpsertInput
    unset?: boolean
  }

  export type AdditionalErrorListCreateEnvelopeInput = {
    set?: AdditionalErrorCreateInput | AdditionalErrorCreateInput[]
  }

  export type AdditionalErrorCreateInput = {
    conflictingSubmissions?: AdditionalErrorCreateconflictingSubmissionsInput | string[]
    description: string
    title: string
  }

  export type DataRecordCreatebatchIDsInput = {
    set: string[]
  }

  export type ErrorListCreateEnvelopeInput = {
    set?: ErrorCreateInput | ErrorCreateInput[]
  }

  export type ErrorCreateInput = {
    title: string
    description: string
    code?: string | null
    offendingProperty?: string | null
    offendingValue?: string | null
    severity?: string | null
  }

  export type ParentListCreateEnvelopeInput = {
    set?: ParentCreateInput | ParentCreateInput[]
  }

  export type ParentCreateInput = {
    parentIDPropName: string
    parentIDValue: string
    parentType: string
  }

  export type S3FileInfoNullableCreateEnvelopeInput = {
    set?: S3FileInfoCreateInput | null
  }

  export type S3FileInfoCreateInput = {
    createdAt?: Date | string | null
    errors?: ErrorCreateInput | ErrorCreateInput[]
    fileName: string
    md5?: string | null
    size?: string | null
    status: string
    updatedAt?: Date | string | null
    warnings?: ErrorCreateInput | ErrorCreateInput[]
  }

  export type SubmissionCreateNestedOneWithoutDataRecordsInput = {
    create?: XOR<SubmissionCreateWithoutDataRecordsInput, SubmissionUncheckedCreateWithoutDataRecordsInput>
    connectOrCreate?: SubmissionCreateOrConnectWithoutDataRecordsInput
    connect?: SubmissionWhereUniqueInput
  }

  export type AdditionalErrorListUpdateEnvelopeInput = {
    set?: AdditionalErrorCreateInput | AdditionalErrorCreateInput[]
    push?: AdditionalErrorCreateInput | AdditionalErrorCreateInput[]
    updateMany?: AdditionalErrorUpdateManyInput
    deleteMany?: AdditionalErrorDeleteManyInput
  }

  export type DataRecordUpdatebatchIDsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ErrorListUpdateEnvelopeInput = {
    set?: ErrorCreateInput | ErrorCreateInput[]
    push?: ErrorCreateInput | ErrorCreateInput[]
    updateMany?: ErrorUpdateManyInput
    deleteMany?: ErrorDeleteManyInput
  }

  export type ParentListUpdateEnvelopeInput = {
    set?: ParentCreateInput | ParentCreateInput[]
    push?: ParentCreateInput | ParentCreateInput[]
    updateMany?: ParentUpdateManyInput
    deleteMany?: ParentDeleteManyInput
  }

  export type S3FileInfoNullableUpdateEnvelopeInput = {
    set?: S3FileInfoCreateInput | null
    upsert?: S3FileInfoUpsertInput
    unset?: boolean
  }

  export type SubmissionUpdateOneRequiredWithoutDataRecordsNestedInput = {
    create?: XOR<SubmissionCreateWithoutDataRecordsInput, SubmissionUncheckedCreateWithoutDataRecordsInput>
    connectOrCreate?: SubmissionCreateOrConnectWithoutDataRecordsInput
    upsert?: SubmissionUpsertWithoutDataRecordsInput
    connect?: SubmissionWhereUniqueInput
    update?: XOR<XOR<SubmissionUpdateToOneWithWhereWithoutDataRecordsInput, SubmissionUpdateWithoutDataRecordsInput>, SubmissionUncheckedUpdateWithoutDataRecordsInput>
  }

  export type DataRecordsArchivedCreatebatchIDsInput = {
    set: string[]
  }

  export type DataRecordsArchivedUpdatebatchIDsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LogsEventDetailNullableCreateEnvelopeInput = {
    set?: LogsEventDetailCreateInput | null
  }

  export type LogsEventDetailCreateInput = {
    nodeIDs?: LogsEventDetailCreatenodeIDsInput | string[]
    nodeType: string
    submissionID: string
  }

  export type LogsEventDetailNullableUpdateEnvelopeInput = {
    set?: LogsEventDetailCreateInput | null
    upsert?: LogsEventDetailUpsertInput
    unset?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudyByIDListCreateEnvelopeInput = {
    set?: StudyByIDCreateInput | StudyByIDCreateInput[]
  }

  export type StudyByIDCreateInput = {
    id: string
  }

  export type UserCreateNestedOneWithoutProgramsInput = {
    create?: XOR<UserCreateWithoutProgramsInput, UserUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgramsInput
    connect?: UserWhereUniqueInput
  }

  export type StudyByIDListUpdateEnvelopeInput = {
    set?: StudyByIDCreateInput | StudyByIDCreateInput[]
    push?: StudyByIDCreateInput | StudyByIDCreateInput[]
    updateMany?: StudyByIDUpdateManyInput
    deleteMany?: StudyByIDDeleteManyInput
  }

  export type UserUpdateOneWithoutProgramsNestedInput = {
    create?: XOR<UserCreateWithoutProgramsInput, UserUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgramsInput
    upsert?: UserUpsertWithoutProgramsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProgramsInput, UserUpdateWithoutProgramsInput>, UserUncheckedUpdateWithoutProgramsInput>
  }

  export type QcResultCreatebatchIDsInput = {
    set: string[]
  }

  export type SubmissionCreateNestedOneWithoutQcResultsInput = {
    create?: XOR<SubmissionCreateWithoutQcResultsInput, SubmissionUncheckedCreateWithoutQcResultsInput>
    connectOrCreate?: SubmissionCreateOrConnectWithoutQcResultsInput
    connect?: SubmissionWhereUniqueInput
  }

  export type QcResultUpdatebatchIDsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SubmissionUpdateOneRequiredWithoutQcResultsNestedInput = {
    create?: XOR<SubmissionCreateWithoutQcResultsInput, SubmissionUncheckedCreateWithoutQcResultsInput>
    connectOrCreate?: SubmissionCreateOrConnectWithoutQcResultsInput
    upsert?: SubmissionUpsertWithoutQcResultsInput
    connect?: SubmissionWhereUniqueInput
    update?: XOR<XOR<SubmissionUpdateToOneWithWhereWithoutQcResultsInput, SubmissionUpdateWithoutQcResultsInput>, SubmissionUncheckedUpdateWithoutQcResultsInput>
  }

  export type CollaboratorListCreateEnvelopeInput = {
    set?: CollaboratorCreateInput | CollaboratorCreateInput[]
  }

  export type CollaboratorCreateInput = {
    Organization?: OrgInfoCreateInput | null
    collaboratorID: string
    collaboratorName?: string | null
    permission: InputJsonValue
  }

  export type DataFileSizeCreateEnvelopeInput = {
    set?: DataFileSizeCreateInput
  }

  export type DataFileSizeCreateInput = {
    formatted: string
    size: number
  }

  export type SubmissionCreatevalidationTypeInput = {
    set: string[]
  }

  export type BatchCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<BatchCreateWithoutSubmissionInput, BatchUncheckedCreateWithoutSubmissionInput> | BatchCreateWithoutSubmissionInput[] | BatchUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutSubmissionInput | BatchCreateOrConnectWithoutSubmissionInput[]
    createMany?: BatchCreateManySubmissionInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type DataRecordCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<DataRecordCreateWithoutSubmissionInput, DataRecordUncheckedCreateWithoutSubmissionInput> | DataRecordCreateWithoutSubmissionInput[] | DataRecordUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: DataRecordCreateOrConnectWithoutSubmissionInput | DataRecordCreateOrConnectWithoutSubmissionInput[]
    createMany?: DataRecordCreateManySubmissionInputEnvelope
    connect?: DataRecordWhereUniqueInput | DataRecordWhereUniqueInput[]
  }

  export type QcResultCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<QcResultCreateWithoutSubmissionInput, QcResultUncheckedCreateWithoutSubmissionInput> | QcResultCreateWithoutSubmissionInput[] | QcResultUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: QcResultCreateOrConnectWithoutSubmissionInput | QcResultCreateOrConnectWithoutSubmissionInput[]
    createMany?: QcResultCreateManySubmissionInputEnvelope
    connect?: QcResultWhereUniqueInput | QcResultWhereUniqueInput[]
  }

  export type ValidationCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<ValidationCreateWithoutSubmissionInput, ValidationUncheckedCreateWithoutSubmissionInput> | ValidationCreateWithoutSubmissionInput[] | ValidationUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutSubmissionInput | ValidationCreateOrConnectWithoutSubmissionInput[]
    createMany?: ValidationCreateManySubmissionInputEnvelope
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<BatchCreateWithoutSubmissionInput, BatchUncheckedCreateWithoutSubmissionInput> | BatchCreateWithoutSubmissionInput[] | BatchUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutSubmissionInput | BatchCreateOrConnectWithoutSubmissionInput[]
    createMany?: BatchCreateManySubmissionInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type DataRecordUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<DataRecordCreateWithoutSubmissionInput, DataRecordUncheckedCreateWithoutSubmissionInput> | DataRecordCreateWithoutSubmissionInput[] | DataRecordUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: DataRecordCreateOrConnectWithoutSubmissionInput | DataRecordCreateOrConnectWithoutSubmissionInput[]
    createMany?: DataRecordCreateManySubmissionInputEnvelope
    connect?: DataRecordWhereUniqueInput | DataRecordWhereUniqueInput[]
  }

  export type QcResultUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<QcResultCreateWithoutSubmissionInput, QcResultUncheckedCreateWithoutSubmissionInput> | QcResultCreateWithoutSubmissionInput[] | QcResultUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: QcResultCreateOrConnectWithoutSubmissionInput | QcResultCreateOrConnectWithoutSubmissionInput[]
    createMany?: QcResultCreateManySubmissionInputEnvelope
    connect?: QcResultWhereUniqueInput | QcResultWhereUniqueInput[]
  }

  export type ValidationUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<ValidationCreateWithoutSubmissionInput, ValidationUncheckedCreateWithoutSubmissionInput> | ValidationCreateWithoutSubmissionInput[] | ValidationUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutSubmissionInput | ValidationCreateOrConnectWithoutSubmissionInput[]
    createMany?: ValidationCreateManySubmissionInputEnvelope
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
  }

  export type CollaboratorListUpdateEnvelopeInput = {
    set?: CollaboratorCreateInput | CollaboratorCreateInput[]
    push?: CollaboratorCreateInput | CollaboratorCreateInput[]
    updateMany?: CollaboratorUpdateManyInput
    deleteMany?: CollaboratorDeleteManyInput
  }

  export type DataFileSizeUpdateEnvelopeInput = {
    set?: DataFileSizeCreateInput
    update?: DataFileSizeUpdateInput
  }

  export type SubmissionUpdatevalidationTypeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BatchUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<BatchCreateWithoutSubmissionInput, BatchUncheckedCreateWithoutSubmissionInput> | BatchCreateWithoutSubmissionInput[] | BatchUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutSubmissionInput | BatchCreateOrConnectWithoutSubmissionInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutSubmissionInput | BatchUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: BatchCreateManySubmissionInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutSubmissionInput | BatchUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutSubmissionInput | BatchUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type DataRecordUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<DataRecordCreateWithoutSubmissionInput, DataRecordUncheckedCreateWithoutSubmissionInput> | DataRecordCreateWithoutSubmissionInput[] | DataRecordUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: DataRecordCreateOrConnectWithoutSubmissionInput | DataRecordCreateOrConnectWithoutSubmissionInput[]
    upsert?: DataRecordUpsertWithWhereUniqueWithoutSubmissionInput | DataRecordUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: DataRecordCreateManySubmissionInputEnvelope
    set?: DataRecordWhereUniqueInput | DataRecordWhereUniqueInput[]
    disconnect?: DataRecordWhereUniqueInput | DataRecordWhereUniqueInput[]
    delete?: DataRecordWhereUniqueInput | DataRecordWhereUniqueInput[]
    connect?: DataRecordWhereUniqueInput | DataRecordWhereUniqueInput[]
    update?: DataRecordUpdateWithWhereUniqueWithoutSubmissionInput | DataRecordUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: DataRecordUpdateManyWithWhereWithoutSubmissionInput | DataRecordUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: DataRecordScalarWhereInput | DataRecordScalarWhereInput[]
  }

  export type QcResultUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<QcResultCreateWithoutSubmissionInput, QcResultUncheckedCreateWithoutSubmissionInput> | QcResultCreateWithoutSubmissionInput[] | QcResultUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: QcResultCreateOrConnectWithoutSubmissionInput | QcResultCreateOrConnectWithoutSubmissionInput[]
    upsert?: QcResultUpsertWithWhereUniqueWithoutSubmissionInput | QcResultUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: QcResultCreateManySubmissionInputEnvelope
    set?: QcResultWhereUniqueInput | QcResultWhereUniqueInput[]
    disconnect?: QcResultWhereUniqueInput | QcResultWhereUniqueInput[]
    delete?: QcResultWhereUniqueInput | QcResultWhereUniqueInput[]
    connect?: QcResultWhereUniqueInput | QcResultWhereUniqueInput[]
    update?: QcResultUpdateWithWhereUniqueWithoutSubmissionInput | QcResultUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: QcResultUpdateManyWithWhereWithoutSubmissionInput | QcResultUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: QcResultScalarWhereInput | QcResultScalarWhereInput[]
  }

  export type ValidationUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<ValidationCreateWithoutSubmissionInput, ValidationUncheckedCreateWithoutSubmissionInput> | ValidationCreateWithoutSubmissionInput[] | ValidationUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutSubmissionInput | ValidationCreateOrConnectWithoutSubmissionInput[]
    upsert?: ValidationUpsertWithWhereUniqueWithoutSubmissionInput | ValidationUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: ValidationCreateManySubmissionInputEnvelope
    set?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    disconnect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    delete?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    update?: ValidationUpdateWithWhereUniqueWithoutSubmissionInput | ValidationUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: ValidationUpdateManyWithWhereWithoutSubmissionInput | ValidationUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: ValidationScalarWhereInput | ValidationScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<BatchCreateWithoutSubmissionInput, BatchUncheckedCreateWithoutSubmissionInput> | BatchCreateWithoutSubmissionInput[] | BatchUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutSubmissionInput | BatchCreateOrConnectWithoutSubmissionInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutSubmissionInput | BatchUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: BatchCreateManySubmissionInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutSubmissionInput | BatchUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutSubmissionInput | BatchUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type DataRecordUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<DataRecordCreateWithoutSubmissionInput, DataRecordUncheckedCreateWithoutSubmissionInput> | DataRecordCreateWithoutSubmissionInput[] | DataRecordUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: DataRecordCreateOrConnectWithoutSubmissionInput | DataRecordCreateOrConnectWithoutSubmissionInput[]
    upsert?: DataRecordUpsertWithWhereUniqueWithoutSubmissionInput | DataRecordUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: DataRecordCreateManySubmissionInputEnvelope
    set?: DataRecordWhereUniqueInput | DataRecordWhereUniqueInput[]
    disconnect?: DataRecordWhereUniqueInput | DataRecordWhereUniqueInput[]
    delete?: DataRecordWhereUniqueInput | DataRecordWhereUniqueInput[]
    connect?: DataRecordWhereUniqueInput | DataRecordWhereUniqueInput[]
    update?: DataRecordUpdateWithWhereUniqueWithoutSubmissionInput | DataRecordUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: DataRecordUpdateManyWithWhereWithoutSubmissionInput | DataRecordUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: DataRecordScalarWhereInput | DataRecordScalarWhereInput[]
  }

  export type QcResultUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<QcResultCreateWithoutSubmissionInput, QcResultUncheckedCreateWithoutSubmissionInput> | QcResultCreateWithoutSubmissionInput[] | QcResultUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: QcResultCreateOrConnectWithoutSubmissionInput | QcResultCreateOrConnectWithoutSubmissionInput[]
    upsert?: QcResultUpsertWithWhereUniqueWithoutSubmissionInput | QcResultUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: QcResultCreateManySubmissionInputEnvelope
    set?: QcResultWhereUniqueInput | QcResultWhereUniqueInput[]
    disconnect?: QcResultWhereUniqueInput | QcResultWhereUniqueInput[]
    delete?: QcResultWhereUniqueInput | QcResultWhereUniqueInput[]
    connect?: QcResultWhereUniqueInput | QcResultWhereUniqueInput[]
    update?: QcResultUpdateWithWhereUniqueWithoutSubmissionInput | QcResultUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: QcResultUpdateManyWithWhereWithoutSubmissionInput | QcResultUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: QcResultScalarWhereInput | QcResultScalarWhereInput[]
  }

  export type ValidationUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<ValidationCreateWithoutSubmissionInput, ValidationUncheckedCreateWithoutSubmissionInput> | ValidationCreateWithoutSubmissionInput[] | ValidationUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: ValidationCreateOrConnectWithoutSubmissionInput | ValidationCreateOrConnectWithoutSubmissionInput[]
    upsert?: ValidationUpsertWithWhereUniqueWithoutSubmissionInput | ValidationUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: ValidationCreateManySubmissionInputEnvelope
    set?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    disconnect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    delete?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    connect?: ValidationWhereUniqueInput | ValidationWhereUniqueInput[]
    update?: ValidationUpdateWithWhereUniqueWithoutSubmissionInput | ValidationUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: ValidationUpdateManyWithWhereWithoutSubmissionInput | ValidationUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: ValidationScalarWhereInput | ValidationScalarWhereInput[]
  }

  export type UserCreatedataCommonsInput = {
    set: string[]
  }

  export type InstitutionInfoNullableCreateEnvelopeInput = {
    set?: InstitutionInfoCreateInput | null
  }

  export type InstitutionInfoCreateInput = {
    id: string
    name: string
    status: string
  }

  export type UserCreatenotificationsInput = {
    set: string[]
  }

  export type OrgInfoNullableCreateEnvelopeInput = {
    set?: OrgInfoCreateInput | null
  }

  export type UserCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreatetokensInput = {
    set: string[]
  }

  export type ProgramCreateNestedManyWithoutConciergeInput = {
    create?: XOR<ProgramCreateWithoutConciergeInput, ProgramUncheckedCreateWithoutConciergeInput> | ProgramCreateWithoutConciergeInput[] | ProgramUncheckedCreateWithoutConciergeInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutConciergeInput | ProgramCreateOrConnectWithoutConciergeInput[]
    createMany?: ProgramCreateManyConciergeInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type ApprovedStudyCreateNestedManyWithoutConciergeInput = {
    create?: XOR<ApprovedStudyCreateWithoutConciergeInput, ApprovedStudyUncheckedCreateWithoutConciergeInput> | ApprovedStudyCreateWithoutConciergeInput[] | ApprovedStudyUncheckedCreateWithoutConciergeInput[]
    connectOrCreate?: ApprovedStudyCreateOrConnectWithoutConciergeInput | ApprovedStudyCreateOrConnectWithoutConciergeInput[]
    createMany?: ApprovedStudyCreateManyConciergeInputEnvelope
    connect?: ApprovedStudyWhereUniqueInput | ApprovedStudyWhereUniqueInput[]
  }

  export type ProgramUncheckedCreateNestedManyWithoutConciergeInput = {
    create?: XOR<ProgramCreateWithoutConciergeInput, ProgramUncheckedCreateWithoutConciergeInput> | ProgramCreateWithoutConciergeInput[] | ProgramUncheckedCreateWithoutConciergeInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutConciergeInput | ProgramCreateOrConnectWithoutConciergeInput[]
    createMany?: ProgramCreateManyConciergeInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type ApprovedStudyUncheckedCreateNestedManyWithoutConciergeInput = {
    create?: XOR<ApprovedStudyCreateWithoutConciergeInput, ApprovedStudyUncheckedCreateWithoutConciergeInput> | ApprovedStudyCreateWithoutConciergeInput[] | ApprovedStudyUncheckedCreateWithoutConciergeInput[]
    connectOrCreate?: ApprovedStudyCreateOrConnectWithoutConciergeInput | ApprovedStudyCreateOrConnectWithoutConciergeInput[]
    createMany?: ApprovedStudyCreateManyConciergeInputEnvelope
    connect?: ApprovedStudyWhereUniqueInput | ApprovedStudyWhereUniqueInput[]
  }

  export type UserUpdatedataCommonsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstitutionInfoNullableUpdateEnvelopeInput = {
    set?: InstitutionInfoCreateInput | null
    upsert?: InstitutionInfoUpsertInput
    unset?: boolean
  }

  export type UserUpdatenotificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrgInfoNullableUpdateEnvelopeInput = {
    set?: OrgInfoCreateInput | null
    upsert?: OrgInfoUpsertInput
    unset?: boolean
  }

  export type UserUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdatetokensInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProgramUpdateManyWithoutConciergeNestedInput = {
    create?: XOR<ProgramCreateWithoutConciergeInput, ProgramUncheckedCreateWithoutConciergeInput> | ProgramCreateWithoutConciergeInput[] | ProgramUncheckedCreateWithoutConciergeInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutConciergeInput | ProgramCreateOrConnectWithoutConciergeInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutConciergeInput | ProgramUpsertWithWhereUniqueWithoutConciergeInput[]
    createMany?: ProgramCreateManyConciergeInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutConciergeInput | ProgramUpdateWithWhereUniqueWithoutConciergeInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutConciergeInput | ProgramUpdateManyWithWhereWithoutConciergeInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type ApprovedStudyUpdateManyWithoutConciergeNestedInput = {
    create?: XOR<ApprovedStudyCreateWithoutConciergeInput, ApprovedStudyUncheckedCreateWithoutConciergeInput> | ApprovedStudyCreateWithoutConciergeInput[] | ApprovedStudyUncheckedCreateWithoutConciergeInput[]
    connectOrCreate?: ApprovedStudyCreateOrConnectWithoutConciergeInput | ApprovedStudyCreateOrConnectWithoutConciergeInput[]
    upsert?: ApprovedStudyUpsertWithWhereUniqueWithoutConciergeInput | ApprovedStudyUpsertWithWhereUniqueWithoutConciergeInput[]
    createMany?: ApprovedStudyCreateManyConciergeInputEnvelope
    set?: ApprovedStudyWhereUniqueInput | ApprovedStudyWhereUniqueInput[]
    disconnect?: ApprovedStudyWhereUniqueInput | ApprovedStudyWhereUniqueInput[]
    delete?: ApprovedStudyWhereUniqueInput | ApprovedStudyWhereUniqueInput[]
    connect?: ApprovedStudyWhereUniqueInput | ApprovedStudyWhereUniqueInput[]
    update?: ApprovedStudyUpdateWithWhereUniqueWithoutConciergeInput | ApprovedStudyUpdateWithWhereUniqueWithoutConciergeInput[]
    updateMany?: ApprovedStudyUpdateManyWithWhereWithoutConciergeInput | ApprovedStudyUpdateManyWithWhereWithoutConciergeInput[]
    deleteMany?: ApprovedStudyScalarWhereInput | ApprovedStudyScalarWhereInput[]
  }

  export type ProgramUncheckedUpdateManyWithoutConciergeNestedInput = {
    create?: XOR<ProgramCreateWithoutConciergeInput, ProgramUncheckedCreateWithoutConciergeInput> | ProgramCreateWithoutConciergeInput[] | ProgramUncheckedCreateWithoutConciergeInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutConciergeInput | ProgramCreateOrConnectWithoutConciergeInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutConciergeInput | ProgramUpsertWithWhereUniqueWithoutConciergeInput[]
    createMany?: ProgramCreateManyConciergeInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutConciergeInput | ProgramUpdateWithWhereUniqueWithoutConciergeInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutConciergeInput | ProgramUpdateManyWithWhereWithoutConciergeInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type ApprovedStudyUncheckedUpdateManyWithoutConciergeNestedInput = {
    create?: XOR<ApprovedStudyCreateWithoutConciergeInput, ApprovedStudyUncheckedCreateWithoutConciergeInput> | ApprovedStudyCreateWithoutConciergeInput[] | ApprovedStudyUncheckedCreateWithoutConciergeInput[]
    connectOrCreate?: ApprovedStudyCreateOrConnectWithoutConciergeInput | ApprovedStudyCreateOrConnectWithoutConciergeInput[]
    upsert?: ApprovedStudyUpsertWithWhereUniqueWithoutConciergeInput | ApprovedStudyUpsertWithWhereUniqueWithoutConciergeInput[]
    createMany?: ApprovedStudyCreateManyConciergeInputEnvelope
    set?: ApprovedStudyWhereUniqueInput | ApprovedStudyWhereUniqueInput[]
    disconnect?: ApprovedStudyWhereUniqueInput | ApprovedStudyWhereUniqueInput[]
    delete?: ApprovedStudyWhereUniqueInput | ApprovedStudyWhereUniqueInput[]
    connect?: ApprovedStudyWhereUniqueInput | ApprovedStudyWhereUniqueInput[]
    update?: ApprovedStudyUpdateWithWhereUniqueWithoutConciergeInput | ApprovedStudyUpdateWithWhereUniqueWithoutConciergeInput[]
    updateMany?: ApprovedStudyUpdateManyWithWhereWithoutConciergeInput | ApprovedStudyUpdateManyWithWhereWithoutConciergeInput[]
    deleteMany?: ApprovedStudyScalarWhereInput | ApprovedStudyScalarWhereInput[]
  }

  export type ValidationCreatetypeInput = {
    set: string[]
  }

  export type SubmissionCreateNestedOneWithoutValidationsInput = {
    create?: XOR<SubmissionCreateWithoutValidationsInput, SubmissionUncheckedCreateWithoutValidationsInput>
    connectOrCreate?: SubmissionCreateOrConnectWithoutValidationsInput
    connect?: SubmissionWhereUniqueInput
  }

  export type ValidationUpdatetypeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SubmissionUpdateOneRequiredWithoutValidationsNestedInput = {
    create?: XOR<SubmissionCreateWithoutValidationsInput, SubmissionUncheckedCreateWithoutValidationsInput>
    connectOrCreate?: SubmissionCreateOrConnectWithoutValidationsInput
    upsert?: SubmissionUpsertWithoutValidationsInput
    connect?: SubmissionWhereUniqueInput
    update?: XOR<XOR<SubmissionUpdateToOneWithWhereWithoutValidationsInput, SubmissionUpdateWithoutValidationsInput>, SubmissionUncheckedUpdateWithoutValidationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ApplicantWhereInput = {
    AND?: ApplicantWhereInput | ApplicantWhereInput[]
    OR?: ApplicantWhereInput[]
    NOT?: ApplicantWhereInput | ApplicantWhereInput[]
    applicantEmail?: StringFilter<"Applicant"> | string
    applicantID?: StringFilter<"Applicant"> | string
    applicantName?: StringFilter<"Applicant"> | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type HistoryWhereInput = {
    AND?: HistoryWhereInput | HistoryWhereInput[]
    OR?: HistoryWhereInput[]
    NOT?: HistoryWhereInput | HistoryWhereInput[]
    dateTime?: DateTimeFilter<"History"> | Date | string
    reviewComment?: StringNullableFilter<"History"> | string | null
    status?: StringFilter<"History"> | string
    userID?: StringFilter<"History"> | string
    userName?: StringNullableFilter<"History"> | string | null
  }

  export type OrgInfoWhereInput = {
    AND?: OrgInfoWhereInput | OrgInfoWhereInput[]
    OR?: OrgInfoWhereInput[]
    NOT?: OrgInfoWhereInput | OrgInfoWhereInput[]
    id?: StringFilter<"OrgInfo"> | string
    name?: StringFilter<"OrgInfo"> | string
    status?: StringNullableFilter<"OrgInfo"> | string | null
    createdAt?: DateTimeNullableFilter<"OrgInfo"> | Date | string | null
    updateAt?: DateTimeNullableFilter<"OrgInfo"> | Date | string | null
    orgID?: StringNullableFilter<"OrgInfo"> | string | null
    orgName?: StringNullableFilter<"OrgInfo"> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BatchFilesWhereInput = {
    AND?: BatchFilesWhereInput | BatchFilesWhereInput[]
    OR?: BatchFilesWhereInput[]
    NOT?: BatchFilesWhereInput | BatchFilesWhereInput[]
    createdAt?: DateTimeFilter<"BatchFiles"> | Date | string
    errors?: StringNullableListFilter<"BatchFiles">
    fileID?: StringNullableFilter<"BatchFiles"> | string | null
    fileName?: StringFilter<"BatchFiles"> | string
    filePrefix?: StringFilter<"BatchFiles"> | string
    nodeType?: StringNullableFilter<"BatchFiles"> | string | null
    signedURL?: StringNullableFilter<"BatchFiles"> | string | null
    size?: IntNullableFilter<"BatchFiles"> | number | null
    status?: StringFilter<"BatchFiles"> | string
    updatedAt?: DateTimeFilter<"BatchFiles"> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PBACDefaultsWhereInput = {
    AND?: PBACDefaultsWhereInput | PBACDefaultsWhereInput[]
    OR?: PBACDefaultsWhereInput[]
    NOT?: PBACDefaultsWhereInput | PBACDefaultsWhereInput[]
    notifications?: NotificationCompositeListFilter | NotificationObjectEqualityInput[]
    permissions?: PermissionCompositeListFilter | PermissionObjectEqualityInput[]
    role?: StringFilter<"PBACDefaults"> | string
  }

  export type NotificationObjectEqualityInput = {
    id: string
    checked: boolean
    disabled: boolean
    group: string
    name: string
    order: number
  }

  export type PermissionObjectEqualityInput = {
    id: string
    checked: boolean
    disabled: boolean
    group: string
    inherited?: string[]
    name: string
    order: number
  }

  export type ConfigurationTagWhereInput = {
    AND?: ConfigurationTagWhereInput | ConfigurationTagWhereInput[]
    OR?: ConfigurationTagWhereInput[]
    NOT?: ConfigurationTagWhereInput | ConfigurationTagWhereInput[]
    Key?: StringFilter<"ConfigurationTag"> | string
    Value?: StringFilter<"ConfigurationTag"> | string
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type AdditionalErrorWhereInput = {
    AND?: AdditionalErrorWhereInput | AdditionalErrorWhereInput[]
    OR?: AdditionalErrorWhereInput[]
    NOT?: AdditionalErrorWhereInput | AdditionalErrorWhereInput[]
    conflictingSubmissions?: StringNullableListFilter<"AdditionalError">
    description?: StringFilter<"AdditionalError"> | string
    title?: StringFilter<"AdditionalError"> | string
  }

  export type ErrorWhereInput = {
    AND?: ErrorWhereInput | ErrorWhereInput[]
    OR?: ErrorWhereInput[]
    NOT?: ErrorWhereInput | ErrorWhereInput[]
    title?: StringFilter<"Error"> | string
    description?: StringFilter<"Error"> | string
    code?: StringNullableFilter<"Error"> | string | null
    offendingProperty?: StringNullableFilter<"Error"> | string | null
    offendingValue?: StringNullableFilter<"Error"> | string | null
    severity?: StringNullableFilter<"Error"> | string | null
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    parentIDPropName?: StringFilter<"Parent"> | string
    parentIDValue?: StringFilter<"Parent"> | string
    parentType?: StringFilter<"Parent"> | string
  }

  export type S3FileInfoWhereInput = {
    AND?: S3FileInfoWhereInput | S3FileInfoWhereInput[]
    OR?: S3FileInfoWhereInput[]
    NOT?: S3FileInfoWhereInput | S3FileInfoWhereInput[]
    createdAt?: DateTimeNullableFilter<"S3FileInfo"> | Date | string | null
    errors?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
    fileName?: StringFilter<"S3FileInfo"> | string
    md5?: StringNullableFilter<"S3FileInfo"> | string | null
    size?: StringNullableFilter<"S3FileInfo"> | string | null
    status?: StringFilter<"S3FileInfo"> | string
    updatedAt?: DateTimeNullableFilter<"S3FileInfo"> | Date | string | null
    warnings?: ErrorCompositeListFilter | ErrorObjectEqualityInput[]
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type LogsEventDetailWhereInput = {
    AND?: LogsEventDetailWhereInput | LogsEventDetailWhereInput[]
    OR?: LogsEventDetailWhereInput[]
    NOT?: LogsEventDetailWhereInput | LogsEventDetailWhereInput[]
    nodeIDs?: StringNullableListFilter<"LogsEventDetail">
    nodeType?: StringFilter<"LogsEventDetail"> | string
    submissionID?: StringFilter<"LogsEventDetail"> | string
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StudyByIDWhereInput = {
    AND?: StudyByIDWhereInput | StudyByIDWhereInput[]
    OR?: StudyByIDWhereInput[]
    NOT?: StudyByIDWhereInput | StudyByIDWhereInput[]
    id?: StringFilter<"StudyByID"> | string
  }

  export type CollaboratorWhereInput = {
    AND?: CollaboratorWhereInput | CollaboratorWhereInput[]
    OR?: CollaboratorWhereInput[]
    NOT?: CollaboratorWhereInput | CollaboratorWhereInput[]
    Organization?: XOR<OrgInfoNullableCompositeFilter, OrgInfoObjectEqualityInput> | null
    collaboratorID?: StringFilter<"Collaborator"> | string
    collaboratorName?: StringNullableFilter<"Collaborator"> | string | null
    permission?: JsonFilter<"Collaborator">
  }

  export type DataFileSizeWhereInput = {
    AND?: DataFileSizeWhereInput | DataFileSizeWhereInput[]
    OR?: DataFileSizeWhereInput[]
    NOT?: DataFileSizeWhereInput | DataFileSizeWhereInput[]
    formatted?: StringFilter<"DataFileSize"> | string
    size?: IntFilter<"DataFileSize"> | number
  }

  export type InstitutionInfoWhereInput = {
    AND?: InstitutionInfoWhereInput | InstitutionInfoWhereInput[]
    OR?: InstitutionInfoWhereInput[]
    NOT?: InstitutionInfoWhereInput | InstitutionInfoWhereInput[]
    id?: StringFilter<"InstitutionInfo"> | string
    name?: StringFilter<"InstitutionInfo"> | string
    status?: StringFilter<"InstitutionInfo"> | string
  }

  export type ApplicantUpdateInput = {
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantID?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
  }

  export type HistoryUpdateManyInput = {
    where: HistoryWhereInput
    data: HistoryUpdateInput
  }

  export type HistoryDeleteManyInput = {
    where: HistoryWhereInput
  }

  export type OrgInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orgID?: NullableStringFieldUpdateOperationsInput | string | null
    orgName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutApprovedStudiesInput = {
    id?: string
    IDP: string
    dataCommons?: UserCreatedataCommonsInput | string[]
    email: string
    firstName: string
    institution?: XOR<InstitutionInfoNullableCreateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName: string
    notifications?: UserCreatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableCreateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserCreatepermissionsInput | string[]
    role: string
    status?: string | null
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserCreatetokensInput | string[]
    userStatus: string
    createdAt?: Date | string
    updateAt?: Date | string
    programs?: ProgramCreateNestedManyWithoutConciergeInput
  }

  export type UserUncheckedCreateWithoutApprovedStudiesInput = {
    id?: string
    IDP: string
    dataCommons?: UserCreatedataCommonsInput | string[]
    email: string
    firstName: string
    institution?: XOR<InstitutionInfoNullableCreateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName: string
    notifications?: UserCreatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableCreateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserCreatepermissionsInput | string[]
    role: string
    status?: string | null
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserCreatetokensInput | string[]
    userStatus: string
    createdAt?: Date | string
    updateAt?: Date | string
    programs?: ProgramUncheckedCreateNestedManyWithoutConciergeInput
  }

  export type UserCreateOrConnectWithoutApprovedStudiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedStudiesInput, UserUncheckedCreateWithoutApprovedStudiesInput>
  }

  export type UserUpsertWithoutApprovedStudiesInput = {
    update: XOR<UserUpdateWithoutApprovedStudiesInput, UserUncheckedUpdateWithoutApprovedStudiesInput>
    create: XOR<UserCreateWithoutApprovedStudiesInput, UserUncheckedCreateWithoutApprovedStudiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedStudiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedStudiesInput, UserUncheckedUpdateWithoutApprovedStudiesInput>
  }

  export type UserUpdateWithoutApprovedStudiesInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    dataCommons?: UserUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionInfoNullableUpdateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: UserUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserUpdatetokensInput | string[]
    userStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUpdateManyWithoutConciergeNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedStudiesInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    dataCommons?: UserUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionInfoNullableUpdateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: UserUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserUpdatetokensInput | string[]
    userStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUncheckedUpdateManyWithoutConciergeNestedInput
  }

  export type BatchFilesCreateerrorsInput = {
    set: string[]
  }

  export type SubmissionCreateWithoutBatchesInput = {
    id?: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: SubmissionCreatevalidationTypeInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    dataRecords?: DataRecordCreateNestedManyWithoutSubmissionInput
    qcResults?: QcResultCreateNestedManyWithoutSubmissionInput
    validations?: ValidationCreateNestedManyWithoutSubmissionInput
  }

  export type SubmissionUncheckedCreateWithoutBatchesInput = {
    id?: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: SubmissionCreatevalidationTypeInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    dataRecords?: DataRecordUncheckedCreateNestedManyWithoutSubmissionInput
    qcResults?: QcResultUncheckedCreateNestedManyWithoutSubmissionInput
    validations?: ValidationUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type SubmissionCreateOrConnectWithoutBatchesInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutBatchesInput, SubmissionUncheckedCreateWithoutBatchesInput>
  }

  export type BatchFilesUpdateManyInput = {
    where: BatchFilesWhereInput
    data: BatchFilesUpdateInput
  }

  export type BatchFilesDeleteManyInput = {
    where: BatchFilesWhereInput
  }

  export type SubmissionUpsertWithoutBatchesInput = {
    update: XOR<SubmissionUpdateWithoutBatchesInput, SubmissionUncheckedUpdateWithoutBatchesInput>
    create: XOR<SubmissionCreateWithoutBatchesInput, SubmissionUncheckedCreateWithoutBatchesInput>
    where?: SubmissionWhereInput
  }

  export type SubmissionUpdateToOneWithWhereWithoutBatchesInput = {
    where?: SubmissionWhereInput
    data: XOR<SubmissionUpdateWithoutBatchesInput, SubmissionUncheckedUpdateWithoutBatchesInput>
  }

  export type SubmissionUpdateWithoutBatchesInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataRecords?: DataRecordUpdateManyWithoutSubmissionNestedInput
    qcResults?: QcResultUpdateManyWithoutSubmissionNestedInput
    validations?: ValidationUpdateManyWithoutSubmissionNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutBatchesInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataRecords?: DataRecordUncheckedUpdateManyWithoutSubmissionNestedInput
    qcResults?: QcResultUncheckedUpdateManyWithoutSubmissionNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type NotificationCreateInput = {
    id: string
    checked: boolean
    disabled: boolean
    group: string
    name: string
    order: number
  }

  export type PermissionCreateInput = {
    id: string
    checked: boolean
    disabled: boolean
    group: string
    inherited?: PermissionCreateinheritedInput | string[]
    name: string
    order: number
  }

  export type PBACDefaultsUpdateManyInput = {
    where: PBACDefaultsWhereInput
    data: PBACDefaultsUpdateInput
  }

  export type PBACDefaultsDeleteManyInput = {
    where: PBACDefaultsWhereInput
  }

  export type ConfigurationTagUpsertInput = {
    set: ConfigurationTagCreateInput | null
    update: ConfigurationTagUpdateInput
  }

  export type AdditionalErrorCreateconflictingSubmissionsInput = {
    set: string[]
  }

  export type SubmissionCreateWithoutDataRecordsInput = {
    id?: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: SubmissionCreatevalidationTypeInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchCreateNestedManyWithoutSubmissionInput
    qcResults?: QcResultCreateNestedManyWithoutSubmissionInput
    validations?: ValidationCreateNestedManyWithoutSubmissionInput
  }

  export type SubmissionUncheckedCreateWithoutDataRecordsInput = {
    id?: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: SubmissionCreatevalidationTypeInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutSubmissionInput
    qcResults?: QcResultUncheckedCreateNestedManyWithoutSubmissionInput
    validations?: ValidationUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type SubmissionCreateOrConnectWithoutDataRecordsInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutDataRecordsInput, SubmissionUncheckedCreateWithoutDataRecordsInput>
  }

  export type AdditionalErrorUpdateManyInput = {
    where: AdditionalErrorWhereInput
    data: AdditionalErrorUpdateInput
  }

  export type AdditionalErrorDeleteManyInput = {
    where: AdditionalErrorWhereInput
  }

  export type ErrorUpdateManyInput = {
    where: ErrorWhereInput
    data: ErrorUpdateInput
  }

  export type ErrorDeleteManyInput = {
    where: ErrorWhereInput
  }

  export type ParentUpdateManyInput = {
    where: ParentWhereInput
    data: ParentUpdateInput
  }

  export type ParentDeleteManyInput = {
    where: ParentWhereInput
  }

  export type S3FileInfoUpsertInput = {
    set: S3FileInfoCreateInput | null
    update: S3FileInfoUpdateInput
  }

  export type SubmissionUpsertWithoutDataRecordsInput = {
    update: XOR<SubmissionUpdateWithoutDataRecordsInput, SubmissionUncheckedUpdateWithoutDataRecordsInput>
    create: XOR<SubmissionCreateWithoutDataRecordsInput, SubmissionUncheckedCreateWithoutDataRecordsInput>
    where?: SubmissionWhereInput
  }

  export type SubmissionUpdateToOneWithWhereWithoutDataRecordsInput = {
    where?: SubmissionWhereInput
    data: XOR<SubmissionUpdateWithoutDataRecordsInput, SubmissionUncheckedUpdateWithoutDataRecordsInput>
  }

  export type SubmissionUpdateWithoutDataRecordsInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUpdateManyWithoutSubmissionNestedInput
    qcResults?: QcResultUpdateManyWithoutSubmissionNestedInput
    validations?: ValidationUpdateManyWithoutSubmissionNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutDataRecordsInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutSubmissionNestedInput
    qcResults?: QcResultUncheckedUpdateManyWithoutSubmissionNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type LogsEventDetailCreatenodeIDsInput = {
    set: string[]
  }

  export type LogsEventDetailUpsertInput = {
    set: LogsEventDetailCreateInput | null
    update: LogsEventDetailUpdateInput
  }

  export type UserCreateWithoutProgramsInput = {
    id?: string
    IDP: string
    dataCommons?: UserCreatedataCommonsInput | string[]
    email: string
    firstName: string
    institution?: XOR<InstitutionInfoNullableCreateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName: string
    notifications?: UserCreatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableCreateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserCreatepermissionsInput | string[]
    role: string
    status?: string | null
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserCreatetokensInput | string[]
    userStatus: string
    createdAt?: Date | string
    updateAt?: Date | string
    approvedStudies?: ApprovedStudyCreateNestedManyWithoutConciergeInput
  }

  export type UserUncheckedCreateWithoutProgramsInput = {
    id?: string
    IDP: string
    dataCommons?: UserCreatedataCommonsInput | string[]
    email: string
    firstName: string
    institution?: XOR<InstitutionInfoNullableCreateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName: string
    notifications?: UserCreatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableCreateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserCreatepermissionsInput | string[]
    role: string
    status?: string | null
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserCreatetokensInput | string[]
    userStatus: string
    createdAt?: Date | string
    updateAt?: Date | string
    approvedStudies?: ApprovedStudyUncheckedCreateNestedManyWithoutConciergeInput
  }

  export type UserCreateOrConnectWithoutProgramsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgramsInput, UserUncheckedCreateWithoutProgramsInput>
  }

  export type StudyByIDUpdateManyInput = {
    where: StudyByIDWhereInput
    data: StudyByIDUpdateInput
  }

  export type StudyByIDDeleteManyInput = {
    where: StudyByIDWhereInput
  }

  export type UserUpsertWithoutProgramsInput = {
    update: XOR<UserUpdateWithoutProgramsInput, UserUncheckedUpdateWithoutProgramsInput>
    create: XOR<UserCreateWithoutProgramsInput, UserUncheckedCreateWithoutProgramsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProgramsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProgramsInput, UserUncheckedUpdateWithoutProgramsInput>
  }

  export type UserUpdateWithoutProgramsInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    dataCommons?: UserUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionInfoNullableUpdateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: UserUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserUpdatetokensInput | string[]
    userStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedStudies?: ApprovedStudyUpdateManyWithoutConciergeNestedInput
  }

  export type UserUncheckedUpdateWithoutProgramsInput = {
    IDP?: StringFieldUpdateOperationsInput | string
    dataCommons?: UserUpdatedataCommonsInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    institution?: XOR<InstitutionInfoNullableUpdateEnvelopeInput, InstitutionInfoCreateInput> | null
    lastName?: StringFieldUpdateOperationsInput | string
    notifications?: UserUpdatenotificationsInput | string[]
    organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    permissions?: UserUpdatepermissionsInput | string[]
    role?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    tokens?: UserUpdatetokensInput | string[]
    userStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedStudies?: ApprovedStudyUncheckedUpdateManyWithoutConciergeNestedInput
  }

  export type SubmissionCreateWithoutQcResultsInput = {
    id?: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: SubmissionCreatevalidationTypeInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchCreateNestedManyWithoutSubmissionInput
    dataRecords?: DataRecordCreateNestedManyWithoutSubmissionInput
    validations?: ValidationCreateNestedManyWithoutSubmissionInput
  }

  export type SubmissionUncheckedCreateWithoutQcResultsInput = {
    id?: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: SubmissionCreatevalidationTypeInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutSubmissionInput
    dataRecords?: DataRecordUncheckedCreateNestedManyWithoutSubmissionInput
    validations?: ValidationUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type SubmissionCreateOrConnectWithoutQcResultsInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutQcResultsInput, SubmissionUncheckedCreateWithoutQcResultsInput>
  }

  export type SubmissionUpsertWithoutQcResultsInput = {
    update: XOR<SubmissionUpdateWithoutQcResultsInput, SubmissionUncheckedUpdateWithoutQcResultsInput>
    create: XOR<SubmissionCreateWithoutQcResultsInput, SubmissionUncheckedCreateWithoutQcResultsInput>
    where?: SubmissionWhereInput
  }

  export type SubmissionUpdateToOneWithWhereWithoutQcResultsInput = {
    where?: SubmissionWhereInput
    data: XOR<SubmissionUpdateWithoutQcResultsInput, SubmissionUncheckedUpdateWithoutQcResultsInput>
  }

  export type SubmissionUpdateWithoutQcResultsInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUpdateManyWithoutSubmissionNestedInput
    dataRecords?: DataRecordUpdateManyWithoutSubmissionNestedInput
    validations?: ValidationUpdateManyWithoutSubmissionNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutQcResultsInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutSubmissionNestedInput
    dataRecords?: DataRecordUncheckedUpdateManyWithoutSubmissionNestedInput
    validations?: ValidationUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type BatchCreateWithoutSubmissionInput = {
    id?: string
    bucketName: string
    displayID: number
    errors?: BatchCreateerrorsInput | string[]
    fileCount: number
    filePrefix: string
    files?: XOR<BatchFilesListCreateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status: string
    submitterID?: string | null
    submitterName?: string | null
    type: string
    zipFileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUncheckedCreateWithoutSubmissionInput = {
    id?: string
    bucketName: string
    displayID: number
    errors?: BatchCreateerrorsInput | string[]
    fileCount: number
    filePrefix: string
    files?: XOR<BatchFilesListCreateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status: string
    submitterID?: string | null
    submitterName?: string | null
    type: string
    zipFileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchCreateOrConnectWithoutSubmissionInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutSubmissionInput, BatchUncheckedCreateWithoutSubmissionInput>
  }

  export type BatchCreateManySubmissionInputEnvelope = {
    data: BatchCreateManySubmissionInput | BatchCreateManySubmissionInput[]
  }

  export type DataRecordCreateWithoutSubmissionInput = {
    id?: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordCreatebatchIDsInput | string[]
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID: string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRecordUncheckedCreateWithoutSubmissionInput = {
    id?: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordCreatebatchIDsInput | string[]
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID: string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRecordCreateOrConnectWithoutSubmissionInput = {
    where: DataRecordWhereUniqueInput
    create: XOR<DataRecordCreateWithoutSubmissionInput, DataRecordUncheckedCreateWithoutSubmissionInput>
  }

  export type DataRecordCreateManySubmissionInputEnvelope = {
    data: DataRecordCreateManySubmissionInput | DataRecordCreateManySubmissionInput[]
  }

  export type QcResultCreateWithoutSubmissionInput = {
    id?: string
    batchIDs?: QcResultCreatebatchIDsInput | string[]
    dataRecordID: string
    displayID: number
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID: string
    origin?: string | null
    severity: string
    submittedID: string
    type: string
    uploadedDate: Date | string
    validatedDate: Date | string
    validationType: string
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type QcResultUncheckedCreateWithoutSubmissionInput = {
    id?: string
    batchIDs?: QcResultCreatebatchIDsInput | string[]
    dataRecordID: string
    displayID: number
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID: string
    origin?: string | null
    severity: string
    submittedID: string
    type: string
    uploadedDate: Date | string
    validatedDate: Date | string
    validationType: string
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type QcResultCreateOrConnectWithoutSubmissionInput = {
    where: QcResultWhereUniqueInput
    create: XOR<QcResultCreateWithoutSubmissionInput, QcResultUncheckedCreateWithoutSubmissionInput>
  }

  export type QcResultCreateManySubmissionInputEnvelope = {
    data: QcResultCreateManySubmissionInput | QcResultCreateManySubmissionInput[]
  }

  export type ValidationCreateWithoutSubmissionInput = {
    id?: string
    ended?: Date | string | null
    scope?: string | null
    started: Date | string
    status?: string | null
    type?: ValidationCreatetypeInput | string[]
  }

  export type ValidationUncheckedCreateWithoutSubmissionInput = {
    id?: string
    ended?: Date | string | null
    scope?: string | null
    started: Date | string
    status?: string | null
    type?: ValidationCreatetypeInput | string[]
  }

  export type ValidationCreateOrConnectWithoutSubmissionInput = {
    where: ValidationWhereUniqueInput
    create: XOR<ValidationCreateWithoutSubmissionInput, ValidationUncheckedCreateWithoutSubmissionInput>
  }

  export type ValidationCreateManySubmissionInputEnvelope = {
    data: ValidationCreateManySubmissionInput | ValidationCreateManySubmissionInput[]
  }

  export type CollaboratorUpdateManyInput = {
    where: CollaboratorWhereInput
    data: CollaboratorUpdateInput
  }

  export type CollaboratorDeleteManyInput = {
    where: CollaboratorWhereInput
  }

  export type DataFileSizeUpdateInput = {
    formatted?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
  }

  export type BatchUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutSubmissionInput, BatchUncheckedUpdateWithoutSubmissionInput>
    create: XOR<BatchCreateWithoutSubmissionInput, BatchUncheckedCreateWithoutSubmissionInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutSubmissionInput, BatchUncheckedUpdateWithoutSubmissionInput>
  }

  export type BatchUpdateManyWithWhereWithoutSubmissionInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type BatchScalarWhereInput = {
    AND?: BatchScalarWhereInput | BatchScalarWhereInput[]
    OR?: BatchScalarWhereInput[]
    NOT?: BatchScalarWhereInput | BatchScalarWhereInput[]
    id?: StringFilter<"Batch"> | string
    bucketName?: StringFilter<"Batch"> | string
    displayID?: IntFilter<"Batch"> | number
    errors?: StringNullableListFilter<"Batch">
    fileCount?: IntFilter<"Batch"> | number
    filePrefix?: StringFilter<"Batch"> | string
    status?: StringFilter<"Batch"> | string
    submissionID?: StringFilter<"Batch"> | string
    submitterID?: StringNullableFilter<"Batch"> | string | null
    submitterName?: StringNullableFilter<"Batch"> | string | null
    type?: StringFilter<"Batch"> | string
    zipFileName?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
  }

  export type DataRecordUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: DataRecordWhereUniqueInput
    update: XOR<DataRecordUpdateWithoutSubmissionInput, DataRecordUncheckedUpdateWithoutSubmissionInput>
    create: XOR<DataRecordCreateWithoutSubmissionInput, DataRecordUncheckedCreateWithoutSubmissionInput>
  }

  export type DataRecordUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: DataRecordWhereUniqueInput
    data: XOR<DataRecordUpdateWithoutSubmissionInput, DataRecordUncheckedUpdateWithoutSubmissionInput>
  }

  export type DataRecordUpdateManyWithWhereWithoutSubmissionInput = {
    where: DataRecordScalarWhereInput
    data: XOR<DataRecordUpdateManyMutationInput, DataRecordUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type DataRecordScalarWhereInput = {
    AND?: DataRecordScalarWhereInput | DataRecordScalarWhereInput[]
    OR?: DataRecordScalarWhereInput[]
    NOT?: DataRecordScalarWhereInput | DataRecordScalarWhereInput[]
    id?: StringFilter<"DataRecord"> | string
    CRDC_ID?: StringNullableFilter<"DataRecord"> | string | null
    IDPropName?: StringFilter<"DataRecord"> | string
    batchIDs?: StringNullableListFilter<"DataRecord">
    dataCommons?: StringFilter<"DataRecord"> | string
    entityType?: StringNullableFilter<"DataRecord"> | string | null
    latestBatchDisplayID?: IntFilter<"DataRecord"> | number
    latestBatchID?: StringFilter<"DataRecord"> | string
    lineNumber?: IntFilter<"DataRecord"> | number
    nodeID?: StringFilter<"DataRecord"> | string
    nodeType?: StringFilter<"DataRecord"> | string
    orginalFileName?: StringFilter<"DataRecord"> | string
    props?: JsonFilter<"DataRecord">
    qcResultID?: StringNullableFilter<"DataRecord"> | string | null
    rawData?: JsonFilter<"DataRecord">
    status?: StringFilter<"DataRecord"> | string
    studyID?: StringFilter<"DataRecord"> | string
    submissionID?: StringFilter<"DataRecord"> | string
    uploadedDate?: DateTimeFilter<"DataRecord"> | Date | string
    validatedAt?: DateTimeNullableFilter<"DataRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"DataRecord"> | Date | string
    updatedAt?: DateTimeFilter<"DataRecord"> | Date | string
  }

  export type QcResultUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: QcResultWhereUniqueInput
    update: XOR<QcResultUpdateWithoutSubmissionInput, QcResultUncheckedUpdateWithoutSubmissionInput>
    create: XOR<QcResultCreateWithoutSubmissionInput, QcResultUncheckedCreateWithoutSubmissionInput>
  }

  export type QcResultUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: QcResultWhereUniqueInput
    data: XOR<QcResultUpdateWithoutSubmissionInput, QcResultUncheckedUpdateWithoutSubmissionInput>
  }

  export type QcResultUpdateManyWithWhereWithoutSubmissionInput = {
    where: QcResultScalarWhereInput
    data: XOR<QcResultUpdateManyMutationInput, QcResultUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type QcResultScalarWhereInput = {
    AND?: QcResultScalarWhereInput | QcResultScalarWhereInput[]
    OR?: QcResultScalarWhereInput[]
    NOT?: QcResultScalarWhereInput | QcResultScalarWhereInput[]
    id?: StringFilter<"QcResult"> | string
    batchIDs?: StringNullableListFilter<"QcResult">
    dataRecordID?: StringFilter<"QcResult"> | string
    displayID?: IntFilter<"QcResult"> | number
    latestBatchID?: StringFilter<"QcResult"> | string
    origin?: StringNullableFilter<"QcResult"> | string | null
    severity?: StringFilter<"QcResult"> | string
    submissionID?: StringFilter<"QcResult"> | string
    submittedID?: StringFilter<"QcResult"> | string
    type?: StringFilter<"QcResult"> | string
    uploadedDate?: DateTimeFilter<"QcResult"> | Date | string
    validatedDate?: DateTimeFilter<"QcResult"> | Date | string
    validationType?: StringFilter<"QcResult"> | string
  }

  export type ValidationUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: ValidationWhereUniqueInput
    update: XOR<ValidationUpdateWithoutSubmissionInput, ValidationUncheckedUpdateWithoutSubmissionInput>
    create: XOR<ValidationCreateWithoutSubmissionInput, ValidationUncheckedCreateWithoutSubmissionInput>
  }

  export type ValidationUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: ValidationWhereUniqueInput
    data: XOR<ValidationUpdateWithoutSubmissionInput, ValidationUncheckedUpdateWithoutSubmissionInput>
  }

  export type ValidationUpdateManyWithWhereWithoutSubmissionInput = {
    where: ValidationScalarWhereInput
    data: XOR<ValidationUpdateManyMutationInput, ValidationUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type ValidationScalarWhereInput = {
    AND?: ValidationScalarWhereInput | ValidationScalarWhereInput[]
    OR?: ValidationScalarWhereInput[]
    NOT?: ValidationScalarWhereInput | ValidationScalarWhereInput[]
    id?: StringFilter<"Validation"> | string
    ended?: DateTimeNullableFilter<"Validation"> | Date | string | null
    scope?: StringNullableFilter<"Validation"> | string | null
    started?: DateTimeFilter<"Validation"> | Date | string
    status?: StringNullableFilter<"Validation"> | string | null
    submissionID?: StringFilter<"Validation"> | string
    type?: StringNullableListFilter<"Validation">
  }

  export type ProgramCreateWithoutConciergeInput = {
    id?: string
    abbreviation?: string | null
    bucketName?: string | null
    conciergeEmail?: string | null
    conciergeName?: string | null
    description?: string | null
    name: string
    rootPath?: string | null
    status: string
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramUncheckedCreateWithoutConciergeInput = {
    id?: string
    abbreviation?: string | null
    bucketName?: string | null
    conciergeEmail?: string | null
    conciergeName?: string | null
    description?: string | null
    name: string
    rootPath?: string | null
    status: string
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramCreateOrConnectWithoutConciergeInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutConciergeInput, ProgramUncheckedCreateWithoutConciergeInput>
  }

  export type ProgramCreateManyConciergeInputEnvelope = {
    data: ProgramCreateManyConciergeInput | ProgramCreateManyConciergeInput[]
  }

  export type ApprovedStudyCreateWithoutConciergeInput = {
    id?: string
    ORCID?: string | null
    PI?: string | null
    controlledAccess: boolean
    dbGaPID?: string | null
    openAccess?: boolean | null
    originalOrg?: string | null
    programName?: string | null
    studyAbbreviation: string
    studyName: string
    useProgramPC?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovedStudyUncheckedCreateWithoutConciergeInput = {
    id?: string
    ORCID?: string | null
    PI?: string | null
    controlledAccess: boolean
    dbGaPID?: string | null
    openAccess?: boolean | null
    originalOrg?: string | null
    programName?: string | null
    studyAbbreviation: string
    studyName: string
    useProgramPC?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovedStudyCreateOrConnectWithoutConciergeInput = {
    where: ApprovedStudyWhereUniqueInput
    create: XOR<ApprovedStudyCreateWithoutConciergeInput, ApprovedStudyUncheckedCreateWithoutConciergeInput>
  }

  export type ApprovedStudyCreateManyConciergeInputEnvelope = {
    data: ApprovedStudyCreateManyConciergeInput | ApprovedStudyCreateManyConciergeInput[]
  }

  export type InstitutionInfoUpsertInput = {
    set: InstitutionInfoCreateInput | null
    update: InstitutionInfoUpdateInput
  }

  export type OrgInfoUpsertInput = {
    set: OrgInfoCreateInput | null
    update: OrgInfoUpdateInput
  }

  export type ProgramUpsertWithWhereUniqueWithoutConciergeInput = {
    where: ProgramWhereUniqueInput
    update: XOR<ProgramUpdateWithoutConciergeInput, ProgramUncheckedUpdateWithoutConciergeInput>
    create: XOR<ProgramCreateWithoutConciergeInput, ProgramUncheckedCreateWithoutConciergeInput>
  }

  export type ProgramUpdateWithWhereUniqueWithoutConciergeInput = {
    where: ProgramWhereUniqueInput
    data: XOR<ProgramUpdateWithoutConciergeInput, ProgramUncheckedUpdateWithoutConciergeInput>
  }

  export type ProgramUpdateManyWithWhereWithoutConciergeInput = {
    where: ProgramScalarWhereInput
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutConciergeInput>
  }

  export type ProgramScalarWhereInput = {
    AND?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    OR?: ProgramScalarWhereInput[]
    NOT?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    id?: StringFilter<"Program"> | string
    abbreviation?: StringNullableFilter<"Program"> | string | null
    bucketName?: StringNullableFilter<"Program"> | string | null
    conciergeEmail?: StringNullableFilter<"Program"> | string | null
    conciergeID?: StringNullableFilter<"Program"> | string | null
    conciergeName?: StringNullableFilter<"Program"> | string | null
    description?: StringNullableFilter<"Program"> | string | null
    name?: StringFilter<"Program"> | string
    rootPath?: StringNullableFilter<"Program"> | string | null
    status?: StringFilter<"Program"> | string
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updateAt?: DateTimeFilter<"Program"> | Date | string
  }

  export type ApprovedStudyUpsertWithWhereUniqueWithoutConciergeInput = {
    where: ApprovedStudyWhereUniqueInput
    update: XOR<ApprovedStudyUpdateWithoutConciergeInput, ApprovedStudyUncheckedUpdateWithoutConciergeInput>
    create: XOR<ApprovedStudyCreateWithoutConciergeInput, ApprovedStudyUncheckedCreateWithoutConciergeInput>
  }

  export type ApprovedStudyUpdateWithWhereUniqueWithoutConciergeInput = {
    where: ApprovedStudyWhereUniqueInput
    data: XOR<ApprovedStudyUpdateWithoutConciergeInput, ApprovedStudyUncheckedUpdateWithoutConciergeInput>
  }

  export type ApprovedStudyUpdateManyWithWhereWithoutConciergeInput = {
    where: ApprovedStudyScalarWhereInput
    data: XOR<ApprovedStudyUpdateManyMutationInput, ApprovedStudyUncheckedUpdateManyWithoutConciergeInput>
  }

  export type ApprovedStudyScalarWhereInput = {
    AND?: ApprovedStudyScalarWhereInput | ApprovedStudyScalarWhereInput[]
    OR?: ApprovedStudyScalarWhereInput[]
    NOT?: ApprovedStudyScalarWhereInput | ApprovedStudyScalarWhereInput[]
    id?: StringFilter<"ApprovedStudy"> | string
    ORCID?: StringNullableFilter<"ApprovedStudy"> | string | null
    PI?: StringNullableFilter<"ApprovedStudy"> | string | null
    controlledAccess?: BoolFilter<"ApprovedStudy"> | boolean
    dbGaPID?: StringNullableFilter<"ApprovedStudy"> | string | null
    openAccess?: BoolNullableFilter<"ApprovedStudy"> | boolean | null
    originalOrg?: StringNullableFilter<"ApprovedStudy"> | string | null
    primaryContactID?: StringNullableFilter<"ApprovedStudy"> | string | null
    programName?: StringNullableFilter<"ApprovedStudy"> | string | null
    studyAbbreviation?: StringFilter<"ApprovedStudy"> | string
    studyName?: StringFilter<"ApprovedStudy"> | string
    useProgramPC?: BoolNullableFilter<"ApprovedStudy"> | boolean | null
    createdAt?: DateTimeFilter<"ApprovedStudy"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovedStudy"> | Date | string
  }

  export type SubmissionCreateWithoutValidationsInput = {
    id?: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: SubmissionCreatevalidationTypeInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchCreateNestedManyWithoutSubmissionInput
    dataRecords?: DataRecordCreateNestedManyWithoutSubmissionInput
    qcResults?: QcResultCreateNestedManyWithoutSubmissionInput
  }

  export type SubmissionUncheckedCreateWithoutValidationsInput = {
    id?: string
    ORCID?: string | null
    accessedAt: Date | string
    archived?: boolean | null
    bucketName: string
    collaborators?: XOR<CollaboratorListCreateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: string | null
    conciergeName?: string | null
    controlledAccess?: boolean | null
    crossSubmissionStatus?: string | null
    dataCommons: string
    dataCommonsDisplayName?: string | null
    dataFileSize: XOR<DataFileSizeCreateEnvelopeInput, DataFileSizeCreateInput>
    dataType: string
    dbGaPID?: string | null
    deletingData?: boolean | null
    fileValidationStatus?: string | null
    finalInactiveReminder?: boolean | null
    history?: XOR<HistoryListCreateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: boolean | null
    inactiveReminder_30?: boolean | null
    inactiveReminder_60?: boolean | null
    inactiveReminder_7?: boolean | null
    intention: string
    metadataValidationStatus?: string | null
    modelVersion: string
    name: string
    nodeCount?: number | null
    organization: XOR<OrgInfoCreateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: string | null
    rootPath: string
    status: string
    studyAbbreviation?: string | null
    studyID: string
    submitterID: string
    submitterName: string
    validationEnded?: Date | string | null
    validationScope?: string | null
    validationStarted?: Date | string | null
    validationType?: SubmissionCreatevalidationTypeInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutSubmissionInput
    dataRecords?: DataRecordUncheckedCreateNestedManyWithoutSubmissionInput
    qcResults?: QcResultUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type SubmissionCreateOrConnectWithoutValidationsInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutValidationsInput, SubmissionUncheckedCreateWithoutValidationsInput>
  }

  export type SubmissionUpsertWithoutValidationsInput = {
    update: XOR<SubmissionUpdateWithoutValidationsInput, SubmissionUncheckedUpdateWithoutValidationsInput>
    create: XOR<SubmissionCreateWithoutValidationsInput, SubmissionUncheckedCreateWithoutValidationsInput>
    where?: SubmissionWhereInput
  }

  export type SubmissionUpdateToOneWithWhereWithoutValidationsInput = {
    where?: SubmissionWhereInput
    data: XOR<SubmissionUpdateWithoutValidationsInput, SubmissionUncheckedUpdateWithoutValidationsInput>
  }

  export type SubmissionUpdateWithoutValidationsInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUpdateManyWithoutSubmissionNestedInput
    dataRecords?: DataRecordUpdateManyWithoutSubmissionNestedInput
    qcResults?: QcResultUpdateManyWithoutSubmissionNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutValidationsInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    accessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bucketName?: StringFieldUpdateOperationsInput | string
    collaborators?: XOR<CollaboratorListUpdateEnvelopeInput, CollaboratorCreateInput> | CollaboratorCreateInput[]
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    crossSubmissionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    dataCommons?: StringFieldUpdateOperationsInput | string
    dataCommonsDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    dataFileSize?: XOR<DataFileSizeUpdateEnvelopeInput, DataFileSizeCreateInput>
    dataType?: StringFieldUpdateOperationsInput | string
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    deletingData?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fileValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    finalInactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    history?: XOR<HistoryListUpdateEnvelopeInput, HistoryCreateInput> | HistoryCreateInput[]
    inactiveReminder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_60?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inactiveReminder_7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    intention?: StringFieldUpdateOperationsInput | string
    metadataValidationStatus?: NullableStringFieldUpdateOperationsInput | string | null
    modelVersion?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nodeCount?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: XOR<OrgInfoUpdateEnvelopeInput, OrgInfoCreateInput>
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    rootPath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    studyAbbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    studyID?: StringFieldUpdateOperationsInput | string
    submitterID?: StringFieldUpdateOperationsInput | string
    submitterName?: StringFieldUpdateOperationsInput | string
    validationEnded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationScope?: NullableStringFieldUpdateOperationsInput | string | null
    validationStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validationType?: SubmissionUpdatevalidationTypeInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutSubmissionNestedInput
    dataRecords?: DataRecordUncheckedUpdateManyWithoutSubmissionNestedInput
    qcResults?: QcResultUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type NotificationCompositeListFilter = {
    equals?: NotificationObjectEqualityInput[]
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type PermissionCompositeListFilter = {
    equals?: PermissionObjectEqualityInput[]
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type HistoryUpdateInput = {
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewComment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatchFilesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errors?: BatchFilesUpdateerrorsInput | string[]
    fileID?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePrefix?: StringFieldUpdateOperationsInput | string
    nodeType?: NullableStringFieldUpdateOperationsInput | string | null
    signedURL?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateinheritedInput = {
    set: string[]
  }

  export type PBACDefaultsUpdateInput = {
    notifications?: XOR<NotificationListUpdateEnvelopeInput, NotificationCreateInput> | NotificationCreateInput[]
    permissions?: XOR<PermissionListUpdateEnvelopeInput, PermissionCreateInput> | PermissionCreateInput[]
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ConfigurationTagUpdateInput = {
    Key?: StringFieldUpdateOperationsInput | string
    Value?: StringFieldUpdateOperationsInput | string
  }

  export type AdditionalErrorUpdateInput = {
    conflictingSubmissions?: AdditionalErrorUpdateconflictingSubmissionsInput | string[]
    description?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type ErrorUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    offendingProperty?: NullableStringFieldUpdateOperationsInput | string | null
    offendingValue?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParentUpdateInput = {
    parentIDPropName?: StringFieldUpdateOperationsInput | string
    parentIDValue?: StringFieldUpdateOperationsInput | string
    parentType?: StringFieldUpdateOperationsInput | string
  }

  export type S3FileInfoUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    fileName?: StringFieldUpdateOperationsInput | string
    md5?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type LogsEventDetailUpdateInput = {
    nodeIDs?: LogsEventDetailUpdatenodeIDsInput | string[]
    nodeType?: StringFieldUpdateOperationsInput | string
    submissionID?: StringFieldUpdateOperationsInput | string
  }

  export type StudyByIDUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BatchCreateManySubmissionInput = {
    id?: string
    bucketName: string
    displayID: number
    errors?: BatchCreateerrorsInput | string[]
    fileCount: number
    filePrefix: string
    files?: XOR<BatchFilesListCreateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status: string
    submitterID?: string | null
    submitterName?: string | null
    type: string
    zipFileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataRecordCreateManySubmissionInput = {
    id?: string
    CRDC_ID?: string | null
    IDPropName: string
    additionalErrors?: XOR<AdditionalErrorListCreateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordCreatebatchIDsInput | string[]
    dataCommons: string
    entityType?: string | null
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID: number
    latestBatchID: string
    lineNumber: number
    nodeID: string
    nodeType: string
    orginalFileName: string
    parents?: XOR<ParentListCreateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props: InputJsonValue
    qcResultID?: string | null
    rawData: InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableCreateEnvelopeInput, S3FileInfoCreateInput> | null
    status: string
    studyID: string
    uploadedDate: Date | string
    validatedAt?: Date | string | null
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QcResultCreateManySubmissionInput = {
    id?: string
    batchIDs?: QcResultCreatebatchIDsInput | string[]
    dataRecordID: string
    displayID: number
    errors?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID: string
    origin?: string | null
    severity: string
    submittedID: string
    type: string
    uploadedDate: Date | string
    validatedDate: Date | string
    validationType: string
    warnings?: XOR<ErrorListCreateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type ValidationCreateManySubmissionInput = {
    id?: string
    ended?: Date | string | null
    scope?: string | null
    started: Date | string
    status?: string | null
    type?: ValidationCreatetypeInput | string[]
  }

  export type CollaboratorUpdateInput = {
    Organization?: XOR<OrgInfoNullableUpdateEnvelopeInput, OrgInfoCreateInput> | null
    collaboratorID?: StringFieldUpdateOperationsInput | string
    collaboratorName?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: InputJsonValue | InputJsonValue
  }

  export type BatchUpdateWithoutSubmissionInput = {
    bucketName?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: BatchUpdateerrorsInput | string[]
    fileCount?: IntFieldUpdateOperationsInput | number
    filePrefix?: StringFieldUpdateOperationsInput | string
    files?: XOR<BatchFilesListUpdateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status?: StringFieldUpdateOperationsInput | string
    submitterID?: NullableStringFieldUpdateOperationsInput | string | null
    submitterName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    zipFileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUncheckedUpdateWithoutSubmissionInput = {
    bucketName?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: BatchUpdateerrorsInput | string[]
    fileCount?: IntFieldUpdateOperationsInput | number
    filePrefix?: StringFieldUpdateOperationsInput | string
    files?: XOR<BatchFilesListUpdateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status?: StringFieldUpdateOperationsInput | string
    submitterID?: NullableStringFieldUpdateOperationsInput | string | null
    submitterName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    zipFileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUncheckedUpdateManyWithoutSubmissionInput = {
    bucketName?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: BatchUpdateerrorsInput | string[]
    fileCount?: IntFieldUpdateOperationsInput | number
    filePrefix?: StringFieldUpdateOperationsInput | string
    files?: XOR<BatchFilesListUpdateEnvelopeInput, BatchFilesCreateInput> | BatchFilesCreateInput[]
    status?: StringFieldUpdateOperationsInput | string
    submitterID?: NullableStringFieldUpdateOperationsInput | string | null
    submitterName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    zipFileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRecordUpdateWithoutSubmissionInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordUpdatebatchIDsInput | string[]
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRecordUncheckedUpdateWithoutSubmissionInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordUpdatebatchIDsInput | string[]
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRecordUncheckedUpdateManyWithoutSubmissionInput = {
    CRDC_ID?: NullableStringFieldUpdateOperationsInput | string | null
    IDPropName?: StringFieldUpdateOperationsInput | string
    additionalErrors?: XOR<AdditionalErrorListUpdateEnvelopeInput, AdditionalErrorCreateInput> | AdditionalErrorCreateInput[]
    batchIDs?: DataRecordUpdatebatchIDsInput | string[]
    dataCommons?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchDisplayID?: IntFieldUpdateOperationsInput | number
    latestBatchID?: StringFieldUpdateOperationsInput | string
    lineNumber?: IntFieldUpdateOperationsInput | number
    nodeID?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    orginalFileName?: StringFieldUpdateOperationsInput | string
    parents?: XOR<ParentListUpdateEnvelopeInput, ParentCreateInput> | ParentCreateInput[]
    props?: InputJsonValue | InputJsonValue
    qcResultID?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: InputJsonValue | InputJsonValue
    s3FileInfo?: XOR<S3FileInfoNullableUpdateEnvelopeInput, S3FileInfoCreateInput> | null
    status?: StringFieldUpdateOperationsInput | string
    studyID?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QcResultUpdateWithoutSubmissionInput = {
    batchIDs?: QcResultUpdatebatchIDsInput | string[]
    dataRecordID?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    submittedID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validationType?: StringFieldUpdateOperationsInput | string
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type QcResultUncheckedUpdateWithoutSubmissionInput = {
    batchIDs?: QcResultUpdatebatchIDsInput | string[]
    dataRecordID?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    submittedID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validationType?: StringFieldUpdateOperationsInput | string
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type QcResultUncheckedUpdateManyWithoutSubmissionInput = {
    batchIDs?: QcResultUpdatebatchIDsInput | string[]
    dataRecordID?: StringFieldUpdateOperationsInput | string
    displayID?: IntFieldUpdateOperationsInput | number
    errors?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
    latestBatchID?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    submittedID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    validationType?: StringFieldUpdateOperationsInput | string
    warnings?: XOR<ErrorListUpdateEnvelopeInput, ErrorCreateInput> | ErrorCreateInput[]
  }

  export type ValidationUpdateWithoutSubmissionInput = {
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: ValidationUpdatetypeInput | string[]
  }

  export type ValidationUncheckedUpdateWithoutSubmissionInput = {
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: ValidationUpdatetypeInput | string[]
  }

  export type ValidationUncheckedUpdateManyWithoutSubmissionInput = {
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    started?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: ValidationUpdatetypeInput | string[]
  }

  export type ProgramCreateManyConciergeInput = {
    id?: string
    abbreviation?: string | null
    bucketName?: string | null
    conciergeEmail?: string | null
    conciergeName?: string | null
    description?: string | null
    name: string
    rootPath?: string | null
    status: string
    studies?: XOR<StudyByIDListCreateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type ApprovedStudyCreateManyConciergeInput = {
    id?: string
    ORCID?: string | null
    PI?: string | null
    controlledAccess: boolean
    dbGaPID?: string | null
    openAccess?: boolean | null
    originalOrg?: string | null
    programName?: string | null
    studyAbbreviation: string
    studyName: string
    useProgramPC?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstitutionInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramUpdateWithoutConciergeInput = {
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rootPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateWithoutConciergeInput = {
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rootPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateManyWithoutConciergeInput = {
    abbreviation?: NullableStringFieldUpdateOperationsInput | string | null
    bucketName?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    conciergeName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    rootPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    studies?: XOR<StudyByIDListUpdateEnvelopeInput, StudyByIDCreateInput> | StudyByIDCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovedStudyUpdateWithoutConciergeInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: BoolFieldUpdateOperationsInput | boolean
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalOrg?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: NullableStringFieldUpdateOperationsInput | string | null
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    useProgramPC?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovedStudyUncheckedUpdateWithoutConciergeInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: BoolFieldUpdateOperationsInput | boolean
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalOrg?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: NullableStringFieldUpdateOperationsInput | string | null
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    useProgramPC?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovedStudyUncheckedUpdateManyWithoutConciergeInput = {
    ORCID?: NullableStringFieldUpdateOperationsInput | string | null
    PI?: NullableStringFieldUpdateOperationsInput | string | null
    controlledAccess?: BoolFieldUpdateOperationsInput | boolean
    dbGaPID?: NullableStringFieldUpdateOperationsInput | string | null
    openAccess?: NullableBoolFieldUpdateOperationsInput | boolean | null
    originalOrg?: NullableStringFieldUpdateOperationsInput | string | null
    programName?: NullableStringFieldUpdateOperationsInput | string | null
    studyAbbreviation?: StringFieldUpdateOperationsInput | string
    studyName?: StringFieldUpdateOperationsInput | string
    useProgramPC?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    checked?: BoolFilter<"Notification"> | boolean
    disabled?: BoolFilter<"Notification"> | boolean
    group?: StringFilter<"Notification"> | string
    name?: StringFilter<"Notification"> | string
    order?: IntFilter<"Notification"> | number
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    checked?: BoolFilter<"Permission"> | boolean
    disabled?: BoolFilter<"Permission"> | boolean
    group?: StringFilter<"Permission"> | string
    inherited?: StringNullableListFilter<"Permission">
    name?: StringFilter<"Permission"> | string
    order?: IntFilter<"Permission"> | number
  }

  export type BatchFilesUpdateerrorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NotificationListUpdateEnvelopeInput = {
    set?: NotificationCreateInput | NotificationCreateInput[]
    push?: NotificationCreateInput | NotificationCreateInput[]
    updateMany?: NotificationUpdateManyInput
    deleteMany?: NotificationDeleteManyInput
  }

  export type PermissionListUpdateEnvelopeInput = {
    set?: PermissionCreateInput | PermissionCreateInput[]
    push?: PermissionCreateInput | PermissionCreateInput[]
    updateMany?: PermissionUpdateManyInput
    deleteMany?: PermissionDeleteManyInput
  }

  export type AdditionalErrorUpdateconflictingSubmissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LogsEventDetailUpdatenodeIDsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NotificationUpdateManyInput = {
    where: NotificationWhereInput
    data: NotificationUpdateInput
  }

  export type NotificationDeleteManyInput = {
    where: NotificationWhereInput
  }

  export type PermissionUpdateManyInput = {
    where: PermissionWhereInput
    data: PermissionUpdateInput
  }

  export type PermissionDeleteManyInput = {
    where: PermissionWhereInput
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    group?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checked?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    group?: StringFieldUpdateOperationsInput | string
    inherited?: PermissionUpdateinheritedInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionUpdateinheritedInput = {
    set?: string[]
    push?: string | string[]
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}